
FreeRTOS_Semaphore.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002d0a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  00002d0a  00002d9e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002f0  00800068  00800068  00002da6  2**0
                  ALLOC
  3 .stab         00004b84  00000000  00000000  00002da8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002b8e  00000000  00000000  0000792c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 08 08 	jmp	0x1010	; 0x1010 <__vector_6>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e0       	ldi	r30, 0x0A	; 10
      68:	fd e2       	ldi	r31, 0x2D	; 45
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 36       	cpi	r26, 0x68	; 104
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a8 e6       	ldi	r26, 0x68	; 104
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 35       	cpi	r26, 0x58	; 88
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 7f 00 	call	0xfe	; 0xfe <main>
      8a:	0c 94 83 16 	jmp	0x2d06	; 0x2d06 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Blink_200ms_task>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <Blink_200ms_task+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	9a 83       	std	Y+2, r25	; 0x02
      9e:	89 83       	std	Y+1, r24	; 0x01
      a0:	aa e3       	ldi	r26, 0x3A	; 58
      a2:	b0 e0       	ldi	r27, 0x00	; 0
      a4:	ea e3       	ldi	r30, 0x3A	; 58
      a6:	f0 e0       	ldi	r31, 0x00	; 0
      a8:	80 81       	ld	r24, Z
      aa:	81 60       	ori	r24, 0x01	; 1
      ac:	8c 93       	st	X, r24
      ae:	ab e3       	ldi	r26, 0x3B	; 59
      b0:	b0 e0       	ldi	r27, 0x00	; 0
      b2:	eb e3       	ldi	r30, 0x3B	; 59
      b4:	f0 e0       	ldi	r31, 0x00	; 0
      b6:	90 81       	ld	r25, Z
      b8:	81 e0       	ldi	r24, 0x01	; 1
      ba:	89 27       	eor	r24, r25
      bc:	8c 93       	st	X, r24
      be:	88 ec       	ldi	r24, 0xC8	; 200
      c0:	90 e0       	ldi	r25, 0x00	; 0
      c2:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vTaskDelay>
      c6:	f3 cf       	rjmp	.-26     	; 0xae <Blink_200ms_task+0x1c>

000000c8 <Blink_1000ms_task>:
		vTaskDelay(200); //OS Delay
	}
}
//--------------------------------------------------
void Blink_1000ms_task( void *pvParameters)
{
      c8:	df 93       	push	r29
      ca:	cf 93       	push	r28
      cc:	00 d0       	rcall	.+0      	; 0xce <Blink_1000ms_task+0x6>
      ce:	cd b7       	in	r28, 0x3d	; 61
      d0:	de b7       	in	r29, 0x3e	; 62
      d2:	9a 83       	std	Y+2, r25	; 0x02
      d4:	89 83       	std	Y+1, r24	; 0x01
	DDRB |=(1<<0); //PB.0 is output
      d6:	a7 e3       	ldi	r26, 0x37	; 55
      d8:	b0 e0       	ldi	r27, 0x00	; 0
      da:	e7 e3       	ldi	r30, 0x37	; 55
      dc:	f0 e0       	ldi	r31, 0x00	; 0
      de:	80 81       	ld	r24, Z
      e0:	81 60       	ori	r24, 0x01	; 1
      e2:	8c 93       	st	X, r24
	
	while(1)
	{

		PORTB ^= (1<<0); //toggle PB.0
      e4:	a8 e3       	ldi	r26, 0x38	; 56
      e6:	b0 e0       	ldi	r27, 0x00	; 0
      e8:	e8 e3       	ldi	r30, 0x38	; 56
      ea:	f0 e0       	ldi	r31, 0x00	; 0
      ec:	90 81       	ld	r25, Z
      ee:	81 e0       	ldi	r24, 0x01	; 1
      f0:	89 27       	eor	r24, r25
      f2:	8c 93       	st	X, r24
		vTaskDelay(1000); //OS Delay
      f4:	88 ee       	ldi	r24, 0xE8	; 232
      f6:	93 e0       	ldi	r25, 0x03	; 3
      f8:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <vTaskDelay>
      fc:	f3 cf       	rjmp	.-26     	; 0xe4 <Blink_1000ms_task+0x1c>

000000fe <main>:

//================= [Main] ====================
#include <avr/io.h>

int main(void)
{
      fe:	af 92       	push	r10
     100:	bf 92       	push	r11
     102:	cf 92       	push	r12
     104:	df 92       	push	r13
     106:	ef 92       	push	r14
     108:	ff 92       	push	r15
     10a:	0f 93       	push	r16
     10c:	df 93       	push	r29
     10e:	cf 93       	push	r28
     110:	cd b7       	in	r28, 0x3d	; 61
     112:	de b7       	in	r29, 0x3e	; 62
	// Create Tasks
	xTaskCreate( Blink_200ms_task,NULL, configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     114:	89 e4       	ldi	r24, 0x49	; 73
     116:	90 e0       	ldi	r25, 0x00	; 0
     118:	60 e0       	ldi	r22, 0x00	; 0
     11a:	70 e0       	ldi	r23, 0x00	; 0
     11c:	45 e5       	ldi	r20, 0x55	; 85
     11e:	50 e0       	ldi	r21, 0x00	; 0
     120:	20 e0       	ldi	r18, 0x00	; 0
     122:	30 e0       	ldi	r19, 0x00	; 0
     124:	01 e0       	ldi	r16, 0x01	; 1
     126:	ee 24       	eor	r14, r14
     128:	ff 24       	eor	r15, r15
     12a:	cc 24       	eor	r12, r12
     12c:	dd 24       	eor	r13, r13
     12e:	aa 24       	eor	r10, r10
     130:	bb 24       	eor	r11, r11
     132:	0e 94 8c 0c 	call	0x1918	; 0x1918 <xTaskGenericCreate>
	xTaskCreate( Blink_1000ms_task,NULL, configMINIMAL_STACK_SIZE, NULL, 2, NULL );
     136:	84 e6       	ldi	r24, 0x64	; 100
     138:	90 e0       	ldi	r25, 0x00	; 0
     13a:	60 e0       	ldi	r22, 0x00	; 0
     13c:	70 e0       	ldi	r23, 0x00	; 0
     13e:	45 e5       	ldi	r20, 0x55	; 85
     140:	50 e0       	ldi	r21, 0x00	; 0
     142:	20 e0       	ldi	r18, 0x00	; 0
     144:	30 e0       	ldi	r19, 0x00	; 0
     146:	02 e0       	ldi	r16, 0x02	; 2
     148:	ee 24       	eor	r14, r14
     14a:	ff 24       	eor	r15, r15
     14c:	cc 24       	eor	r12, r12
     14e:	dd 24       	eor	r13, r13
     150:	aa 24       	eor	r10, r10
     152:	bb 24       	eor	r11, r11
     154:	0e 94 8c 0c 	call	0x1918	; 0x1918 <xTaskGenericCreate>

	// Start FreeRTOS
	vTaskStartScheduler();
     158:	0e 94 c3 10 	call	0x2186	; 0x2186 <vTaskStartScheduler>
     15c:	80 e0       	ldi	r24, 0x00	; 0
     15e:	90 e0       	ldi	r25, 0x00	; 0
	
}
     160:	cf 91       	pop	r28
     162:	df 91       	pop	r29
     164:	0f 91       	pop	r16
     166:	ff 90       	pop	r15
     168:	ef 90       	pop	r14
     16a:	df 90       	pop	r13
     16c:	cf 90       	pop	r12
     16e:	bf 90       	pop	r11
     170:	af 90       	pop	r10
     172:	08 95       	ret

00000174 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     174:	df 93       	push	r29
     176:	cf 93       	push	r28
     178:	cd b7       	in	r28, 0x3d	; 61
     17a:	de b7       	in	r29, 0x3e	; 62
     17c:	27 97       	sbiw	r28, 0x07	; 7
     17e:	0f b6       	in	r0, 0x3f	; 63
     180:	f8 94       	cli
     182:	de bf       	out	0x3e, r29	; 62
     184:	0f be       	out	0x3f, r0	; 63
     186:	cd bf       	out	0x3d, r28	; 61
     188:	9d 83       	std	Y+5, r25	; 0x05
     18a:	8c 83       	std	Y+4, r24	; 0x04
     18c:	6e 83       	std	Y+6, r22	; 0x06
     18e:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     190:	8a e1       	ldi	r24, 0x1A	; 26
     192:	90 e0       	ldi	r25, 0x00	; 0
     194:	0e 94 92 03 	call	0x724	; 0x724 <pvPortMalloc>
     198:	9a 83       	std	Y+2, r25	; 0x02
     19a:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     19c:	89 81       	ldd	r24, Y+1	; 0x01
     19e:	9a 81       	ldd	r25, Y+2	; 0x02
     1a0:	00 97       	sbiw	r24, 0x00	; 0
     1a2:	09 f4       	brne	.+2      	; 0x1a6 <xCoRoutineCreate+0x32>
     1a4:	6f c0       	rjmp	.+222    	; 0x284 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     1a6:	80 91 68 00 	lds	r24, 0x0068
     1aa:	90 91 69 00 	lds	r25, 0x0069
     1ae:	00 97       	sbiw	r24, 0x00	; 0
     1b0:	41 f4       	brne	.+16     	; 0x1c2 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     1b2:	89 81       	ldd	r24, Y+1	; 0x01
     1b4:	9a 81       	ldd	r25, Y+2	; 0x02
     1b6:	90 93 69 00 	sts	0x0069, r25
     1ba:	80 93 68 00 	sts	0x0068, r24
			prvInitialiseCoRoutineLists();
     1be:	0e 94 21 03 	call	0x642	; 0x642 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     1c2:	8e 81       	ldd	r24, Y+6	; 0x06
     1c4:	82 30       	cpi	r24, 0x02	; 2
     1c6:	10 f0       	brcs	.+4      	; 0x1cc <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     1c8:	81 e0       	ldi	r24, 0x01	; 1
     1ca:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     1cc:	e9 81       	ldd	r30, Y+1	; 0x01
     1ce:	fa 81       	ldd	r31, Y+2	; 0x02
     1d0:	11 8e       	std	Z+25, r1	; 0x19
     1d2:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     1d4:	e9 81       	ldd	r30, Y+1	; 0x01
     1d6:	fa 81       	ldd	r31, Y+2	; 0x02
     1d8:	8e 81       	ldd	r24, Y+6	; 0x06
     1da:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     1dc:	e9 81       	ldd	r30, Y+1	; 0x01
     1de:	fa 81       	ldd	r31, Y+2	; 0x02
     1e0:	8f 81       	ldd	r24, Y+7	; 0x07
     1e2:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     1e4:	e9 81       	ldd	r30, Y+1	; 0x01
     1e6:	fa 81       	ldd	r31, Y+2	; 0x02
     1e8:	8c 81       	ldd	r24, Y+4	; 0x04
     1ea:	9d 81       	ldd	r25, Y+5	; 0x05
     1ec:	91 83       	std	Z+1, r25	; 0x01
     1ee:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     1f0:	89 81       	ldd	r24, Y+1	; 0x01
     1f2:	9a 81       	ldd	r25, Y+2	; 0x02
     1f4:	02 96       	adiw	r24, 0x02	; 2
     1f6:	0e 94 28 04 	call	0x850	; 0x850 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	9a 81       	ldd	r25, Y+2	; 0x02
     1fe:	0c 96       	adiw	r24, 0x0c	; 12
     200:	0e 94 28 04 	call	0x850	; 0x850 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     204:	e9 81       	ldd	r30, Y+1	; 0x01
     206:	fa 81       	ldd	r31, Y+2	; 0x02
     208:	89 81       	ldd	r24, Y+1	; 0x01
     20a:	9a 81       	ldd	r25, Y+2	; 0x02
     20c:	91 87       	std	Z+9, r25	; 0x09
     20e:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     210:	e9 81       	ldd	r30, Y+1	; 0x01
     212:	fa 81       	ldd	r31, Y+2	; 0x02
     214:	89 81       	ldd	r24, Y+1	; 0x01
     216:	9a 81       	ldd	r25, Y+2	; 0x02
     218:	93 8b       	std	Z+19, r25	; 0x13
     21a:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     21c:	8e 81       	ldd	r24, Y+6	; 0x06
     21e:	28 2f       	mov	r18, r24
     220:	30 e0       	ldi	r19, 0x00	; 0
     222:	83 e0       	ldi	r24, 0x03	; 3
     224:	90 e0       	ldi	r25, 0x00	; 0
     226:	82 1b       	sub	r24, r18
     228:	93 0b       	sbc	r25, r19
     22a:	e9 81       	ldd	r30, Y+1	; 0x01
     22c:	fa 81       	ldd	r31, Y+2	; 0x02
     22e:	95 87       	std	Z+13, r25	; 0x0d
     230:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     232:	e9 81       	ldd	r30, Y+1	; 0x01
     234:	fa 81       	ldd	r31, Y+2	; 0x02
     236:	96 89       	ldd	r25, Z+22	; 0x16
     238:	80 91 6a 00 	lds	r24, 0x006A
     23c:	89 17       	cp	r24, r25
     23e:	28 f4       	brcc	.+10     	; 0x24a <xCoRoutineCreate+0xd6>
     240:	e9 81       	ldd	r30, Y+1	; 0x01
     242:	fa 81       	ldd	r31, Y+2	; 0x02
     244:	86 89       	ldd	r24, Z+22	; 0x16
     246:	80 93 6a 00 	sts	0x006A, r24
     24a:	e9 81       	ldd	r30, Y+1	; 0x01
     24c:	fa 81       	ldd	r31, Y+2	; 0x02
     24e:	86 89       	ldd	r24, Z+22	; 0x16
     250:	28 2f       	mov	r18, r24
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	c9 01       	movw	r24, r18
     256:	88 0f       	add	r24, r24
     258:	99 1f       	adc	r25, r25
     25a:	88 0f       	add	r24, r24
     25c:	99 1f       	adc	r25, r25
     25e:	88 0f       	add	r24, r24
     260:	99 1f       	adc	r25, r25
     262:	82 0f       	add	r24, r18
     264:	93 1f       	adc	r25, r19
     266:	ac 01       	movw	r20, r24
     268:	4f 58       	subi	r20, 0x8F	; 143
     26a:	5f 4f       	sbci	r21, 0xFF	; 255
     26c:	89 81       	ldd	r24, Y+1	; 0x01
     26e:	9a 81       	ldd	r25, Y+2	; 0x02
     270:	9c 01       	movw	r18, r24
     272:	2e 5f       	subi	r18, 0xFE	; 254
     274:	3f 4f       	sbci	r19, 0xFF	; 255
     276:	ca 01       	movw	r24, r20
     278:	b9 01       	movw	r22, r18
     27a:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>

		xReturn = pdPASS;
     27e:	81 e0       	ldi	r24, 0x01	; 1
     280:	8b 83       	std	Y+3, r24	; 0x03
     282:	02 c0       	rjmp	.+4      	; 0x288 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     284:	8f ef       	ldi	r24, 0xFF	; 255
     286:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     288:	8b 81       	ldd	r24, Y+3	; 0x03
}
     28a:	27 96       	adiw	r28, 0x07	; 7
     28c:	0f b6       	in	r0, 0x3f	; 63
     28e:	f8 94       	cli
     290:	de bf       	out	0x3e, r29	; 62
     292:	0f be       	out	0x3f, r0	; 63
     294:	cd bf       	out	0x3d, r28	; 61
     296:	cf 91       	pop	r28
     298:	df 91       	pop	r29
     29a:	08 95       	ret

0000029c <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     29c:	df 93       	push	r29
     29e:	cf 93       	push	r28
     2a0:	00 d0       	rcall	.+0      	; 0x2a2 <vCoRoutineAddToDelayedList+0x6>
     2a2:	00 d0       	rcall	.+0      	; 0x2a4 <vCoRoutineAddToDelayedList+0x8>
     2a4:	00 d0       	rcall	.+0      	; 0x2a6 <vCoRoutineAddToDelayedList+0xa>
     2a6:	cd b7       	in	r28, 0x3d	; 61
     2a8:	de b7       	in	r29, 0x3e	; 62
     2aa:	9c 83       	std	Y+4, r25	; 0x04
     2ac:	8b 83       	std	Y+3, r24	; 0x03
     2ae:	7e 83       	std	Y+6, r23	; 0x06
     2b0:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     2b2:	20 91 6b 00 	lds	r18, 0x006B
     2b6:	30 91 6c 00 	lds	r19, 0x006C
     2ba:	8b 81       	ldd	r24, Y+3	; 0x03
     2bc:	9c 81       	ldd	r25, Y+4	; 0x04
     2be:	82 0f       	add	r24, r18
     2c0:	93 1f       	adc	r25, r19
     2c2:	9a 83       	std	Y+2, r25	; 0x02
     2c4:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2c6:	80 91 68 00 	lds	r24, 0x0068
     2ca:	90 91 69 00 	lds	r25, 0x0069
     2ce:	02 96       	adiw	r24, 0x02	; 2
     2d0:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     2d4:	e0 91 68 00 	lds	r30, 0x0068
     2d8:	f0 91 69 00 	lds	r31, 0x0069
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	9a 81       	ldd	r25, Y+2	; 0x02
     2e0:	93 83       	std	Z+3, r25	; 0x03
     2e2:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     2e4:	20 91 6b 00 	lds	r18, 0x006B
     2e8:	30 91 6c 00 	lds	r19, 0x006C
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	82 17       	cp	r24, r18
     2f2:	93 07       	cpc	r25, r19
     2f4:	70 f4       	brcc	.+28     	; 0x312 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2f6:	80 91 97 00 	lds	r24, 0x0097
     2fa:	90 91 98 00 	lds	r25, 0x0098
     2fe:	20 91 68 00 	lds	r18, 0x0068
     302:	30 91 69 00 	lds	r19, 0x0069
     306:	2e 5f       	subi	r18, 0xFE	; 254
     308:	3f 4f       	sbci	r19, 0xFF	; 255
     30a:	b9 01       	movw	r22, r18
     30c:	0e 94 84 04 	call	0x908	; 0x908 <vListInsert>
     310:	0d c0       	rjmp	.+26     	; 0x32c <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     312:	80 91 95 00 	lds	r24, 0x0095
     316:	90 91 96 00 	lds	r25, 0x0096
     31a:	20 91 68 00 	lds	r18, 0x0068
     31e:	30 91 69 00 	lds	r19, 0x0069
     322:	2e 5f       	subi	r18, 0xFE	; 254
     324:	3f 4f       	sbci	r19, 0xFF	; 255
     326:	b9 01       	movw	r22, r18
     328:	0e 94 84 04 	call	0x908	; 0x908 <vListInsert>
	}

	if( pxEventList )
     32c:	8d 81       	ldd	r24, Y+5	; 0x05
     32e:	9e 81       	ldd	r25, Y+6	; 0x06
     330:	00 97       	sbiw	r24, 0x00	; 0
     332:	61 f0       	breq	.+24     	; 0x34c <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     334:	80 91 68 00 	lds	r24, 0x0068
     338:	90 91 69 00 	lds	r25, 0x0069
     33c:	9c 01       	movw	r18, r24
     33e:	24 5f       	subi	r18, 0xF4	; 244
     340:	3f 4f       	sbci	r19, 0xFF	; 255
     342:	8d 81       	ldd	r24, Y+5	; 0x05
     344:	9e 81       	ldd	r25, Y+6	; 0x06
     346:	b9 01       	movw	r22, r18
     348:	0e 94 84 04 	call	0x908	; 0x908 <vListInsert>
	}
}
     34c:	26 96       	adiw	r28, 0x06	; 6
     34e:	0f b6       	in	r0, 0x3f	; 63
     350:	f8 94       	cli
     352:	de bf       	out	0x3e, r29	; 62
     354:	0f be       	out	0x3f, r0	; 63
     356:	cd bf       	out	0x3d, r28	; 61
     358:	cf 91       	pop	r28
     35a:	df 91       	pop	r29
     35c:	08 95       	ret

0000035e <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     35e:	df 93       	push	r29
     360:	cf 93       	push	r28
     362:	00 d0       	rcall	.+0      	; 0x364 <prvCheckPendingReadyList+0x6>
     364:	cd b7       	in	r28, 0x3d	; 61
     366:	de b7       	in	r29, 0x3e	; 62
     368:	3a c0       	rjmp	.+116    	; 0x3de <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     36a:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     36c:	e0 91 9e 00 	lds	r30, 0x009E
     370:	f0 91 9f 00 	lds	r31, 0x009F
     374:	86 81       	ldd	r24, Z+6	; 0x06
     376:	97 81       	ldd	r25, Z+7	; 0x07
     378:	9a 83       	std	Y+2, r25	; 0x02
     37a:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     37c:	89 81       	ldd	r24, Y+1	; 0x01
     37e:	9a 81       	ldd	r25, Y+2	; 0x02
     380:	0c 96       	adiw	r24, 0x0c	; 12
     382:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     386:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     388:	89 81       	ldd	r24, Y+1	; 0x01
     38a:	9a 81       	ldd	r25, Y+2	; 0x02
     38c:	02 96       	adiw	r24, 0x02	; 2
     38e:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     392:	e9 81       	ldd	r30, Y+1	; 0x01
     394:	fa 81       	ldd	r31, Y+2	; 0x02
     396:	96 89       	ldd	r25, Z+22	; 0x16
     398:	80 91 6a 00 	lds	r24, 0x006A
     39c:	89 17       	cp	r24, r25
     39e:	28 f4       	brcc	.+10     	; 0x3aa <prvCheckPendingReadyList+0x4c>
     3a0:	e9 81       	ldd	r30, Y+1	; 0x01
     3a2:	fa 81       	ldd	r31, Y+2	; 0x02
     3a4:	86 89       	ldd	r24, Z+22	; 0x16
     3a6:	80 93 6a 00 	sts	0x006A, r24
     3aa:	e9 81       	ldd	r30, Y+1	; 0x01
     3ac:	fa 81       	ldd	r31, Y+2	; 0x02
     3ae:	86 89       	ldd	r24, Z+22	; 0x16
     3b0:	28 2f       	mov	r18, r24
     3b2:	30 e0       	ldi	r19, 0x00	; 0
     3b4:	c9 01       	movw	r24, r18
     3b6:	88 0f       	add	r24, r24
     3b8:	99 1f       	adc	r25, r25
     3ba:	88 0f       	add	r24, r24
     3bc:	99 1f       	adc	r25, r25
     3be:	88 0f       	add	r24, r24
     3c0:	99 1f       	adc	r25, r25
     3c2:	82 0f       	add	r24, r18
     3c4:	93 1f       	adc	r25, r19
     3c6:	ac 01       	movw	r20, r24
     3c8:	4f 58       	subi	r20, 0x8F	; 143
     3ca:	5f 4f       	sbci	r21, 0xFF	; 255
     3cc:	89 81       	ldd	r24, Y+1	; 0x01
     3ce:	9a 81       	ldd	r25, Y+2	; 0x02
     3d0:	9c 01       	movw	r18, r24
     3d2:	2e 5f       	subi	r18, 0xFE	; 254
     3d4:	3f 4f       	sbci	r19, 0xFF	; 255
     3d6:	ca 01       	movw	r24, r20
     3d8:	b9 01       	movw	r22, r18
     3da:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     3de:	80 91 99 00 	lds	r24, 0x0099
     3e2:	88 23       	and	r24, r24
     3e4:	09 f0       	breq	.+2      	; 0x3e8 <prvCheckPendingReadyList+0x8a>
     3e6:	c1 cf       	rjmp	.-126    	; 0x36a <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     3e8:	0f 90       	pop	r0
     3ea:	0f 90       	pop	r0
     3ec:	cf 91       	pop	r28
     3ee:	df 91       	pop	r29
     3f0:	08 95       	ret

000003f2 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     3f2:	df 93       	push	r29
     3f4:	cf 93       	push	r28
     3f6:	00 d0       	rcall	.+0      	; 0x3f8 <prvCheckDelayedList+0x6>
     3f8:	00 d0       	rcall	.+0      	; 0x3fa <prvCheckDelayedList+0x8>
     3fa:	cd b7       	in	r28, 0x3d	; 61
     3fc:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     3fe:	0e 94 9d 11 	call	0x233a	; 0x233a <xTaskGetTickCount>
     402:	20 91 6d 00 	lds	r18, 0x006D
     406:	30 91 6e 00 	lds	r19, 0x006E
     40a:	82 1b       	sub	r24, r18
     40c:	93 0b       	sbc	r25, r19
     40e:	90 93 70 00 	sts	0x0070, r25
     412:	80 93 6f 00 	sts	0x006F, r24
     416:	85 c0       	rjmp	.+266    	; 0x522 <__stack+0xc3>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     418:	80 91 6b 00 	lds	r24, 0x006B
     41c:	90 91 6c 00 	lds	r25, 0x006C
     420:	01 96       	adiw	r24, 0x01	; 1
     422:	90 93 6c 00 	sts	0x006C, r25
     426:	80 93 6b 00 	sts	0x006B, r24
		xPassedTicks--;
     42a:	80 91 6f 00 	lds	r24, 0x006F
     42e:	90 91 70 00 	lds	r25, 0x0070
     432:	01 97       	sbiw	r24, 0x01	; 1
     434:	90 93 70 00 	sts	0x0070, r25
     438:	80 93 6f 00 	sts	0x006F, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     43c:	80 91 6b 00 	lds	r24, 0x006B
     440:	90 91 6c 00 	lds	r25, 0x006C
     444:	00 97       	sbiw	r24, 0x00	; 0
     446:	09 f0       	breq	.+2      	; 0x44a <prvCheckDelayedList+0x58>
     448:	64 c0       	rjmp	.+200    	; 0x512 <__stack+0xb3>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     44a:	80 91 95 00 	lds	r24, 0x0095
     44e:	90 91 96 00 	lds	r25, 0x0096
     452:	9a 83       	std	Y+2, r25	; 0x02
     454:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     456:	80 91 97 00 	lds	r24, 0x0097
     45a:	90 91 98 00 	lds	r25, 0x0098
     45e:	90 93 96 00 	sts	0x0096, r25
     462:	80 93 95 00 	sts	0x0095, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	9a 81       	ldd	r25, Y+2	; 0x02
     46a:	90 93 98 00 	sts	0x0098, r25
     46e:	80 93 97 00 	sts	0x0097, r24
     472:	4f c0       	rjmp	.+158    	; 0x512 <__stack+0xb3>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     474:	e0 91 95 00 	lds	r30, 0x0095
     478:	f0 91 96 00 	lds	r31, 0x0096
     47c:	05 80       	ldd	r0, Z+5	; 0x05
     47e:	f6 81       	ldd	r31, Z+6	; 0x06
     480:	e0 2d       	mov	r30, r0
     482:	86 81       	ldd	r24, Z+6	; 0x06
     484:	97 81       	ldd	r25, Z+7	; 0x07
     486:	9c 83       	std	Y+4, r25	; 0x04
     488:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     48a:	eb 81       	ldd	r30, Y+3	; 0x03
     48c:	fc 81       	ldd	r31, Y+4	; 0x04
     48e:	22 81       	ldd	r18, Z+2	; 0x02
     490:	33 81       	ldd	r19, Z+3	; 0x03
     492:	80 91 6b 00 	lds	r24, 0x006B
     496:	90 91 6c 00 	lds	r25, 0x006C
     49a:	82 17       	cp	r24, r18
     49c:	93 07       	cpc	r25, r19
     49e:	08 f4       	brcc	.+2      	; 0x4a2 <__stack+0x43>
     4a0:	40 c0       	rjmp	.+128    	; 0x522 <__stack+0xc3>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     4a2:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     4a4:	8b 81       	ldd	r24, Y+3	; 0x03
     4a6:	9c 81       	ldd	r25, Y+4	; 0x04
     4a8:	02 96       	adiw	r24, 0x02	; 2
     4aa:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     4ae:	eb 81       	ldd	r30, Y+3	; 0x03
     4b0:	fc 81       	ldd	r31, Y+4	; 0x04
     4b2:	84 89       	ldd	r24, Z+20	; 0x14
     4b4:	95 89       	ldd	r25, Z+21	; 0x15
     4b6:	00 97       	sbiw	r24, 0x00	; 0
     4b8:	29 f0       	breq	.+10     	; 0x4c4 <__stack+0x65>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     4ba:	8b 81       	ldd	r24, Y+3	; 0x03
     4bc:	9c 81       	ldd	r25, Y+4	; 0x04
     4be:	0c 96       	adiw	r24, 0x0c	; 12
     4c0:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     4c4:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     4c6:	eb 81       	ldd	r30, Y+3	; 0x03
     4c8:	fc 81       	ldd	r31, Y+4	; 0x04
     4ca:	96 89       	ldd	r25, Z+22	; 0x16
     4cc:	80 91 6a 00 	lds	r24, 0x006A
     4d0:	89 17       	cp	r24, r25
     4d2:	28 f4       	brcc	.+10     	; 0x4de <__stack+0x7f>
     4d4:	eb 81       	ldd	r30, Y+3	; 0x03
     4d6:	fc 81       	ldd	r31, Y+4	; 0x04
     4d8:	86 89       	ldd	r24, Z+22	; 0x16
     4da:	80 93 6a 00 	sts	0x006A, r24
     4de:	eb 81       	ldd	r30, Y+3	; 0x03
     4e0:	fc 81       	ldd	r31, Y+4	; 0x04
     4e2:	86 89       	ldd	r24, Z+22	; 0x16
     4e4:	28 2f       	mov	r18, r24
     4e6:	30 e0       	ldi	r19, 0x00	; 0
     4e8:	c9 01       	movw	r24, r18
     4ea:	88 0f       	add	r24, r24
     4ec:	99 1f       	adc	r25, r25
     4ee:	88 0f       	add	r24, r24
     4f0:	99 1f       	adc	r25, r25
     4f2:	88 0f       	add	r24, r24
     4f4:	99 1f       	adc	r25, r25
     4f6:	82 0f       	add	r24, r18
     4f8:	93 1f       	adc	r25, r19
     4fa:	ac 01       	movw	r20, r24
     4fc:	4f 58       	subi	r20, 0x8F	; 143
     4fe:	5f 4f       	sbci	r21, 0xFF	; 255
     500:	8b 81       	ldd	r24, Y+3	; 0x03
     502:	9c 81       	ldd	r25, Y+4	; 0x04
     504:	9c 01       	movw	r18, r24
     506:	2e 5f       	subi	r18, 0xFE	; 254
     508:	3f 4f       	sbci	r19, 0xFF	; 255
     50a:	ca 01       	movw	r24, r20
     50c:	b9 01       	movw	r22, r18
     50e:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     512:	e0 91 95 00 	lds	r30, 0x0095
     516:	f0 91 96 00 	lds	r31, 0x0096
     51a:	80 81       	ld	r24, Z
     51c:	88 23       	and	r24, r24
     51e:	09 f0       	breq	.+2      	; 0x522 <__stack+0xc3>
     520:	a9 cf       	rjmp	.-174    	; 0x474 <__stack+0x15>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     522:	80 91 6f 00 	lds	r24, 0x006F
     526:	90 91 70 00 	lds	r25, 0x0070
     52a:	00 97       	sbiw	r24, 0x00	; 0
     52c:	09 f0       	breq	.+2      	; 0x530 <__stack+0xd1>
     52e:	74 cf       	rjmp	.-280    	; 0x418 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     530:	80 91 6b 00 	lds	r24, 0x006B
     534:	90 91 6c 00 	lds	r25, 0x006C
     538:	90 93 6e 00 	sts	0x006E, r25
     53c:	80 93 6d 00 	sts	0x006D, r24
}
     540:	0f 90       	pop	r0
     542:	0f 90       	pop	r0
     544:	0f 90       	pop	r0
     546:	0f 90       	pop	r0
     548:	cf 91       	pop	r28
     54a:	df 91       	pop	r29
     54c:	08 95       	ret

0000054e <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     54e:	df 93       	push	r29
     550:	cf 93       	push	r28
     552:	00 d0       	rcall	.+0      	; 0x554 <vCoRoutineSchedule+0x6>
     554:	cd b7       	in	r28, 0x3d	; 61
     556:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     558:	0e 94 af 01 	call	0x35e	; 0x35e <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     55c:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <prvCheckDelayedList>
     560:	0a c0       	rjmp	.+20     	; 0x576 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     562:	80 91 6a 00 	lds	r24, 0x006A
     566:	88 23       	and	r24, r24
     568:	09 f4       	brne	.+2      	; 0x56c <vCoRoutineSchedule+0x1e>
     56a:	66 c0       	rjmp	.+204    	; 0x638 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     56c:	80 91 6a 00 	lds	r24, 0x006A
     570:	81 50       	subi	r24, 0x01	; 1
     572:	80 93 6a 00 	sts	0x006A, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     576:	80 91 6a 00 	lds	r24, 0x006A
     57a:	28 2f       	mov	r18, r24
     57c:	30 e0       	ldi	r19, 0x00	; 0
     57e:	c9 01       	movw	r24, r18
     580:	88 0f       	add	r24, r24
     582:	99 1f       	adc	r25, r25
     584:	88 0f       	add	r24, r24
     586:	99 1f       	adc	r25, r25
     588:	88 0f       	add	r24, r24
     58a:	99 1f       	adc	r25, r25
     58c:	82 0f       	add	r24, r18
     58e:	93 1f       	adc	r25, r19
     590:	fc 01       	movw	r30, r24
     592:	ef 58       	subi	r30, 0x8F	; 143
     594:	ff 4f       	sbci	r31, 0xFF	; 255
     596:	80 81       	ld	r24, Z
     598:	88 23       	and	r24, r24
     59a:	19 f3       	breq	.-58     	; 0x562 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     59c:	80 91 6a 00 	lds	r24, 0x006A
     5a0:	28 2f       	mov	r18, r24
     5a2:	30 e0       	ldi	r19, 0x00	; 0
     5a4:	c9 01       	movw	r24, r18
     5a6:	88 0f       	add	r24, r24
     5a8:	99 1f       	adc	r25, r25
     5aa:	88 0f       	add	r24, r24
     5ac:	99 1f       	adc	r25, r25
     5ae:	88 0f       	add	r24, r24
     5b0:	99 1f       	adc	r25, r25
     5b2:	82 0f       	add	r24, r18
     5b4:	93 1f       	adc	r25, r19
     5b6:	8f 58       	subi	r24, 0x8F	; 143
     5b8:	9f 4f       	sbci	r25, 0xFF	; 255
     5ba:	9a 83       	std	Y+2, r25	; 0x02
     5bc:	89 83       	std	Y+1, r24	; 0x01
     5be:	e9 81       	ldd	r30, Y+1	; 0x01
     5c0:	fa 81       	ldd	r31, Y+2	; 0x02
     5c2:	01 80       	ldd	r0, Z+1	; 0x01
     5c4:	f2 81       	ldd	r31, Z+2	; 0x02
     5c6:	e0 2d       	mov	r30, r0
     5c8:	82 81       	ldd	r24, Z+2	; 0x02
     5ca:	93 81       	ldd	r25, Z+3	; 0x03
     5cc:	e9 81       	ldd	r30, Y+1	; 0x01
     5ce:	fa 81       	ldd	r31, Y+2	; 0x02
     5d0:	92 83       	std	Z+2, r25	; 0x02
     5d2:	81 83       	std	Z+1, r24	; 0x01
     5d4:	e9 81       	ldd	r30, Y+1	; 0x01
     5d6:	fa 81       	ldd	r31, Y+2	; 0x02
     5d8:	21 81       	ldd	r18, Z+1	; 0x01
     5da:	32 81       	ldd	r19, Z+2	; 0x02
     5dc:	89 81       	ldd	r24, Y+1	; 0x01
     5de:	9a 81       	ldd	r25, Y+2	; 0x02
     5e0:	03 96       	adiw	r24, 0x03	; 3
     5e2:	28 17       	cp	r18, r24
     5e4:	39 07       	cpc	r19, r25
     5e6:	59 f4       	brne	.+22     	; 0x5fe <vCoRoutineSchedule+0xb0>
     5e8:	e9 81       	ldd	r30, Y+1	; 0x01
     5ea:	fa 81       	ldd	r31, Y+2	; 0x02
     5ec:	01 80       	ldd	r0, Z+1	; 0x01
     5ee:	f2 81       	ldd	r31, Z+2	; 0x02
     5f0:	e0 2d       	mov	r30, r0
     5f2:	82 81       	ldd	r24, Z+2	; 0x02
     5f4:	93 81       	ldd	r25, Z+3	; 0x03
     5f6:	e9 81       	ldd	r30, Y+1	; 0x01
     5f8:	fa 81       	ldd	r31, Y+2	; 0x02
     5fa:	92 83       	std	Z+2, r25	; 0x02
     5fc:	81 83       	std	Z+1, r24	; 0x01
     5fe:	e9 81       	ldd	r30, Y+1	; 0x01
     600:	fa 81       	ldd	r31, Y+2	; 0x02
     602:	01 80       	ldd	r0, Z+1	; 0x01
     604:	f2 81       	ldd	r31, Z+2	; 0x02
     606:	e0 2d       	mov	r30, r0
     608:	86 81       	ldd	r24, Z+6	; 0x06
     60a:	97 81       	ldd	r25, Z+7	; 0x07
     60c:	90 93 69 00 	sts	0x0069, r25
     610:	80 93 68 00 	sts	0x0068, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     614:	e0 91 68 00 	lds	r30, 0x0068
     618:	f0 91 69 00 	lds	r31, 0x0069
     61c:	40 81       	ld	r20, Z
     61e:	51 81       	ldd	r21, Z+1	; 0x01
     620:	80 91 68 00 	lds	r24, 0x0068
     624:	90 91 69 00 	lds	r25, 0x0069
     628:	e0 91 68 00 	lds	r30, 0x0068
     62c:	f0 91 69 00 	lds	r31, 0x0069
     630:	27 89       	ldd	r18, Z+23	; 0x17
     632:	62 2f       	mov	r22, r18
     634:	fa 01       	movw	r30, r20
     636:	09 95       	icall

	return;
}
     638:	0f 90       	pop	r0
     63a:	0f 90       	pop	r0
     63c:	cf 91       	pop	r28
     63e:	df 91       	pop	r29
     640:	08 95       	ret

00000642 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     642:	df 93       	push	r29
     644:	cf 93       	push	r28
     646:	0f 92       	push	r0
     648:	cd b7       	in	r28, 0x3d	; 61
     64a:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     64c:	19 82       	std	Y+1, r1	; 0x01
     64e:	13 c0       	rjmp	.+38     	; 0x676 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     650:	89 81       	ldd	r24, Y+1	; 0x01
     652:	28 2f       	mov	r18, r24
     654:	30 e0       	ldi	r19, 0x00	; 0
     656:	c9 01       	movw	r24, r18
     658:	88 0f       	add	r24, r24
     65a:	99 1f       	adc	r25, r25
     65c:	88 0f       	add	r24, r24
     65e:	99 1f       	adc	r25, r25
     660:	88 0f       	add	r24, r24
     662:	99 1f       	adc	r25, r25
     664:	82 0f       	add	r24, r18
     666:	93 1f       	adc	r25, r19
     668:	8f 58       	subi	r24, 0x8F	; 143
     66a:	9f 4f       	sbci	r25, 0xFF	; 255
     66c:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     670:	89 81       	ldd	r24, Y+1	; 0x01
     672:	8f 5f       	subi	r24, 0xFF	; 255
     674:	89 83       	std	Y+1, r24	; 0x01
     676:	89 81       	ldd	r24, Y+1	; 0x01
     678:	82 30       	cpi	r24, 0x02	; 2
     67a:	50 f3       	brcs	.-44     	; 0x650 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     67c:	83 e8       	ldi	r24, 0x83	; 131
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     684:	8c e8       	ldi	r24, 0x8C	; 140
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     68c:	89 e9       	ldi	r24, 0x99	; 153
     68e:	90 e0       	ldi	r25, 0x00	; 0
     690:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     694:	83 e8       	ldi	r24, 0x83	; 131
     696:	90 e0       	ldi	r25, 0x00	; 0
     698:	90 93 96 00 	sts	0x0096, r25
     69c:	80 93 95 00 	sts	0x0095, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     6a0:	8c e8       	ldi	r24, 0x8C	; 140
     6a2:	90 e0       	ldi	r25, 0x00	; 0
     6a4:	90 93 98 00 	sts	0x0098, r25
     6a8:	80 93 97 00 	sts	0x0097, r24
}
     6ac:	0f 90       	pop	r0
     6ae:	cf 91       	pop	r28
     6b0:	df 91       	pop	r29
     6b2:	08 95       	ret

000006b4 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     6b4:	df 93       	push	r29
     6b6:	cf 93       	push	r28
     6b8:	00 d0       	rcall	.+0      	; 0x6ba <xCoRoutineRemoveFromEventList+0x6>
     6ba:	00 d0       	rcall	.+0      	; 0x6bc <xCoRoutineRemoveFromEventList+0x8>
     6bc:	0f 92       	push	r0
     6be:	cd b7       	in	r28, 0x3d	; 61
     6c0:	de b7       	in	r29, 0x3e	; 62
     6c2:	9d 83       	std	Y+5, r25	; 0x05
     6c4:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     6c6:	ec 81       	ldd	r30, Y+4	; 0x04
     6c8:	fd 81       	ldd	r31, Y+5	; 0x05
     6ca:	05 80       	ldd	r0, Z+5	; 0x05
     6cc:	f6 81       	ldd	r31, Z+6	; 0x06
     6ce:	e0 2d       	mov	r30, r0
     6d0:	86 81       	ldd	r24, Z+6	; 0x06
     6d2:	97 81       	ldd	r25, Z+7	; 0x07
     6d4:	9b 83       	std	Y+3, r25	; 0x03
     6d6:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     6d8:	8a 81       	ldd	r24, Y+2	; 0x02
     6da:	9b 81       	ldd	r25, Y+3	; 0x03
     6dc:	0c 96       	adiw	r24, 0x0c	; 12
     6de:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     6e2:	8a 81       	ldd	r24, Y+2	; 0x02
     6e4:	9b 81       	ldd	r25, Y+3	; 0x03
     6e6:	9c 01       	movw	r18, r24
     6e8:	24 5f       	subi	r18, 0xF4	; 244
     6ea:	3f 4f       	sbci	r19, 0xFF	; 255
     6ec:	89 e9       	ldi	r24, 0x99	; 153
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	b9 01       	movw	r22, r18
     6f2:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     6f6:	ea 81       	ldd	r30, Y+2	; 0x02
     6f8:	fb 81       	ldd	r31, Y+3	; 0x03
     6fa:	96 89       	ldd	r25, Z+22	; 0x16
     6fc:	e0 91 68 00 	lds	r30, 0x0068
     700:	f0 91 69 00 	lds	r31, 0x0069
     704:	86 89       	ldd	r24, Z+22	; 0x16
     706:	98 17       	cp	r25, r24
     708:	18 f0       	brcs	.+6      	; 0x710 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     70a:	81 e0       	ldi	r24, 0x01	; 1
     70c:	89 83       	std	Y+1, r24	; 0x01
     70e:	01 c0       	rjmp	.+2      	; 0x712 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     710:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     712:	89 81       	ldd	r24, Y+1	; 0x01
}
     714:	0f 90       	pop	r0
     716:	0f 90       	pop	r0
     718:	0f 90       	pop	r0
     71a:	0f 90       	pop	r0
     71c:	0f 90       	pop	r0
     71e:	cf 91       	pop	r28
     720:	df 91       	pop	r29
     722:	08 95       	ret

00000724 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     724:	df 93       	push	r29
     726:	cf 93       	push	r28
     728:	00 d0       	rcall	.+0      	; 0x72a <pvPortMalloc+0x6>
     72a:	00 d0       	rcall	.+0      	; 0x72c <pvPortMalloc+0x8>
     72c:	cd b7       	in	r28, 0x3d	; 61
     72e:	de b7       	in	r29, 0x3e	; 62
     730:	9c 83       	std	Y+4, r25	; 0x04
     732:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     734:	1a 82       	std	Y+2, r1	; 0x02
     736:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     738:	0e 94 07 11 	call	0x220e	; 0x220e <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     73c:	80 91 a2 00 	lds	r24, 0x00A2
     740:	90 91 a3 00 	lds	r25, 0x00A3
     744:	2b 81       	ldd	r18, Y+3	; 0x03
     746:	3c 81       	ldd	r19, Y+4	; 0x04
     748:	82 0f       	add	r24, r18
     74a:	93 1f       	adc	r25, r19
     74c:	22 e0       	ldi	r18, 0x02	; 2
     74e:	88 35       	cpi	r24, 0x58	; 88
     750:	92 07       	cpc	r25, r18
     752:	18 f5       	brcc	.+70     	; 0x79a <pvPortMalloc+0x76>
     754:	20 91 a2 00 	lds	r18, 0x00A2
     758:	30 91 a3 00 	lds	r19, 0x00A3
     75c:	8b 81       	ldd	r24, Y+3	; 0x03
     75e:	9c 81       	ldd	r25, Y+4	; 0x04
     760:	28 0f       	add	r18, r24
     762:	39 1f       	adc	r19, r25
     764:	80 91 a2 00 	lds	r24, 0x00A2
     768:	90 91 a3 00 	lds	r25, 0x00A3
     76c:	82 17       	cp	r24, r18
     76e:	93 07       	cpc	r25, r19
     770:	a0 f4       	brcc	.+40     	; 0x79a <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     772:	80 91 a2 00 	lds	r24, 0x00A2
     776:	90 91 a3 00 	lds	r25, 0x00A3
     77a:	8c 55       	subi	r24, 0x5C	; 92
     77c:	9f 4f       	sbci	r25, 0xFF	; 255
     77e:	9a 83       	std	Y+2, r25	; 0x02
     780:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     782:	20 91 a2 00 	lds	r18, 0x00A2
     786:	30 91 a3 00 	lds	r19, 0x00A3
     78a:	8b 81       	ldd	r24, Y+3	; 0x03
     78c:	9c 81       	ldd	r25, Y+4	; 0x04
     78e:	82 0f       	add	r24, r18
     790:	93 1f       	adc	r25, r19
     792:	90 93 a3 00 	sts	0x00A3, r25
     796:	80 93 a2 00 	sts	0x00A2, r24
		}	
	}
	xTaskResumeAll();
     79a:	0e 94 13 11 	call	0x2226	; 0x2226 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     79e:	89 81       	ldd	r24, Y+1	; 0x01
     7a0:	9a 81       	ldd	r25, Y+2	; 0x02
}
     7a2:	0f 90       	pop	r0
     7a4:	0f 90       	pop	r0
     7a6:	0f 90       	pop	r0
     7a8:	0f 90       	pop	r0
     7aa:	cf 91       	pop	r28
     7ac:	df 91       	pop	r29
     7ae:	08 95       	ret

000007b0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     7b0:	df 93       	push	r29
     7b2:	cf 93       	push	r28
     7b4:	00 d0       	rcall	.+0      	; 0x7b6 <vPortFree+0x6>
     7b6:	cd b7       	in	r28, 0x3d	; 61
     7b8:	de b7       	in	r29, 0x3e	; 62
     7ba:	9a 83       	std	Y+2, r25	; 0x02
     7bc:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     7be:	0f 90       	pop	r0
     7c0:	0f 90       	pop	r0
     7c2:	cf 91       	pop	r28
     7c4:	df 91       	pop	r29
     7c6:	08 95       	ret

000007c8 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     7c8:	df 93       	push	r29
     7ca:	cf 93       	push	r28
     7cc:	cd b7       	in	r28, 0x3d	; 61
     7ce:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     7d0:	10 92 a3 00 	sts	0x00A3, r1
     7d4:	10 92 a2 00 	sts	0x00A2, r1
}
     7d8:	cf 91       	pop	r28
     7da:	df 91       	pop	r29
     7dc:	08 95       	ret

000007de <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     7de:	df 93       	push	r29
     7e0:	cf 93       	push	r28
     7e2:	cd b7       	in	r28, 0x3d	; 61
     7e4:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     7e6:	20 91 a2 00 	lds	r18, 0x00A2
     7ea:	30 91 a3 00 	lds	r19, 0x00A3
     7ee:	88 e5       	ldi	r24, 0x58	; 88
     7f0:	92 e0       	ldi	r25, 0x02	; 2
     7f2:	82 1b       	sub	r24, r18
     7f4:	93 0b       	sbc	r25, r19
}
     7f6:	cf 91       	pop	r28
     7f8:	df 91       	pop	r29
     7fa:	08 95       	ret

000007fc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     7fc:	df 93       	push	r29
     7fe:	cf 93       	push	r28
     800:	00 d0       	rcall	.+0      	; 0x802 <vListInitialise+0x6>
     802:	cd b7       	in	r28, 0x3d	; 61
     804:	de b7       	in	r29, 0x3e	; 62
     806:	9a 83       	std	Y+2, r25	; 0x02
     808:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     80a:	89 81       	ldd	r24, Y+1	; 0x01
     80c:	9a 81       	ldd	r25, Y+2	; 0x02
     80e:	03 96       	adiw	r24, 0x03	; 3
     810:	e9 81       	ldd	r30, Y+1	; 0x01
     812:	fa 81       	ldd	r31, Y+2	; 0x02
     814:	92 83       	std	Z+2, r25	; 0x02
     816:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     818:	e9 81       	ldd	r30, Y+1	; 0x01
     81a:	fa 81       	ldd	r31, Y+2	; 0x02
     81c:	8f ef       	ldi	r24, 0xFF	; 255
     81e:	9f ef       	ldi	r25, 0xFF	; 255
     820:	94 83       	std	Z+4, r25	; 0x04
     822:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     824:	89 81       	ldd	r24, Y+1	; 0x01
     826:	9a 81       	ldd	r25, Y+2	; 0x02
     828:	03 96       	adiw	r24, 0x03	; 3
     82a:	e9 81       	ldd	r30, Y+1	; 0x01
     82c:	fa 81       	ldd	r31, Y+2	; 0x02
     82e:	96 83       	std	Z+6, r25	; 0x06
     830:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     832:	89 81       	ldd	r24, Y+1	; 0x01
     834:	9a 81       	ldd	r25, Y+2	; 0x02
     836:	03 96       	adiw	r24, 0x03	; 3
     838:	e9 81       	ldd	r30, Y+1	; 0x01
     83a:	fa 81       	ldd	r31, Y+2	; 0x02
     83c:	90 87       	std	Z+8, r25	; 0x08
     83e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     840:	e9 81       	ldd	r30, Y+1	; 0x01
     842:	fa 81       	ldd	r31, Y+2	; 0x02
     844:	10 82       	st	Z, r1
}
     846:	0f 90       	pop	r0
     848:	0f 90       	pop	r0
     84a:	cf 91       	pop	r28
     84c:	df 91       	pop	r29
     84e:	08 95       	ret

00000850 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     850:	df 93       	push	r29
     852:	cf 93       	push	r28
     854:	00 d0       	rcall	.+0      	; 0x856 <vListInitialiseItem+0x6>
     856:	cd b7       	in	r28, 0x3d	; 61
     858:	de b7       	in	r29, 0x3e	; 62
     85a:	9a 83       	std	Y+2, r25	; 0x02
     85c:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     85e:	e9 81       	ldd	r30, Y+1	; 0x01
     860:	fa 81       	ldd	r31, Y+2	; 0x02
     862:	11 86       	std	Z+9, r1	; 0x09
     864:	10 86       	std	Z+8, r1	; 0x08
}
     866:	0f 90       	pop	r0
     868:	0f 90       	pop	r0
     86a:	cf 91       	pop	r28
     86c:	df 91       	pop	r29
     86e:	08 95       	ret

00000870 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     870:	df 93       	push	r29
     872:	cf 93       	push	r28
     874:	00 d0       	rcall	.+0      	; 0x876 <vListInsertEnd+0x6>
     876:	00 d0       	rcall	.+0      	; 0x878 <vListInsertEnd+0x8>
     878:	00 d0       	rcall	.+0      	; 0x87a <vListInsertEnd+0xa>
     87a:	cd b7       	in	r28, 0x3d	; 61
     87c:	de b7       	in	r29, 0x3e	; 62
     87e:	9c 83       	std	Y+4, r25	; 0x04
     880:	8b 83       	std	Y+3, r24	; 0x03
     882:	7e 83       	std	Y+6, r23	; 0x06
     884:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     886:	eb 81       	ldd	r30, Y+3	; 0x03
     888:	fc 81       	ldd	r31, Y+4	; 0x04
     88a:	81 81       	ldd	r24, Z+1	; 0x01
     88c:	92 81       	ldd	r25, Z+2	; 0x02
     88e:	9a 83       	std	Y+2, r25	; 0x02
     890:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     892:	e9 81       	ldd	r30, Y+1	; 0x01
     894:	fa 81       	ldd	r31, Y+2	; 0x02
     896:	82 81       	ldd	r24, Z+2	; 0x02
     898:	93 81       	ldd	r25, Z+3	; 0x03
     89a:	ed 81       	ldd	r30, Y+5	; 0x05
     89c:	fe 81       	ldd	r31, Y+6	; 0x06
     89e:	93 83       	std	Z+3, r25	; 0x03
     8a0:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     8a2:	eb 81       	ldd	r30, Y+3	; 0x03
     8a4:	fc 81       	ldd	r31, Y+4	; 0x04
     8a6:	81 81       	ldd	r24, Z+1	; 0x01
     8a8:	92 81       	ldd	r25, Z+2	; 0x02
     8aa:	ed 81       	ldd	r30, Y+5	; 0x05
     8ac:	fe 81       	ldd	r31, Y+6	; 0x06
     8ae:	95 83       	std	Z+5, r25	; 0x05
     8b0:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     8b2:	e9 81       	ldd	r30, Y+1	; 0x01
     8b4:	fa 81       	ldd	r31, Y+2	; 0x02
     8b6:	02 80       	ldd	r0, Z+2	; 0x02
     8b8:	f3 81       	ldd	r31, Z+3	; 0x03
     8ba:	e0 2d       	mov	r30, r0
     8bc:	8d 81       	ldd	r24, Y+5	; 0x05
     8be:	9e 81       	ldd	r25, Y+6	; 0x06
     8c0:	95 83       	std	Z+5, r25	; 0x05
     8c2:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     8c4:	8d 81       	ldd	r24, Y+5	; 0x05
     8c6:	9e 81       	ldd	r25, Y+6	; 0x06
     8c8:	e9 81       	ldd	r30, Y+1	; 0x01
     8ca:	fa 81       	ldd	r31, Y+2	; 0x02
     8cc:	93 83       	std	Z+3, r25	; 0x03
     8ce:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     8d0:	8d 81       	ldd	r24, Y+5	; 0x05
     8d2:	9e 81       	ldd	r25, Y+6	; 0x06
     8d4:	eb 81       	ldd	r30, Y+3	; 0x03
     8d6:	fc 81       	ldd	r31, Y+4	; 0x04
     8d8:	92 83       	std	Z+2, r25	; 0x02
     8da:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8dc:	ed 81       	ldd	r30, Y+5	; 0x05
     8de:	fe 81       	ldd	r31, Y+6	; 0x06
     8e0:	8b 81       	ldd	r24, Y+3	; 0x03
     8e2:	9c 81       	ldd	r25, Y+4	; 0x04
     8e4:	91 87       	std	Z+9, r25	; 0x09
     8e6:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8e8:	eb 81       	ldd	r30, Y+3	; 0x03
     8ea:	fc 81       	ldd	r31, Y+4	; 0x04
     8ec:	80 81       	ld	r24, Z
     8ee:	8f 5f       	subi	r24, 0xFF	; 255
     8f0:	eb 81       	ldd	r30, Y+3	; 0x03
     8f2:	fc 81       	ldd	r31, Y+4	; 0x04
     8f4:	80 83       	st	Z, r24
}
     8f6:	26 96       	adiw	r28, 0x06	; 6
     8f8:	0f b6       	in	r0, 0x3f	; 63
     8fa:	f8 94       	cli
     8fc:	de bf       	out	0x3e, r29	; 62
     8fe:	0f be       	out	0x3f, r0	; 63
     900:	cd bf       	out	0x3d, r28	; 61
     902:	cf 91       	pop	r28
     904:	df 91       	pop	r29
     906:	08 95       	ret

00000908 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     908:	df 93       	push	r29
     90a:	cf 93       	push	r28
     90c:	cd b7       	in	r28, 0x3d	; 61
     90e:	de b7       	in	r29, 0x3e	; 62
     910:	28 97       	sbiw	r28, 0x08	; 8
     912:	0f b6       	in	r0, 0x3f	; 63
     914:	f8 94       	cli
     916:	de bf       	out	0x3e, r29	; 62
     918:	0f be       	out	0x3f, r0	; 63
     91a:	cd bf       	out	0x3d, r28	; 61
     91c:	9e 83       	std	Y+6, r25	; 0x06
     91e:	8d 83       	std	Y+5, r24	; 0x05
     920:	78 87       	std	Y+8, r23	; 0x08
     922:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     924:	ef 81       	ldd	r30, Y+7	; 0x07
     926:	f8 85       	ldd	r31, Y+8	; 0x08
     928:	80 81       	ld	r24, Z
     92a:	91 81       	ldd	r25, Z+1	; 0x01
     92c:	9a 83       	std	Y+2, r25	; 0x02
     92e:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     930:	89 81       	ldd	r24, Y+1	; 0x01
     932:	9a 81       	ldd	r25, Y+2	; 0x02
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	8f 3f       	cpi	r24, 0xFF	; 255
     938:	92 07       	cpc	r25, r18
     93a:	39 f4       	brne	.+14     	; 0x94a <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     93c:	ed 81       	ldd	r30, Y+5	; 0x05
     93e:	fe 81       	ldd	r31, Y+6	; 0x06
     940:	87 81       	ldd	r24, Z+7	; 0x07
     942:	90 85       	ldd	r25, Z+8	; 0x08
     944:	9c 83       	std	Y+4, r25	; 0x04
     946:	8b 83       	std	Y+3, r24	; 0x03
     948:	18 c0       	rjmp	.+48     	; 0x97a <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     94a:	8d 81       	ldd	r24, Y+5	; 0x05
     94c:	9e 81       	ldd	r25, Y+6	; 0x06
     94e:	03 96       	adiw	r24, 0x03	; 3
     950:	9c 83       	std	Y+4, r25	; 0x04
     952:	8b 83       	std	Y+3, r24	; 0x03
     954:	06 c0       	rjmp	.+12     	; 0x962 <vListInsert+0x5a>
     956:	eb 81       	ldd	r30, Y+3	; 0x03
     958:	fc 81       	ldd	r31, Y+4	; 0x04
     95a:	82 81       	ldd	r24, Z+2	; 0x02
     95c:	93 81       	ldd	r25, Z+3	; 0x03
     95e:	9c 83       	std	Y+4, r25	; 0x04
     960:	8b 83       	std	Y+3, r24	; 0x03
     962:	eb 81       	ldd	r30, Y+3	; 0x03
     964:	fc 81       	ldd	r31, Y+4	; 0x04
     966:	02 80       	ldd	r0, Z+2	; 0x02
     968:	f3 81       	ldd	r31, Z+3	; 0x03
     96a:	e0 2d       	mov	r30, r0
     96c:	20 81       	ld	r18, Z
     96e:	31 81       	ldd	r19, Z+1	; 0x01
     970:	89 81       	ldd	r24, Y+1	; 0x01
     972:	9a 81       	ldd	r25, Y+2	; 0x02
     974:	82 17       	cp	r24, r18
     976:	93 07       	cpc	r25, r19
     978:	70 f7       	brcc	.-36     	; 0x956 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     97a:	eb 81       	ldd	r30, Y+3	; 0x03
     97c:	fc 81       	ldd	r31, Y+4	; 0x04
     97e:	82 81       	ldd	r24, Z+2	; 0x02
     980:	93 81       	ldd	r25, Z+3	; 0x03
     982:	ef 81       	ldd	r30, Y+7	; 0x07
     984:	f8 85       	ldd	r31, Y+8	; 0x08
     986:	93 83       	std	Z+3, r25	; 0x03
     988:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     98a:	ef 81       	ldd	r30, Y+7	; 0x07
     98c:	f8 85       	ldd	r31, Y+8	; 0x08
     98e:	02 80       	ldd	r0, Z+2	; 0x02
     990:	f3 81       	ldd	r31, Z+3	; 0x03
     992:	e0 2d       	mov	r30, r0
     994:	8f 81       	ldd	r24, Y+7	; 0x07
     996:	98 85       	ldd	r25, Y+8	; 0x08
     998:	95 83       	std	Z+5, r25	; 0x05
     99a:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     99c:	ef 81       	ldd	r30, Y+7	; 0x07
     99e:	f8 85       	ldd	r31, Y+8	; 0x08
     9a0:	8b 81       	ldd	r24, Y+3	; 0x03
     9a2:	9c 81       	ldd	r25, Y+4	; 0x04
     9a4:	95 83       	std	Z+5, r25	; 0x05
     9a6:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     9a8:	8f 81       	ldd	r24, Y+7	; 0x07
     9aa:	98 85       	ldd	r25, Y+8	; 0x08
     9ac:	eb 81       	ldd	r30, Y+3	; 0x03
     9ae:	fc 81       	ldd	r31, Y+4	; 0x04
     9b0:	93 83       	std	Z+3, r25	; 0x03
     9b2:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9b4:	ef 81       	ldd	r30, Y+7	; 0x07
     9b6:	f8 85       	ldd	r31, Y+8	; 0x08
     9b8:	8d 81       	ldd	r24, Y+5	; 0x05
     9ba:	9e 81       	ldd	r25, Y+6	; 0x06
     9bc:	91 87       	std	Z+9, r25	; 0x09
     9be:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     9c0:	ed 81       	ldd	r30, Y+5	; 0x05
     9c2:	fe 81       	ldd	r31, Y+6	; 0x06
     9c4:	80 81       	ld	r24, Z
     9c6:	8f 5f       	subi	r24, 0xFF	; 255
     9c8:	ed 81       	ldd	r30, Y+5	; 0x05
     9ca:	fe 81       	ldd	r31, Y+6	; 0x06
     9cc:	80 83       	st	Z, r24
}
     9ce:	28 96       	adiw	r28, 0x08	; 8
     9d0:	0f b6       	in	r0, 0x3f	; 63
     9d2:	f8 94       	cli
     9d4:	de bf       	out	0x3e, r29	; 62
     9d6:	0f be       	out	0x3f, r0	; 63
     9d8:	cd bf       	out	0x3d, r28	; 61
     9da:	cf 91       	pop	r28
     9dc:	df 91       	pop	r29
     9de:	08 95       	ret

000009e0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     9e0:	df 93       	push	r29
     9e2:	cf 93       	push	r28
     9e4:	00 d0       	rcall	.+0      	; 0x9e6 <vListRemove+0x6>
     9e6:	00 d0       	rcall	.+0      	; 0x9e8 <vListRemove+0x8>
     9e8:	cd b7       	in	r28, 0x3d	; 61
     9ea:	de b7       	in	r29, 0x3e	; 62
     9ec:	9c 83       	std	Y+4, r25	; 0x04
     9ee:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     9f0:	eb 81       	ldd	r30, Y+3	; 0x03
     9f2:	fc 81       	ldd	r31, Y+4	; 0x04
     9f4:	a2 81       	ldd	r26, Z+2	; 0x02
     9f6:	b3 81       	ldd	r27, Z+3	; 0x03
     9f8:	eb 81       	ldd	r30, Y+3	; 0x03
     9fa:	fc 81       	ldd	r31, Y+4	; 0x04
     9fc:	84 81       	ldd	r24, Z+4	; 0x04
     9fe:	95 81       	ldd	r25, Z+5	; 0x05
     a00:	15 96       	adiw	r26, 0x05	; 5
     a02:	9c 93       	st	X, r25
     a04:	8e 93       	st	-X, r24
     a06:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a08:	eb 81       	ldd	r30, Y+3	; 0x03
     a0a:	fc 81       	ldd	r31, Y+4	; 0x04
     a0c:	a4 81       	ldd	r26, Z+4	; 0x04
     a0e:	b5 81       	ldd	r27, Z+5	; 0x05
     a10:	eb 81       	ldd	r30, Y+3	; 0x03
     a12:	fc 81       	ldd	r31, Y+4	; 0x04
     a14:	82 81       	ldd	r24, Z+2	; 0x02
     a16:	93 81       	ldd	r25, Z+3	; 0x03
     a18:	13 96       	adiw	r26, 0x03	; 3
     a1a:	9c 93       	st	X, r25
     a1c:	8e 93       	st	-X, r24
     a1e:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     a20:	eb 81       	ldd	r30, Y+3	; 0x03
     a22:	fc 81       	ldd	r31, Y+4	; 0x04
     a24:	80 85       	ldd	r24, Z+8	; 0x08
     a26:	91 85       	ldd	r25, Z+9	; 0x09
     a28:	9a 83       	std	Y+2, r25	; 0x02
     a2a:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a2c:	e9 81       	ldd	r30, Y+1	; 0x01
     a2e:	fa 81       	ldd	r31, Y+2	; 0x02
     a30:	21 81       	ldd	r18, Z+1	; 0x01
     a32:	32 81       	ldd	r19, Z+2	; 0x02
     a34:	8b 81       	ldd	r24, Y+3	; 0x03
     a36:	9c 81       	ldd	r25, Y+4	; 0x04
     a38:	28 17       	cp	r18, r24
     a3a:	39 07       	cpc	r19, r25
     a3c:	41 f4       	brne	.+16     	; 0xa4e <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a3e:	eb 81       	ldd	r30, Y+3	; 0x03
     a40:	fc 81       	ldd	r31, Y+4	; 0x04
     a42:	84 81       	ldd	r24, Z+4	; 0x04
     a44:	95 81       	ldd	r25, Z+5	; 0x05
     a46:	e9 81       	ldd	r30, Y+1	; 0x01
     a48:	fa 81       	ldd	r31, Y+2	; 0x02
     a4a:	92 83       	std	Z+2, r25	; 0x02
     a4c:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     a4e:	eb 81       	ldd	r30, Y+3	; 0x03
     a50:	fc 81       	ldd	r31, Y+4	; 0x04
     a52:	11 86       	std	Z+9, r1	; 0x09
     a54:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a56:	e9 81       	ldd	r30, Y+1	; 0x01
     a58:	fa 81       	ldd	r31, Y+2	; 0x02
     a5a:	80 81       	ld	r24, Z
     a5c:	81 50       	subi	r24, 0x01	; 1
     a5e:	e9 81       	ldd	r30, Y+1	; 0x01
     a60:	fa 81       	ldd	r31, Y+2	; 0x02
     a62:	80 83       	st	Z, r24
}
     a64:	0f 90       	pop	r0
     a66:	0f 90       	pop	r0
     a68:	0f 90       	pop	r0
     a6a:	0f 90       	pop	r0
     a6c:	cf 91       	pop	r28
     a6e:	df 91       	pop	r29
     a70:	08 95       	ret

00000a72 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     a72:	df 93       	push	r29
     a74:	cf 93       	push	r28
     a76:	cd b7       	in	r28, 0x3d	; 61
     a78:	de b7       	in	r29, 0x3e	; 62
     a7a:	28 97       	sbiw	r28, 0x08	; 8
     a7c:	0f b6       	in	r0, 0x3f	; 63
     a7e:	f8 94       	cli
     a80:	de bf       	out	0x3e, r29	; 62
     a82:	0f be       	out	0x3f, r0	; 63
     a84:	cd bf       	out	0x3d, r28	; 61
     a86:	9c 83       	std	Y+4, r25	; 0x04
     a88:	8b 83       	std	Y+3, r24	; 0x03
     a8a:	7e 83       	std	Y+6, r23	; 0x06
     a8c:	6d 83       	std	Y+5, r22	; 0x05
     a8e:	58 87       	std	Y+8, r21	; 0x08
     a90:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     a92:	eb 81       	ldd	r30, Y+3	; 0x03
     a94:	fc 81       	ldd	r31, Y+4	; 0x04
     a96:	81 e1       	ldi	r24, 0x11	; 17
     a98:	80 83       	st	Z, r24
	pxTopOfStack--;
     a9a:	8b 81       	ldd	r24, Y+3	; 0x03
     a9c:	9c 81       	ldd	r25, Y+4	; 0x04
     a9e:	01 97       	sbiw	r24, 0x01	; 1
     aa0:	9c 83       	std	Y+4, r25	; 0x04
     aa2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     aa4:	eb 81       	ldd	r30, Y+3	; 0x03
     aa6:	fc 81       	ldd	r31, Y+4	; 0x04
     aa8:	82 e2       	ldi	r24, 0x22	; 34
     aaa:	80 83       	st	Z, r24
	pxTopOfStack--;
     aac:	8b 81       	ldd	r24, Y+3	; 0x03
     aae:	9c 81       	ldd	r25, Y+4	; 0x04
     ab0:	01 97       	sbiw	r24, 0x01	; 1
     ab2:	9c 83       	std	Y+4, r25	; 0x04
     ab4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     ab6:	eb 81       	ldd	r30, Y+3	; 0x03
     ab8:	fc 81       	ldd	r31, Y+4	; 0x04
     aba:	83 e3       	ldi	r24, 0x33	; 51
     abc:	80 83       	st	Z, r24
	pxTopOfStack--;
     abe:	8b 81       	ldd	r24, Y+3	; 0x03
     ac0:	9c 81       	ldd	r25, Y+4	; 0x04
     ac2:	01 97       	sbiw	r24, 0x01	; 1
     ac4:	9c 83       	std	Y+4, r25	; 0x04
     ac6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     ac8:	8d 81       	ldd	r24, Y+5	; 0x05
     aca:	9e 81       	ldd	r25, Y+6	; 0x06
     acc:	9a 83       	std	Y+2, r25	; 0x02
     ace:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     ad0:	89 81       	ldd	r24, Y+1	; 0x01
     ad2:	eb 81       	ldd	r30, Y+3	; 0x03
     ad4:	fc 81       	ldd	r31, Y+4	; 0x04
     ad6:	80 83       	st	Z, r24
	pxTopOfStack--;
     ad8:	8b 81       	ldd	r24, Y+3	; 0x03
     ada:	9c 81       	ldd	r25, Y+4	; 0x04
     adc:	01 97       	sbiw	r24, 0x01	; 1
     ade:	9c 83       	std	Y+4, r25	; 0x04
     ae0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     ae2:	89 81       	ldd	r24, Y+1	; 0x01
     ae4:	9a 81       	ldd	r25, Y+2	; 0x02
     ae6:	89 2f       	mov	r24, r25
     ae8:	99 27       	eor	r25, r25
     aea:	9a 83       	std	Y+2, r25	; 0x02
     aec:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     aee:	89 81       	ldd	r24, Y+1	; 0x01
     af0:	eb 81       	ldd	r30, Y+3	; 0x03
     af2:	fc 81       	ldd	r31, Y+4	; 0x04
     af4:	80 83       	st	Z, r24
	pxTopOfStack--;
     af6:	8b 81       	ldd	r24, Y+3	; 0x03
     af8:	9c 81       	ldd	r25, Y+4	; 0x04
     afa:	01 97       	sbiw	r24, 0x01	; 1
     afc:	9c 83       	std	Y+4, r25	; 0x04
     afe:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     b00:	eb 81       	ldd	r30, Y+3	; 0x03
     b02:	fc 81       	ldd	r31, Y+4	; 0x04
     b04:	10 82       	st	Z, r1
	pxTopOfStack--;
     b06:	8b 81       	ldd	r24, Y+3	; 0x03
     b08:	9c 81       	ldd	r25, Y+4	; 0x04
     b0a:	01 97       	sbiw	r24, 0x01	; 1
     b0c:	9c 83       	std	Y+4, r25	; 0x04
     b0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     b10:	eb 81       	ldd	r30, Y+3	; 0x03
     b12:	fc 81       	ldd	r31, Y+4	; 0x04
     b14:	80 e8       	ldi	r24, 0x80	; 128
     b16:	80 83       	st	Z, r24
	pxTopOfStack--;
     b18:	8b 81       	ldd	r24, Y+3	; 0x03
     b1a:	9c 81       	ldd	r25, Y+4	; 0x04
     b1c:	01 97       	sbiw	r24, 0x01	; 1
     b1e:	9c 83       	std	Y+4, r25	; 0x04
     b20:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     b22:	eb 81       	ldd	r30, Y+3	; 0x03
     b24:	fc 81       	ldd	r31, Y+4	; 0x04
     b26:	10 82       	st	Z, r1
	pxTopOfStack--;
     b28:	8b 81       	ldd	r24, Y+3	; 0x03
     b2a:	9c 81       	ldd	r25, Y+4	; 0x04
     b2c:	01 97       	sbiw	r24, 0x01	; 1
     b2e:	9c 83       	std	Y+4, r25	; 0x04
     b30:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     b32:	eb 81       	ldd	r30, Y+3	; 0x03
     b34:	fc 81       	ldd	r31, Y+4	; 0x04
     b36:	82 e0       	ldi	r24, 0x02	; 2
     b38:	80 83       	st	Z, r24
	pxTopOfStack--;
     b3a:	8b 81       	ldd	r24, Y+3	; 0x03
     b3c:	9c 81       	ldd	r25, Y+4	; 0x04
     b3e:	01 97       	sbiw	r24, 0x01	; 1
     b40:	9c 83       	std	Y+4, r25	; 0x04
     b42:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     b44:	eb 81       	ldd	r30, Y+3	; 0x03
     b46:	fc 81       	ldd	r31, Y+4	; 0x04
     b48:	83 e0       	ldi	r24, 0x03	; 3
     b4a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b4c:	8b 81       	ldd	r24, Y+3	; 0x03
     b4e:	9c 81       	ldd	r25, Y+4	; 0x04
     b50:	01 97       	sbiw	r24, 0x01	; 1
     b52:	9c 83       	std	Y+4, r25	; 0x04
     b54:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     b56:	eb 81       	ldd	r30, Y+3	; 0x03
     b58:	fc 81       	ldd	r31, Y+4	; 0x04
     b5a:	84 e0       	ldi	r24, 0x04	; 4
     b5c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b5e:	8b 81       	ldd	r24, Y+3	; 0x03
     b60:	9c 81       	ldd	r25, Y+4	; 0x04
     b62:	01 97       	sbiw	r24, 0x01	; 1
     b64:	9c 83       	std	Y+4, r25	; 0x04
     b66:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     b68:	eb 81       	ldd	r30, Y+3	; 0x03
     b6a:	fc 81       	ldd	r31, Y+4	; 0x04
     b6c:	85 e0       	ldi	r24, 0x05	; 5
     b6e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b70:	8b 81       	ldd	r24, Y+3	; 0x03
     b72:	9c 81       	ldd	r25, Y+4	; 0x04
     b74:	01 97       	sbiw	r24, 0x01	; 1
     b76:	9c 83       	std	Y+4, r25	; 0x04
     b78:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     b7a:	eb 81       	ldd	r30, Y+3	; 0x03
     b7c:	fc 81       	ldd	r31, Y+4	; 0x04
     b7e:	86 e0       	ldi	r24, 0x06	; 6
     b80:	80 83       	st	Z, r24
	pxTopOfStack--;
     b82:	8b 81       	ldd	r24, Y+3	; 0x03
     b84:	9c 81       	ldd	r25, Y+4	; 0x04
     b86:	01 97       	sbiw	r24, 0x01	; 1
     b88:	9c 83       	std	Y+4, r25	; 0x04
     b8a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     b8c:	eb 81       	ldd	r30, Y+3	; 0x03
     b8e:	fc 81       	ldd	r31, Y+4	; 0x04
     b90:	87 e0       	ldi	r24, 0x07	; 7
     b92:	80 83       	st	Z, r24
	pxTopOfStack--;
     b94:	8b 81       	ldd	r24, Y+3	; 0x03
     b96:	9c 81       	ldd	r25, Y+4	; 0x04
     b98:	01 97       	sbiw	r24, 0x01	; 1
     b9a:	9c 83       	std	Y+4, r25	; 0x04
     b9c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     b9e:	eb 81       	ldd	r30, Y+3	; 0x03
     ba0:	fc 81       	ldd	r31, Y+4	; 0x04
     ba2:	88 e0       	ldi	r24, 0x08	; 8
     ba4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ba6:	8b 81       	ldd	r24, Y+3	; 0x03
     ba8:	9c 81       	ldd	r25, Y+4	; 0x04
     baa:	01 97       	sbiw	r24, 0x01	; 1
     bac:	9c 83       	std	Y+4, r25	; 0x04
     bae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     bb0:	eb 81       	ldd	r30, Y+3	; 0x03
     bb2:	fc 81       	ldd	r31, Y+4	; 0x04
     bb4:	89 e0       	ldi	r24, 0x09	; 9
     bb6:	80 83       	st	Z, r24
	pxTopOfStack--;
     bb8:	8b 81       	ldd	r24, Y+3	; 0x03
     bba:	9c 81       	ldd	r25, Y+4	; 0x04
     bbc:	01 97       	sbiw	r24, 0x01	; 1
     bbe:	9c 83       	std	Y+4, r25	; 0x04
     bc0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     bc2:	eb 81       	ldd	r30, Y+3	; 0x03
     bc4:	fc 81       	ldd	r31, Y+4	; 0x04
     bc6:	80 e1       	ldi	r24, 0x10	; 16
     bc8:	80 83       	st	Z, r24
	pxTopOfStack--;
     bca:	8b 81       	ldd	r24, Y+3	; 0x03
     bcc:	9c 81       	ldd	r25, Y+4	; 0x04
     bce:	01 97       	sbiw	r24, 0x01	; 1
     bd0:	9c 83       	std	Y+4, r25	; 0x04
     bd2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     bd4:	eb 81       	ldd	r30, Y+3	; 0x03
     bd6:	fc 81       	ldd	r31, Y+4	; 0x04
     bd8:	81 e1       	ldi	r24, 0x11	; 17
     bda:	80 83       	st	Z, r24
	pxTopOfStack--;
     bdc:	8b 81       	ldd	r24, Y+3	; 0x03
     bde:	9c 81       	ldd	r25, Y+4	; 0x04
     be0:	01 97       	sbiw	r24, 0x01	; 1
     be2:	9c 83       	std	Y+4, r25	; 0x04
     be4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     be6:	eb 81       	ldd	r30, Y+3	; 0x03
     be8:	fc 81       	ldd	r31, Y+4	; 0x04
     bea:	82 e1       	ldi	r24, 0x12	; 18
     bec:	80 83       	st	Z, r24
	pxTopOfStack--;
     bee:	8b 81       	ldd	r24, Y+3	; 0x03
     bf0:	9c 81       	ldd	r25, Y+4	; 0x04
     bf2:	01 97       	sbiw	r24, 0x01	; 1
     bf4:	9c 83       	std	Y+4, r25	; 0x04
     bf6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     bf8:	eb 81       	ldd	r30, Y+3	; 0x03
     bfa:	fc 81       	ldd	r31, Y+4	; 0x04
     bfc:	83 e1       	ldi	r24, 0x13	; 19
     bfe:	80 83       	st	Z, r24
	pxTopOfStack--;
     c00:	8b 81       	ldd	r24, Y+3	; 0x03
     c02:	9c 81       	ldd	r25, Y+4	; 0x04
     c04:	01 97       	sbiw	r24, 0x01	; 1
     c06:	9c 83       	std	Y+4, r25	; 0x04
     c08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     c0a:	eb 81       	ldd	r30, Y+3	; 0x03
     c0c:	fc 81       	ldd	r31, Y+4	; 0x04
     c0e:	84 e1       	ldi	r24, 0x14	; 20
     c10:	80 83       	st	Z, r24
	pxTopOfStack--;
     c12:	8b 81       	ldd	r24, Y+3	; 0x03
     c14:	9c 81       	ldd	r25, Y+4	; 0x04
     c16:	01 97       	sbiw	r24, 0x01	; 1
     c18:	9c 83       	std	Y+4, r25	; 0x04
     c1a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     c1c:	eb 81       	ldd	r30, Y+3	; 0x03
     c1e:	fc 81       	ldd	r31, Y+4	; 0x04
     c20:	85 e1       	ldi	r24, 0x15	; 21
     c22:	80 83       	st	Z, r24
	pxTopOfStack--;
     c24:	8b 81       	ldd	r24, Y+3	; 0x03
     c26:	9c 81       	ldd	r25, Y+4	; 0x04
     c28:	01 97       	sbiw	r24, 0x01	; 1
     c2a:	9c 83       	std	Y+4, r25	; 0x04
     c2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     c2e:	eb 81       	ldd	r30, Y+3	; 0x03
     c30:	fc 81       	ldd	r31, Y+4	; 0x04
     c32:	86 e1       	ldi	r24, 0x16	; 22
     c34:	80 83       	st	Z, r24
	pxTopOfStack--;
     c36:	8b 81       	ldd	r24, Y+3	; 0x03
     c38:	9c 81       	ldd	r25, Y+4	; 0x04
     c3a:	01 97       	sbiw	r24, 0x01	; 1
     c3c:	9c 83       	std	Y+4, r25	; 0x04
     c3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     c40:	eb 81       	ldd	r30, Y+3	; 0x03
     c42:	fc 81       	ldd	r31, Y+4	; 0x04
     c44:	87 e1       	ldi	r24, 0x17	; 23
     c46:	80 83       	st	Z, r24
	pxTopOfStack--;
     c48:	8b 81       	ldd	r24, Y+3	; 0x03
     c4a:	9c 81       	ldd	r25, Y+4	; 0x04
     c4c:	01 97       	sbiw	r24, 0x01	; 1
     c4e:	9c 83       	std	Y+4, r25	; 0x04
     c50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     c52:	eb 81       	ldd	r30, Y+3	; 0x03
     c54:	fc 81       	ldd	r31, Y+4	; 0x04
     c56:	88 e1       	ldi	r24, 0x18	; 24
     c58:	80 83       	st	Z, r24
	pxTopOfStack--;
     c5a:	8b 81       	ldd	r24, Y+3	; 0x03
     c5c:	9c 81       	ldd	r25, Y+4	; 0x04
     c5e:	01 97       	sbiw	r24, 0x01	; 1
     c60:	9c 83       	std	Y+4, r25	; 0x04
     c62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     c64:	eb 81       	ldd	r30, Y+3	; 0x03
     c66:	fc 81       	ldd	r31, Y+4	; 0x04
     c68:	89 e1       	ldi	r24, 0x19	; 25
     c6a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c6c:	8b 81       	ldd	r24, Y+3	; 0x03
     c6e:	9c 81       	ldd	r25, Y+4	; 0x04
     c70:	01 97       	sbiw	r24, 0x01	; 1
     c72:	9c 83       	std	Y+4, r25	; 0x04
     c74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     c76:	eb 81       	ldd	r30, Y+3	; 0x03
     c78:	fc 81       	ldd	r31, Y+4	; 0x04
     c7a:	80 e2       	ldi	r24, 0x20	; 32
     c7c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c7e:	8b 81       	ldd	r24, Y+3	; 0x03
     c80:	9c 81       	ldd	r25, Y+4	; 0x04
     c82:	01 97       	sbiw	r24, 0x01	; 1
     c84:	9c 83       	std	Y+4, r25	; 0x04
     c86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     c88:	eb 81       	ldd	r30, Y+3	; 0x03
     c8a:	fc 81       	ldd	r31, Y+4	; 0x04
     c8c:	81 e2       	ldi	r24, 0x21	; 33
     c8e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c90:	8b 81       	ldd	r24, Y+3	; 0x03
     c92:	9c 81       	ldd	r25, Y+4	; 0x04
     c94:	01 97       	sbiw	r24, 0x01	; 1
     c96:	9c 83       	std	Y+4, r25	; 0x04
     c98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     c9a:	eb 81       	ldd	r30, Y+3	; 0x03
     c9c:	fc 81       	ldd	r31, Y+4	; 0x04
     c9e:	82 e2       	ldi	r24, 0x22	; 34
     ca0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ca2:	8b 81       	ldd	r24, Y+3	; 0x03
     ca4:	9c 81       	ldd	r25, Y+4	; 0x04
     ca6:	01 97       	sbiw	r24, 0x01	; 1
     ca8:	9c 83       	std	Y+4, r25	; 0x04
     caa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     cac:	eb 81       	ldd	r30, Y+3	; 0x03
     cae:	fc 81       	ldd	r31, Y+4	; 0x04
     cb0:	83 e2       	ldi	r24, 0x23	; 35
     cb2:	80 83       	st	Z, r24
	pxTopOfStack--;
     cb4:	8b 81       	ldd	r24, Y+3	; 0x03
     cb6:	9c 81       	ldd	r25, Y+4	; 0x04
     cb8:	01 97       	sbiw	r24, 0x01	; 1
     cba:	9c 83       	std	Y+4, r25	; 0x04
     cbc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     cbe:	8f 81       	ldd	r24, Y+7	; 0x07
     cc0:	98 85       	ldd	r25, Y+8	; 0x08
     cc2:	9a 83       	std	Y+2, r25	; 0x02
     cc4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     cc6:	89 81       	ldd	r24, Y+1	; 0x01
     cc8:	eb 81       	ldd	r30, Y+3	; 0x03
     cca:	fc 81       	ldd	r31, Y+4	; 0x04
     ccc:	80 83       	st	Z, r24
	pxTopOfStack--;
     cce:	8b 81       	ldd	r24, Y+3	; 0x03
     cd0:	9c 81       	ldd	r25, Y+4	; 0x04
     cd2:	01 97       	sbiw	r24, 0x01	; 1
     cd4:	9c 83       	std	Y+4, r25	; 0x04
     cd6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     cd8:	89 81       	ldd	r24, Y+1	; 0x01
     cda:	9a 81       	ldd	r25, Y+2	; 0x02
     cdc:	89 2f       	mov	r24, r25
     cde:	99 27       	eor	r25, r25
     ce0:	9a 83       	std	Y+2, r25	; 0x02
     ce2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     ce4:	89 81       	ldd	r24, Y+1	; 0x01
     ce6:	eb 81       	ldd	r30, Y+3	; 0x03
     ce8:	fc 81       	ldd	r31, Y+4	; 0x04
     cea:	80 83       	st	Z, r24
	pxTopOfStack--;
     cec:	8b 81       	ldd	r24, Y+3	; 0x03
     cee:	9c 81       	ldd	r25, Y+4	; 0x04
     cf0:	01 97       	sbiw	r24, 0x01	; 1
     cf2:	9c 83       	std	Y+4, r25	; 0x04
     cf4:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     cf6:	eb 81       	ldd	r30, Y+3	; 0x03
     cf8:	fc 81       	ldd	r31, Y+4	; 0x04
     cfa:	86 e2       	ldi	r24, 0x26	; 38
     cfc:	80 83       	st	Z, r24
	pxTopOfStack--;
     cfe:	8b 81       	ldd	r24, Y+3	; 0x03
     d00:	9c 81       	ldd	r25, Y+4	; 0x04
     d02:	01 97       	sbiw	r24, 0x01	; 1
     d04:	9c 83       	std	Y+4, r25	; 0x04
     d06:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     d08:	eb 81       	ldd	r30, Y+3	; 0x03
     d0a:	fc 81       	ldd	r31, Y+4	; 0x04
     d0c:	87 e2       	ldi	r24, 0x27	; 39
     d0e:	80 83       	st	Z, r24
	pxTopOfStack--;
     d10:	8b 81       	ldd	r24, Y+3	; 0x03
     d12:	9c 81       	ldd	r25, Y+4	; 0x04
     d14:	01 97       	sbiw	r24, 0x01	; 1
     d16:	9c 83       	std	Y+4, r25	; 0x04
     d18:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     d1a:	eb 81       	ldd	r30, Y+3	; 0x03
     d1c:	fc 81       	ldd	r31, Y+4	; 0x04
     d1e:	88 e2       	ldi	r24, 0x28	; 40
     d20:	80 83       	st	Z, r24
	pxTopOfStack--;
     d22:	8b 81       	ldd	r24, Y+3	; 0x03
     d24:	9c 81       	ldd	r25, Y+4	; 0x04
     d26:	01 97       	sbiw	r24, 0x01	; 1
     d28:	9c 83       	std	Y+4, r25	; 0x04
     d2a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     d2c:	eb 81       	ldd	r30, Y+3	; 0x03
     d2e:	fc 81       	ldd	r31, Y+4	; 0x04
     d30:	89 e2       	ldi	r24, 0x29	; 41
     d32:	80 83       	st	Z, r24
	pxTopOfStack--;
     d34:	8b 81       	ldd	r24, Y+3	; 0x03
     d36:	9c 81       	ldd	r25, Y+4	; 0x04
     d38:	01 97       	sbiw	r24, 0x01	; 1
     d3a:	9c 83       	std	Y+4, r25	; 0x04
     d3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     d3e:	eb 81       	ldd	r30, Y+3	; 0x03
     d40:	fc 81       	ldd	r31, Y+4	; 0x04
     d42:	80 e3       	ldi	r24, 0x30	; 48
     d44:	80 83       	st	Z, r24
	pxTopOfStack--;
     d46:	8b 81       	ldd	r24, Y+3	; 0x03
     d48:	9c 81       	ldd	r25, Y+4	; 0x04
     d4a:	01 97       	sbiw	r24, 0x01	; 1
     d4c:	9c 83       	std	Y+4, r25	; 0x04
     d4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     d50:	eb 81       	ldd	r30, Y+3	; 0x03
     d52:	fc 81       	ldd	r31, Y+4	; 0x04
     d54:	81 e3       	ldi	r24, 0x31	; 49
     d56:	80 83       	st	Z, r24
	pxTopOfStack--;
     d58:	8b 81       	ldd	r24, Y+3	; 0x03
     d5a:	9c 81       	ldd	r25, Y+4	; 0x04
     d5c:	01 97       	sbiw	r24, 0x01	; 1
     d5e:	9c 83       	std	Y+4, r25	; 0x04
     d60:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     d62:	8b 81       	ldd	r24, Y+3	; 0x03
     d64:	9c 81       	ldd	r25, Y+4	; 0x04
}
     d66:	28 96       	adiw	r28, 0x08	; 8
     d68:	0f b6       	in	r0, 0x3f	; 63
     d6a:	f8 94       	cli
     d6c:	de bf       	out	0x3e, r29	; 62
     d6e:	0f be       	out	0x3f, r0	; 63
     d70:	cd bf       	out	0x3d, r28	; 61
     d72:	cf 91       	pop	r28
     d74:	df 91       	pop	r29
     d76:	08 95       	ret

00000d78 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     d78:	df 93       	push	r29
     d7a:	cf 93       	push	r28
     d7c:	cd b7       	in	r28, 0x3d	; 61
     d7e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     d80:	0e 94 ac 07 	call	0xf58	; 0xf58 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     d84:	a0 91 fc 02 	lds	r26, 0x02FC
     d88:	b0 91 fd 02 	lds	r27, 0x02FD
     d8c:	cd 91       	ld	r28, X+
     d8e:	cd bf       	out	0x3d, r28	; 61
     d90:	dd 91       	ld	r29, X+
     d92:	de bf       	out	0x3e, r29	; 62
     d94:	ff 91       	pop	r31
     d96:	ef 91       	pop	r30
     d98:	df 91       	pop	r29
     d9a:	cf 91       	pop	r28
     d9c:	bf 91       	pop	r27
     d9e:	af 91       	pop	r26
     da0:	9f 91       	pop	r25
     da2:	8f 91       	pop	r24
     da4:	7f 91       	pop	r23
     da6:	6f 91       	pop	r22
     da8:	5f 91       	pop	r21
     daa:	4f 91       	pop	r20
     dac:	3f 91       	pop	r19
     dae:	2f 91       	pop	r18
     db0:	1f 91       	pop	r17
     db2:	0f 91       	pop	r16
     db4:	ff 90       	pop	r15
     db6:	ef 90       	pop	r14
     db8:	df 90       	pop	r13
     dba:	cf 90       	pop	r12
     dbc:	bf 90       	pop	r11
     dbe:	af 90       	pop	r10
     dc0:	9f 90       	pop	r9
     dc2:	8f 90       	pop	r8
     dc4:	7f 90       	pop	r7
     dc6:	6f 90       	pop	r6
     dc8:	5f 90       	pop	r5
     dca:	4f 90       	pop	r4
     dcc:	3f 90       	pop	r3
     dce:	2f 90       	pop	r2
     dd0:	1f 90       	pop	r1
     dd2:	0f 90       	pop	r0
     dd4:	0f be       	out	0x3f, r0	; 63
     dd6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     dd8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     dda:	81 e0       	ldi	r24, 0x01	; 1
}
     ddc:	cf 91       	pop	r28
     dde:	df 91       	pop	r29
     de0:	08 95       	ret

00000de2 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     de2:	df 93       	push	r29
     de4:	cf 93       	push	r28
     de6:	cd b7       	in	r28, 0x3d	; 61
     de8:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     dea:	cf 91       	pop	r28
     dec:	df 91       	pop	r29
     dee:	08 95       	ret

00000df0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     df0:	0f 92       	push	r0
     df2:	0f b6       	in	r0, 0x3f	; 63
     df4:	f8 94       	cli
     df6:	0f 92       	push	r0
     df8:	1f 92       	push	r1
     dfa:	11 24       	eor	r1, r1
     dfc:	2f 92       	push	r2
     dfe:	3f 92       	push	r3
     e00:	4f 92       	push	r4
     e02:	5f 92       	push	r5
     e04:	6f 92       	push	r6
     e06:	7f 92       	push	r7
     e08:	8f 92       	push	r8
     e0a:	9f 92       	push	r9
     e0c:	af 92       	push	r10
     e0e:	bf 92       	push	r11
     e10:	cf 92       	push	r12
     e12:	df 92       	push	r13
     e14:	ef 92       	push	r14
     e16:	ff 92       	push	r15
     e18:	0f 93       	push	r16
     e1a:	1f 93       	push	r17
     e1c:	2f 93       	push	r18
     e1e:	3f 93       	push	r19
     e20:	4f 93       	push	r20
     e22:	5f 93       	push	r21
     e24:	6f 93       	push	r22
     e26:	7f 93       	push	r23
     e28:	8f 93       	push	r24
     e2a:	9f 93       	push	r25
     e2c:	af 93       	push	r26
     e2e:	bf 93       	push	r27
     e30:	cf 93       	push	r28
     e32:	df 93       	push	r29
     e34:	ef 93       	push	r30
     e36:	ff 93       	push	r31
     e38:	a0 91 fc 02 	lds	r26, 0x02FC
     e3c:	b0 91 fd 02 	lds	r27, 0x02FD
     e40:	0d b6       	in	r0, 0x3d	; 61
     e42:	0d 92       	st	X+, r0
     e44:	0e b6       	in	r0, 0x3e	; 62
     e46:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e48:	0e 94 b2 12 	call	0x2564	; 0x2564 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e4c:	a0 91 fc 02 	lds	r26, 0x02FC
     e50:	b0 91 fd 02 	lds	r27, 0x02FD
     e54:	cd 91       	ld	r28, X+
     e56:	cd bf       	out	0x3d, r28	; 61
     e58:	dd 91       	ld	r29, X+
     e5a:	de bf       	out	0x3e, r29	; 62
     e5c:	ff 91       	pop	r31
     e5e:	ef 91       	pop	r30
     e60:	df 91       	pop	r29
     e62:	cf 91       	pop	r28
     e64:	bf 91       	pop	r27
     e66:	af 91       	pop	r26
     e68:	9f 91       	pop	r25
     e6a:	8f 91       	pop	r24
     e6c:	7f 91       	pop	r23
     e6e:	6f 91       	pop	r22
     e70:	5f 91       	pop	r21
     e72:	4f 91       	pop	r20
     e74:	3f 91       	pop	r19
     e76:	2f 91       	pop	r18
     e78:	1f 91       	pop	r17
     e7a:	0f 91       	pop	r16
     e7c:	ff 90       	pop	r15
     e7e:	ef 90       	pop	r14
     e80:	df 90       	pop	r13
     e82:	cf 90       	pop	r12
     e84:	bf 90       	pop	r11
     e86:	af 90       	pop	r10
     e88:	9f 90       	pop	r9
     e8a:	8f 90       	pop	r8
     e8c:	7f 90       	pop	r7
     e8e:	6f 90       	pop	r6
     e90:	5f 90       	pop	r5
     e92:	4f 90       	pop	r4
     e94:	3f 90       	pop	r3
     e96:	2f 90       	pop	r2
     e98:	1f 90       	pop	r1
     e9a:	0f 90       	pop	r0
     e9c:	0f be       	out	0x3f, r0	; 63
     e9e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ea0:	08 95       	ret

00000ea2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     ea2:	0f 92       	push	r0
     ea4:	0f b6       	in	r0, 0x3f	; 63
     ea6:	f8 94       	cli
     ea8:	0f 92       	push	r0
     eaa:	1f 92       	push	r1
     eac:	11 24       	eor	r1, r1
     eae:	2f 92       	push	r2
     eb0:	3f 92       	push	r3
     eb2:	4f 92       	push	r4
     eb4:	5f 92       	push	r5
     eb6:	6f 92       	push	r6
     eb8:	7f 92       	push	r7
     eba:	8f 92       	push	r8
     ebc:	9f 92       	push	r9
     ebe:	af 92       	push	r10
     ec0:	bf 92       	push	r11
     ec2:	cf 92       	push	r12
     ec4:	df 92       	push	r13
     ec6:	ef 92       	push	r14
     ec8:	ff 92       	push	r15
     eca:	0f 93       	push	r16
     ecc:	1f 93       	push	r17
     ece:	2f 93       	push	r18
     ed0:	3f 93       	push	r19
     ed2:	4f 93       	push	r20
     ed4:	5f 93       	push	r21
     ed6:	6f 93       	push	r22
     ed8:	7f 93       	push	r23
     eda:	8f 93       	push	r24
     edc:	9f 93       	push	r25
     ede:	af 93       	push	r26
     ee0:	bf 93       	push	r27
     ee2:	cf 93       	push	r28
     ee4:	df 93       	push	r29
     ee6:	ef 93       	push	r30
     ee8:	ff 93       	push	r31
     eea:	a0 91 fc 02 	lds	r26, 0x02FC
     eee:	b0 91 fd 02 	lds	r27, 0x02FD
     ef2:	0d b6       	in	r0, 0x3d	; 61
     ef4:	0d 92       	st	X+, r0
     ef6:	0e b6       	in	r0, 0x3e	; 62
     ef8:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     efa:	0e 94 dd 11 	call	0x23ba	; 0x23ba <vTaskIncrementTick>
	vTaskSwitchContext();
     efe:	0e 94 b2 12 	call	0x2564	; 0x2564 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f02:	a0 91 fc 02 	lds	r26, 0x02FC
     f06:	b0 91 fd 02 	lds	r27, 0x02FD
     f0a:	cd 91       	ld	r28, X+
     f0c:	cd bf       	out	0x3d, r28	; 61
     f0e:	dd 91       	ld	r29, X+
     f10:	de bf       	out	0x3e, r29	; 62
     f12:	ff 91       	pop	r31
     f14:	ef 91       	pop	r30
     f16:	df 91       	pop	r29
     f18:	cf 91       	pop	r28
     f1a:	bf 91       	pop	r27
     f1c:	af 91       	pop	r26
     f1e:	9f 91       	pop	r25
     f20:	8f 91       	pop	r24
     f22:	7f 91       	pop	r23
     f24:	6f 91       	pop	r22
     f26:	5f 91       	pop	r21
     f28:	4f 91       	pop	r20
     f2a:	3f 91       	pop	r19
     f2c:	2f 91       	pop	r18
     f2e:	1f 91       	pop	r17
     f30:	0f 91       	pop	r16
     f32:	ff 90       	pop	r15
     f34:	ef 90       	pop	r14
     f36:	df 90       	pop	r13
     f38:	cf 90       	pop	r12
     f3a:	bf 90       	pop	r11
     f3c:	af 90       	pop	r10
     f3e:	9f 90       	pop	r9
     f40:	8f 90       	pop	r8
     f42:	7f 90       	pop	r7
     f44:	6f 90       	pop	r6
     f46:	5f 90       	pop	r5
     f48:	4f 90       	pop	r4
     f4a:	3f 90       	pop	r3
     f4c:	2f 90       	pop	r2
     f4e:	1f 90       	pop	r1
     f50:	0f 90       	pop	r0
     f52:	0f be       	out	0x3f, r0	; 63
     f54:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f56:	08 95       	ret

00000f58 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     f58:	df 93       	push	r29
     f5a:	cf 93       	push	r28
     f5c:	00 d0       	rcall	.+0      	; 0xf5e <prvSetupTimerInterrupt+0x6>
     f5e:	00 d0       	rcall	.+0      	; 0xf60 <prvSetupTimerInterrupt+0x8>
     f60:	00 d0       	rcall	.+0      	; 0xf62 <prvSetupTimerInterrupt+0xa>
     f62:	cd b7       	in	r28, 0x3d	; 61
     f64:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     f66:	88 ee       	ldi	r24, 0xE8	; 232
     f68:	93 e0       	ldi	r25, 0x03	; 3
     f6a:	a0 e0       	ldi	r26, 0x00	; 0
     f6c:	b0 e0       	ldi	r27, 0x00	; 0
     f6e:	8b 83       	std	Y+3, r24	; 0x03
     f70:	9c 83       	std	Y+4, r25	; 0x04
     f72:	ad 83       	std	Y+5, r26	; 0x05
     f74:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     f76:	8b 81       	ldd	r24, Y+3	; 0x03
     f78:	9c 81       	ldd	r25, Y+4	; 0x04
     f7a:	ad 81       	ldd	r26, Y+5	; 0x05
     f7c:	be 81       	ldd	r27, Y+6	; 0x06
     f7e:	68 94       	set
     f80:	15 f8       	bld	r1, 5
     f82:	b6 95       	lsr	r27
     f84:	a7 95       	ror	r26
     f86:	97 95       	ror	r25
     f88:	87 95       	ror	r24
     f8a:	16 94       	lsr	r1
     f8c:	d1 f7       	brne	.-12     	; 0xf82 <prvSetupTimerInterrupt+0x2a>
     f8e:	8b 83       	std	Y+3, r24	; 0x03
     f90:	9c 83       	std	Y+4, r25	; 0x04
     f92:	ad 83       	std	Y+5, r26	; 0x05
     f94:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
     f96:	8b 81       	ldd	r24, Y+3	; 0x03
     f98:	9c 81       	ldd	r25, Y+4	; 0x04
     f9a:	ad 81       	ldd	r26, Y+5	; 0x05
     f9c:	be 81       	ldd	r27, Y+6	; 0x06
     f9e:	01 97       	sbiw	r24, 0x01	; 1
     fa0:	a1 09       	sbc	r26, r1
     fa2:	b1 09       	sbc	r27, r1
     fa4:	8b 83       	std	Y+3, r24	; 0x03
     fa6:	9c 83       	std	Y+4, r25	; 0x04
     fa8:	ad 83       	std	Y+5, r26	; 0x05
     faa:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     fac:	8b 81       	ldd	r24, Y+3	; 0x03
     fae:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     fb0:	8b 81       	ldd	r24, Y+3	; 0x03
     fb2:	9c 81       	ldd	r25, Y+4	; 0x04
     fb4:	ad 81       	ldd	r26, Y+5	; 0x05
     fb6:	be 81       	ldd	r27, Y+6	; 0x06
     fb8:	89 2f       	mov	r24, r25
     fba:	9a 2f       	mov	r25, r26
     fbc:	ab 2f       	mov	r26, r27
     fbe:	bb 27       	eor	r27, r27
     fc0:	8b 83       	std	Y+3, r24	; 0x03
     fc2:	9c 83       	std	Y+4, r25	; 0x04
     fc4:	ad 83       	std	Y+5, r26	; 0x05
     fc6:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     fc8:	8b 81       	ldd	r24, Y+3	; 0x03
     fca:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     fcc:	eb e4       	ldi	r30, 0x4B	; 75
     fce:	f0 e0       	ldi	r31, 0x00	; 0
     fd0:	8a 81       	ldd	r24, Y+2	; 0x02
     fd2:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     fd4:	ea e4       	ldi	r30, 0x4A	; 74
     fd6:	f0 e0       	ldi	r31, 0x00	; 0
     fd8:	89 81       	ldd	r24, Y+1	; 0x01
     fda:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     fdc:	8b e0       	ldi	r24, 0x0B	; 11
     fde:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     fe0:	ee e4       	ldi	r30, 0x4E	; 78
     fe2:	f0 e0       	ldi	r31, 0x00	; 0
     fe4:	89 81       	ldd	r24, Y+1	; 0x01
     fe6:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     fe8:	e9 e5       	ldi	r30, 0x59	; 89
     fea:	f0 e0       	ldi	r31, 0x00	; 0
     fec:	80 81       	ld	r24, Z
     fee:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     ff0:	89 81       	ldd	r24, Y+1	; 0x01
     ff2:	80 61       	ori	r24, 0x10	; 16
     ff4:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     ff6:	e9 e5       	ldi	r30, 0x59	; 89
     ff8:	f0 e0       	ldi	r31, 0x00	; 0
     ffa:	89 81       	ldd	r24, Y+1	; 0x01
     ffc:	80 83       	st	Z, r24
}
     ffe:	26 96       	adiw	r28, 0x06	; 6
    1000:	0f b6       	in	r0, 0x3f	; 63
    1002:	f8 94       	cli
    1004:	de bf       	out	0x3e, r29	; 62
    1006:	0f be       	out	0x3f, r0	; 63
    1008:	cd bf       	out	0x3d, r28	; 61
    100a:	cf 91       	pop	r28
    100c:	df 91       	pop	r29
    100e:	08 95       	ret

00001010 <__vector_6>:
	 * count is incremented after the context is saved.
	 */
	void  TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void  TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1010:	0e 94 51 07 	call	0xea2	; 0xea2 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1014:	18 95       	reti

00001016 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1016:	df 93       	push	r29
    1018:	cf 93       	push	r28
    101a:	cd b7       	in	r28, 0x3d	; 61
    101c:	de b7       	in	r29, 0x3e	; 62
    101e:	28 97       	sbiw	r28, 0x08	; 8
    1020:	0f b6       	in	r0, 0x3f	; 63
    1022:	f8 94       	cli
    1024:	de bf       	out	0x3e, r29	; 62
    1026:	0f be       	out	0x3f, r0	; 63
    1028:	cd bf       	out	0x3d, r28	; 61
    102a:	8f 83       	std	Y+7, r24	; 0x07
    102c:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    102e:	1a 82       	std	Y+2, r1	; 0x02
    1030:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1032:	8f 81       	ldd	r24, Y+7	; 0x07
    1034:	88 23       	and	r24, r24
    1036:	09 f4       	brne	.+2      	; 0x103a <xQueueCreate+0x24>
    1038:	8c c0       	rjmp	.+280    	; 0x1152 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    103a:	8f e1       	ldi	r24, 0x1F	; 31
    103c:	90 e0       	ldi	r25, 0x00	; 0
    103e:	0e 94 92 03 	call	0x724	; 0x724 <pvPortMalloc>
    1042:	9e 83       	std	Y+6, r25	; 0x06
    1044:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1046:	8d 81       	ldd	r24, Y+5	; 0x05
    1048:	9e 81       	ldd	r25, Y+6	; 0x06
    104a:	00 97       	sbiw	r24, 0x00	; 0
    104c:	09 f4       	brne	.+2      	; 0x1050 <xQueueCreate+0x3a>
    104e:	81 c0       	rjmp	.+258    	; 0x1152 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1050:	8f 81       	ldd	r24, Y+7	; 0x07
    1052:	28 2f       	mov	r18, r24
    1054:	30 e0       	ldi	r19, 0x00	; 0
    1056:	88 85       	ldd	r24, Y+8	; 0x08
    1058:	88 2f       	mov	r24, r24
    105a:	90 e0       	ldi	r25, 0x00	; 0
    105c:	ac 01       	movw	r20, r24
    105e:	24 9f       	mul	r18, r20
    1060:	c0 01       	movw	r24, r0
    1062:	25 9f       	mul	r18, r21
    1064:	90 0d       	add	r25, r0
    1066:	34 9f       	mul	r19, r20
    1068:	90 0d       	add	r25, r0
    106a:	11 24       	eor	r1, r1
    106c:	01 96       	adiw	r24, 0x01	; 1
    106e:	9c 83       	std	Y+4, r25	; 0x04
    1070:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1072:	8b 81       	ldd	r24, Y+3	; 0x03
    1074:	9c 81       	ldd	r25, Y+4	; 0x04
    1076:	0e 94 92 03 	call	0x724	; 0x724 <pvPortMalloc>
    107a:	ed 81       	ldd	r30, Y+5	; 0x05
    107c:	fe 81       	ldd	r31, Y+6	; 0x06
    107e:	91 83       	std	Z+1, r25	; 0x01
    1080:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1082:	ed 81       	ldd	r30, Y+5	; 0x05
    1084:	fe 81       	ldd	r31, Y+6	; 0x06
    1086:	80 81       	ld	r24, Z
    1088:	91 81       	ldd	r25, Z+1	; 0x01
    108a:	00 97       	sbiw	r24, 0x00	; 0
    108c:	09 f4       	brne	.+2      	; 0x1090 <xQueueCreate+0x7a>
    108e:	5d c0       	rjmp	.+186    	; 0x114a <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1090:	ed 81       	ldd	r30, Y+5	; 0x05
    1092:	fe 81       	ldd	r31, Y+6	; 0x06
    1094:	40 81       	ld	r20, Z
    1096:	51 81       	ldd	r21, Z+1	; 0x01
    1098:	8f 81       	ldd	r24, Y+7	; 0x07
    109a:	28 2f       	mov	r18, r24
    109c:	30 e0       	ldi	r19, 0x00	; 0
    109e:	88 85       	ldd	r24, Y+8	; 0x08
    10a0:	88 2f       	mov	r24, r24
    10a2:	90 e0       	ldi	r25, 0x00	; 0
    10a4:	bc 01       	movw	r22, r24
    10a6:	26 9f       	mul	r18, r22
    10a8:	c0 01       	movw	r24, r0
    10aa:	27 9f       	mul	r18, r23
    10ac:	90 0d       	add	r25, r0
    10ae:	36 9f       	mul	r19, r22
    10b0:	90 0d       	add	r25, r0
    10b2:	11 24       	eor	r1, r1
    10b4:	84 0f       	add	r24, r20
    10b6:	95 1f       	adc	r25, r21
    10b8:	ed 81       	ldd	r30, Y+5	; 0x05
    10ba:	fe 81       	ldd	r31, Y+6	; 0x06
    10bc:	93 83       	std	Z+3, r25	; 0x03
    10be:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    10c0:	ed 81       	ldd	r30, Y+5	; 0x05
    10c2:	fe 81       	ldd	r31, Y+6	; 0x06
    10c4:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    10c6:	ed 81       	ldd	r30, Y+5	; 0x05
    10c8:	fe 81       	ldd	r31, Y+6	; 0x06
    10ca:	80 81       	ld	r24, Z
    10cc:	91 81       	ldd	r25, Z+1	; 0x01
    10ce:	ed 81       	ldd	r30, Y+5	; 0x05
    10d0:	fe 81       	ldd	r31, Y+6	; 0x06
    10d2:	95 83       	std	Z+5, r25	; 0x05
    10d4:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    10d6:	ed 81       	ldd	r30, Y+5	; 0x05
    10d8:	fe 81       	ldd	r31, Y+6	; 0x06
    10da:	40 81       	ld	r20, Z
    10dc:	51 81       	ldd	r21, Z+1	; 0x01
    10de:	8f 81       	ldd	r24, Y+7	; 0x07
    10e0:	88 2f       	mov	r24, r24
    10e2:	90 e0       	ldi	r25, 0x00	; 0
    10e4:	9c 01       	movw	r18, r24
    10e6:	21 50       	subi	r18, 0x01	; 1
    10e8:	30 40       	sbci	r19, 0x00	; 0
    10ea:	88 85       	ldd	r24, Y+8	; 0x08
    10ec:	88 2f       	mov	r24, r24
    10ee:	90 e0       	ldi	r25, 0x00	; 0
    10f0:	bc 01       	movw	r22, r24
    10f2:	26 9f       	mul	r18, r22
    10f4:	c0 01       	movw	r24, r0
    10f6:	27 9f       	mul	r18, r23
    10f8:	90 0d       	add	r25, r0
    10fa:	36 9f       	mul	r19, r22
    10fc:	90 0d       	add	r25, r0
    10fe:	11 24       	eor	r1, r1
    1100:	84 0f       	add	r24, r20
    1102:	95 1f       	adc	r25, r21
    1104:	ed 81       	ldd	r30, Y+5	; 0x05
    1106:	fe 81       	ldd	r31, Y+6	; 0x06
    1108:	97 83       	std	Z+7, r25	; 0x07
    110a:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    110c:	ed 81       	ldd	r30, Y+5	; 0x05
    110e:	fe 81       	ldd	r31, Y+6	; 0x06
    1110:	8f 81       	ldd	r24, Y+7	; 0x07
    1112:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1114:	ed 81       	ldd	r30, Y+5	; 0x05
    1116:	fe 81       	ldd	r31, Y+6	; 0x06
    1118:	88 85       	ldd	r24, Y+8	; 0x08
    111a:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    111c:	ed 81       	ldd	r30, Y+5	; 0x05
    111e:	fe 81       	ldd	r31, Y+6	; 0x06
    1120:	8f ef       	ldi	r24, 0xFF	; 255
    1122:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1124:	ed 81       	ldd	r30, Y+5	; 0x05
    1126:	fe 81       	ldd	r31, Y+6	; 0x06
    1128:	8f ef       	ldi	r24, 0xFF	; 255
    112a:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    112c:	8d 81       	ldd	r24, Y+5	; 0x05
    112e:	9e 81       	ldd	r25, Y+6	; 0x06
    1130:	08 96       	adiw	r24, 0x08	; 8
    1132:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1136:	8d 81       	ldd	r24, Y+5	; 0x05
    1138:	9e 81       	ldd	r25, Y+6	; 0x06
    113a:	41 96       	adiw	r24, 0x11	; 17
    113c:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1140:	8d 81       	ldd	r24, Y+5	; 0x05
    1142:	9e 81       	ldd	r25, Y+6	; 0x06
    1144:	9a 83       	std	Y+2, r25	; 0x02
    1146:	89 83       	std	Y+1, r24	; 0x01
    1148:	04 c0       	rjmp	.+8      	; 0x1152 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    114a:	8d 81       	ldd	r24, Y+5	; 0x05
    114c:	9e 81       	ldd	r25, Y+6	; 0x06
    114e:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1152:	89 81       	ldd	r24, Y+1	; 0x01
    1154:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1156:	28 96       	adiw	r28, 0x08	; 8
    1158:	0f b6       	in	r0, 0x3f	; 63
    115a:	f8 94       	cli
    115c:	de bf       	out	0x3e, r29	; 62
    115e:	0f be       	out	0x3f, r0	; 63
    1160:	cd bf       	out	0x3d, r28	; 61
    1162:	cf 91       	pop	r28
    1164:	df 91       	pop	r29
    1166:	08 95       	ret

00001168 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1168:	df 93       	push	r29
    116a:	cf 93       	push	r28
    116c:	cd b7       	in	r28, 0x3d	; 61
    116e:	de b7       	in	r29, 0x3e	; 62
    1170:	2c 97       	sbiw	r28, 0x0c	; 12
    1172:	0f b6       	in	r0, 0x3f	; 63
    1174:	f8 94       	cli
    1176:	de bf       	out	0x3e, r29	; 62
    1178:	0f be       	out	0x3f, r0	; 63
    117a:	cd bf       	out	0x3d, r28	; 61
    117c:	9e 83       	std	Y+6, r25	; 0x06
    117e:	8d 83       	std	Y+5, r24	; 0x05
    1180:	78 87       	std	Y+8, r23	; 0x08
    1182:	6f 83       	std	Y+7, r22	; 0x07
    1184:	5a 87       	std	Y+10, r21	; 0x0a
    1186:	49 87       	std	Y+9, r20	; 0x09
    1188:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    118a:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    118c:	0f b6       	in	r0, 0x3f	; 63
    118e:	f8 94       	cli
    1190:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1192:	ed 81       	ldd	r30, Y+5	; 0x05
    1194:	fe 81       	ldd	r31, Y+6	; 0x06
    1196:	92 8d       	ldd	r25, Z+26	; 0x1a
    1198:	ed 81       	ldd	r30, Y+5	; 0x05
    119a:	fe 81       	ldd	r31, Y+6	; 0x06
    119c:	83 8d       	ldd	r24, Z+27	; 0x1b
    119e:	98 17       	cp	r25, r24
    11a0:	d8 f4       	brcc	.+54     	; 0x11d8 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    11a2:	8d 81       	ldd	r24, Y+5	; 0x05
    11a4:	9e 81       	ldd	r25, Y+6	; 0x06
    11a6:	2f 81       	ldd	r18, Y+7	; 0x07
    11a8:	38 85       	ldd	r19, Y+8	; 0x08
    11aa:	b9 01       	movw	r22, r18
    11ac:	4b 85       	ldd	r20, Y+11	; 0x0b
    11ae:	0e 94 ef 0a 	call	0x15de	; 0x15de <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    11b2:	ed 81       	ldd	r30, Y+5	; 0x05
    11b4:	fe 81       	ldd	r31, Y+6	; 0x06
    11b6:	81 89       	ldd	r24, Z+17	; 0x11
    11b8:	88 23       	and	r24, r24
    11ba:	49 f0       	breq	.+18     	; 0x11ce <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    11bc:	8d 81       	ldd	r24, Y+5	; 0x05
    11be:	9e 81       	ldd	r25, Y+6	; 0x06
    11c0:	41 96       	adiw	r24, 0x11	; 17
    11c2:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskRemoveFromEventList>
    11c6:	81 30       	cpi	r24, 0x01	; 1
    11c8:	11 f4       	brne	.+4      	; 0x11ce <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    11ca:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    11ce:	0f 90       	pop	r0
    11d0:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    11d2:	81 e0       	ldi	r24, 0x01	; 1
    11d4:	8c 87       	std	Y+12, r24	; 0x0c
    11d6:	5c c0       	rjmp	.+184    	; 0x1290 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    11d8:	89 85       	ldd	r24, Y+9	; 0x09
    11da:	9a 85       	ldd	r25, Y+10	; 0x0a
    11dc:	00 97       	sbiw	r24, 0x00	; 0
    11de:	21 f4       	brne	.+8      	; 0x11e8 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    11e0:	0f 90       	pop	r0
    11e2:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    11e4:	1c 86       	std	Y+12, r1	; 0x0c
    11e6:	54 c0       	rjmp	.+168    	; 0x1290 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    11e8:	89 81       	ldd	r24, Y+1	; 0x01
    11ea:	88 23       	and	r24, r24
    11ec:	31 f4       	brne	.+12     	; 0x11fa <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    11ee:	ce 01       	movw	r24, r28
    11f0:	02 96       	adiw	r24, 0x02	; 2
    11f2:	0e 94 c9 13 	call	0x2792	; 0x2792 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    11f6:	81 e0       	ldi	r24, 0x01	; 1
    11f8:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    11fa:	0f 90       	pop	r0
    11fc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    11fe:	0e 94 07 11 	call	0x220e	; 0x220e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1202:	0f b6       	in	r0, 0x3f	; 63
    1204:	f8 94       	cli
    1206:	0f 92       	push	r0
    1208:	ed 81       	ldd	r30, Y+5	; 0x05
    120a:	fe 81       	ldd	r31, Y+6	; 0x06
    120c:	85 8d       	ldd	r24, Z+29	; 0x1d
    120e:	8f 3f       	cpi	r24, 0xFF	; 255
    1210:	19 f4       	brne	.+6      	; 0x1218 <xQueueGenericSend+0xb0>
    1212:	ed 81       	ldd	r30, Y+5	; 0x05
    1214:	fe 81       	ldd	r31, Y+6	; 0x06
    1216:	15 8e       	std	Z+29, r1	; 0x1d
    1218:	ed 81       	ldd	r30, Y+5	; 0x05
    121a:	fe 81       	ldd	r31, Y+6	; 0x06
    121c:	86 8d       	ldd	r24, Z+30	; 0x1e
    121e:	8f 3f       	cpi	r24, 0xFF	; 255
    1220:	19 f4       	brne	.+6      	; 0x1228 <xQueueGenericSend+0xc0>
    1222:	ed 81       	ldd	r30, Y+5	; 0x05
    1224:	fe 81       	ldd	r31, Y+6	; 0x06
    1226:	16 8e       	std	Z+30, r1	; 0x1e
    1228:	0f 90       	pop	r0
    122a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    122c:	ce 01       	movw	r24, r28
    122e:	02 96       	adiw	r24, 0x02	; 2
    1230:	9e 01       	movw	r18, r28
    1232:	27 5f       	subi	r18, 0xF7	; 247
    1234:	3f 4f       	sbci	r19, 0xFF	; 255
    1236:	b9 01       	movw	r22, r18
    1238:	0e 94 e2 13 	call	0x27c4	; 0x27c4 <xTaskCheckForTimeOut>
    123c:	88 23       	and	r24, r24
    123e:	09 f5       	brne	.+66     	; 0x1282 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1240:	8d 81       	ldd	r24, Y+5	; 0x05
    1242:	9e 81       	ldd	r25, Y+6	; 0x06
    1244:	0e 94 53 0c 	call	0x18a6	; 0x18a6 <prvIsQueueFull>
    1248:	88 23       	and	r24, r24
    124a:	a1 f0       	breq	.+40     	; 0x1274 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    124c:	8d 81       	ldd	r24, Y+5	; 0x05
    124e:	9e 81       	ldd	r25, Y+6	; 0x06
    1250:	08 96       	adiw	r24, 0x08	; 8
    1252:	29 85       	ldd	r18, Y+9	; 0x09
    1254:	3a 85       	ldd	r19, Y+10	; 0x0a
    1256:	b9 01       	movw	r22, r18
    1258:	0e 94 18 13 	call	0x2630	; 0x2630 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    125c:	8d 81       	ldd	r24, Y+5	; 0x05
    125e:	9e 81       	ldd	r25, Y+6	; 0x06
    1260:	0e 94 cc 0b 	call	0x1798	; 0x1798 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1264:	0e 94 13 11 	call	0x2226	; 0x2226 <xTaskResumeAll>
    1268:	88 23       	and	r24, r24
    126a:	09 f0       	breq	.+2      	; 0x126e <xQueueGenericSend+0x106>
    126c:	8f cf       	rjmp	.-226    	; 0x118c <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    126e:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortYield>
    1272:	8c cf       	rjmp	.-232    	; 0x118c <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1274:	8d 81       	ldd	r24, Y+5	; 0x05
    1276:	9e 81       	ldd	r25, Y+6	; 0x06
    1278:	0e 94 cc 0b 	call	0x1798	; 0x1798 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    127c:	0e 94 13 11 	call	0x2226	; 0x2226 <xTaskResumeAll>
    1280:	85 cf       	rjmp	.-246    	; 0x118c <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1282:	8d 81       	ldd	r24, Y+5	; 0x05
    1284:	9e 81       	ldd	r25, Y+6	; 0x06
    1286:	0e 94 cc 0b 	call	0x1798	; 0x1798 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    128a:	0e 94 13 11 	call	0x2226	; 0x2226 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    128e:	1c 86       	std	Y+12, r1	; 0x0c
    1290:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1292:	2c 96       	adiw	r28, 0x0c	; 12
    1294:	0f b6       	in	r0, 0x3f	; 63
    1296:	f8 94       	cli
    1298:	de bf       	out	0x3e, r29	; 62
    129a:	0f be       	out	0x3f, r0	; 63
    129c:	cd bf       	out	0x3d, r28	; 61
    129e:	cf 91       	pop	r28
    12a0:	df 91       	pop	r29
    12a2:	08 95       	ret

000012a4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    12a4:	df 93       	push	r29
    12a6:	cf 93       	push	r28
    12a8:	cd b7       	in	r28, 0x3d	; 61
    12aa:	de b7       	in	r29, 0x3e	; 62
    12ac:	29 97       	sbiw	r28, 0x09	; 9
    12ae:	0f b6       	in	r0, 0x3f	; 63
    12b0:	f8 94       	cli
    12b2:	de bf       	out	0x3e, r29	; 62
    12b4:	0f be       	out	0x3f, r0	; 63
    12b6:	cd bf       	out	0x3d, r28	; 61
    12b8:	9c 83       	std	Y+4, r25	; 0x04
    12ba:	8b 83       	std	Y+3, r24	; 0x03
    12bc:	7e 83       	std	Y+6, r23	; 0x06
    12be:	6d 83       	std	Y+5, r22	; 0x05
    12c0:	58 87       	std	Y+8, r21	; 0x08
    12c2:	4f 83       	std	Y+7, r20	; 0x07
    12c4:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    12c6:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    12c8:	eb 81       	ldd	r30, Y+3	; 0x03
    12ca:	fc 81       	ldd	r31, Y+4	; 0x04
    12cc:	92 8d       	ldd	r25, Z+26	; 0x1a
    12ce:	eb 81       	ldd	r30, Y+3	; 0x03
    12d0:	fc 81       	ldd	r31, Y+4	; 0x04
    12d2:	83 8d       	ldd	r24, Z+27	; 0x1b
    12d4:	98 17       	cp	r25, r24
    12d6:	40 f5       	brcc	.+80     	; 0x1328 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    12d8:	8b 81       	ldd	r24, Y+3	; 0x03
    12da:	9c 81       	ldd	r25, Y+4	; 0x04
    12dc:	2d 81       	ldd	r18, Y+5	; 0x05
    12de:	3e 81       	ldd	r19, Y+6	; 0x06
    12e0:	b9 01       	movw	r22, r18
    12e2:	49 85       	ldd	r20, Y+9	; 0x09
    12e4:	0e 94 ef 0a 	call	0x15de	; 0x15de <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    12e8:	eb 81       	ldd	r30, Y+3	; 0x03
    12ea:	fc 81       	ldd	r31, Y+4	; 0x04
    12ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    12ee:	8f 3f       	cpi	r24, 0xFF	; 255
    12f0:	89 f4       	brne	.+34     	; 0x1314 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12f2:	eb 81       	ldd	r30, Y+3	; 0x03
    12f4:	fc 81       	ldd	r31, Y+4	; 0x04
    12f6:	81 89       	ldd	r24, Z+17	; 0x11
    12f8:	88 23       	and	r24, r24
    12fa:	99 f0       	breq	.+38     	; 0x1322 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12fc:	8b 81       	ldd	r24, Y+3	; 0x03
    12fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1300:	41 96       	adiw	r24, 0x11	; 17
    1302:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskRemoveFromEventList>
    1306:	88 23       	and	r24, r24
    1308:	61 f0       	breq	.+24     	; 0x1322 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    130a:	ef 81       	ldd	r30, Y+7	; 0x07
    130c:	f8 85       	ldd	r31, Y+8	; 0x08
    130e:	81 e0       	ldi	r24, 0x01	; 1
    1310:	80 83       	st	Z, r24
    1312:	07 c0       	rjmp	.+14     	; 0x1322 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1314:	eb 81       	ldd	r30, Y+3	; 0x03
    1316:	fc 81       	ldd	r31, Y+4	; 0x04
    1318:	86 8d       	ldd	r24, Z+30	; 0x1e
    131a:	8f 5f       	subi	r24, 0xFF	; 255
    131c:	eb 81       	ldd	r30, Y+3	; 0x03
    131e:	fc 81       	ldd	r31, Y+4	; 0x04
    1320:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1322:	81 e0       	ldi	r24, 0x01	; 1
    1324:	8a 83       	std	Y+2, r24	; 0x02
    1326:	01 c0       	rjmp	.+2      	; 0x132a <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1328:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    132a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    132c:	29 96       	adiw	r28, 0x09	; 9
    132e:	0f b6       	in	r0, 0x3f	; 63
    1330:	f8 94       	cli
    1332:	de bf       	out	0x3e, r29	; 62
    1334:	0f be       	out	0x3f, r0	; 63
    1336:	cd bf       	out	0x3d, r28	; 61
    1338:	cf 91       	pop	r28
    133a:	df 91       	pop	r29
    133c:	08 95       	ret

0000133e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    133e:	df 93       	push	r29
    1340:	cf 93       	push	r28
    1342:	cd b7       	in	r28, 0x3d	; 61
    1344:	de b7       	in	r29, 0x3e	; 62
    1346:	2e 97       	sbiw	r28, 0x0e	; 14
    1348:	0f b6       	in	r0, 0x3f	; 63
    134a:	f8 94       	cli
    134c:	de bf       	out	0x3e, r29	; 62
    134e:	0f be       	out	0x3f, r0	; 63
    1350:	cd bf       	out	0x3d, r28	; 61
    1352:	98 87       	std	Y+8, r25	; 0x08
    1354:	8f 83       	std	Y+7, r24	; 0x07
    1356:	7a 87       	std	Y+10, r23	; 0x0a
    1358:	69 87       	std	Y+9, r22	; 0x09
    135a:	5c 87       	std	Y+12, r21	; 0x0c
    135c:	4b 87       	std	Y+11, r20	; 0x0b
    135e:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1360:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1362:	0f b6       	in	r0, 0x3f	; 63
    1364:	f8 94       	cli
    1366:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1368:	ef 81       	ldd	r30, Y+7	; 0x07
    136a:	f8 85       	ldd	r31, Y+8	; 0x08
    136c:	82 8d       	ldd	r24, Z+26	; 0x1a
    136e:	88 23       	and	r24, r24
    1370:	09 f4       	brne	.+2      	; 0x1374 <xQueueGenericReceive+0x36>
    1372:	3f c0       	rjmp	.+126    	; 0x13f2 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1374:	ef 81       	ldd	r30, Y+7	; 0x07
    1376:	f8 85       	ldd	r31, Y+8	; 0x08
    1378:	86 81       	ldd	r24, Z+6	; 0x06
    137a:	97 81       	ldd	r25, Z+7	; 0x07
    137c:	9a 83       	std	Y+2, r25	; 0x02
    137e:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1380:	8f 81       	ldd	r24, Y+7	; 0x07
    1382:	98 85       	ldd	r25, Y+8	; 0x08
    1384:	29 85       	ldd	r18, Y+9	; 0x09
    1386:	3a 85       	ldd	r19, Y+10	; 0x0a
    1388:	b9 01       	movw	r22, r18
    138a:	0e 94 84 0b 	call	0x1708	; 0x1708 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    138e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1390:	88 23       	and	r24, r24
    1392:	b1 f4       	brne	.+44     	; 0x13c0 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1394:	ef 81       	ldd	r30, Y+7	; 0x07
    1396:	f8 85       	ldd	r31, Y+8	; 0x08
    1398:	82 8d       	ldd	r24, Z+26	; 0x1a
    139a:	81 50       	subi	r24, 0x01	; 1
    139c:	ef 81       	ldd	r30, Y+7	; 0x07
    139e:	f8 85       	ldd	r31, Y+8	; 0x08
    13a0:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13a2:	ef 81       	ldd	r30, Y+7	; 0x07
    13a4:	f8 85       	ldd	r31, Y+8	; 0x08
    13a6:	80 85       	ldd	r24, Z+8	; 0x08
    13a8:	88 23       	and	r24, r24
    13aa:	f1 f0       	breq	.+60     	; 0x13e8 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    13ac:	8f 81       	ldd	r24, Y+7	; 0x07
    13ae:	98 85       	ldd	r25, Y+8	; 0x08
    13b0:	08 96       	adiw	r24, 0x08	; 8
    13b2:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskRemoveFromEventList>
    13b6:	81 30       	cpi	r24, 0x01	; 1
    13b8:	b9 f4       	brne	.+46     	; 0x13e8 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    13ba:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortYield>
    13be:	14 c0       	rjmp	.+40     	; 0x13e8 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    13c0:	ef 81       	ldd	r30, Y+7	; 0x07
    13c2:	f8 85       	ldd	r31, Y+8	; 0x08
    13c4:	89 81       	ldd	r24, Y+1	; 0x01
    13c6:	9a 81       	ldd	r25, Y+2	; 0x02
    13c8:	97 83       	std	Z+7, r25	; 0x07
    13ca:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13cc:	ef 81       	ldd	r30, Y+7	; 0x07
    13ce:	f8 85       	ldd	r31, Y+8	; 0x08
    13d0:	81 89       	ldd	r24, Z+17	; 0x11
    13d2:	88 23       	and	r24, r24
    13d4:	49 f0       	breq	.+18     	; 0x13e8 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13d6:	8f 81       	ldd	r24, Y+7	; 0x07
    13d8:	98 85       	ldd	r25, Y+8	; 0x08
    13da:	41 96       	adiw	r24, 0x11	; 17
    13dc:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskRemoveFromEventList>
    13e0:	88 23       	and	r24, r24
    13e2:	11 f0       	breq	.+4      	; 0x13e8 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    13e4:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    13e8:	0f 90       	pop	r0
    13ea:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    13ec:	81 e0       	ldi	r24, 0x01	; 1
    13ee:	8e 87       	std	Y+14, r24	; 0x0e
    13f0:	5c c0       	rjmp	.+184    	; 0x14aa <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    13f2:	8b 85       	ldd	r24, Y+11	; 0x0b
    13f4:	9c 85       	ldd	r25, Y+12	; 0x0c
    13f6:	00 97       	sbiw	r24, 0x00	; 0
    13f8:	21 f4       	brne	.+8      	; 0x1402 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    13fa:	0f 90       	pop	r0
    13fc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    13fe:	1e 86       	std	Y+14, r1	; 0x0e
    1400:	54 c0       	rjmp	.+168    	; 0x14aa <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1402:	8b 81       	ldd	r24, Y+3	; 0x03
    1404:	88 23       	and	r24, r24
    1406:	31 f4       	brne	.+12     	; 0x1414 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1408:	ce 01       	movw	r24, r28
    140a:	04 96       	adiw	r24, 0x04	; 4
    140c:	0e 94 c9 13 	call	0x2792	; 0x2792 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1410:	81 e0       	ldi	r24, 0x01	; 1
    1412:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1414:	0f 90       	pop	r0
    1416:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1418:	0e 94 07 11 	call	0x220e	; 0x220e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    141c:	0f b6       	in	r0, 0x3f	; 63
    141e:	f8 94       	cli
    1420:	0f 92       	push	r0
    1422:	ef 81       	ldd	r30, Y+7	; 0x07
    1424:	f8 85       	ldd	r31, Y+8	; 0x08
    1426:	85 8d       	ldd	r24, Z+29	; 0x1d
    1428:	8f 3f       	cpi	r24, 0xFF	; 255
    142a:	19 f4       	brne	.+6      	; 0x1432 <xQueueGenericReceive+0xf4>
    142c:	ef 81       	ldd	r30, Y+7	; 0x07
    142e:	f8 85       	ldd	r31, Y+8	; 0x08
    1430:	15 8e       	std	Z+29, r1	; 0x1d
    1432:	ef 81       	ldd	r30, Y+7	; 0x07
    1434:	f8 85       	ldd	r31, Y+8	; 0x08
    1436:	86 8d       	ldd	r24, Z+30	; 0x1e
    1438:	8f 3f       	cpi	r24, 0xFF	; 255
    143a:	19 f4       	brne	.+6      	; 0x1442 <xQueueGenericReceive+0x104>
    143c:	ef 81       	ldd	r30, Y+7	; 0x07
    143e:	f8 85       	ldd	r31, Y+8	; 0x08
    1440:	16 8e       	std	Z+30, r1	; 0x1e
    1442:	0f 90       	pop	r0
    1444:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1446:	ce 01       	movw	r24, r28
    1448:	04 96       	adiw	r24, 0x04	; 4
    144a:	9e 01       	movw	r18, r28
    144c:	25 5f       	subi	r18, 0xF5	; 245
    144e:	3f 4f       	sbci	r19, 0xFF	; 255
    1450:	b9 01       	movw	r22, r18
    1452:	0e 94 e2 13 	call	0x27c4	; 0x27c4 <xTaskCheckForTimeOut>
    1456:	88 23       	and	r24, r24
    1458:	09 f5       	brne	.+66     	; 0x149c <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    145a:	8f 81       	ldd	r24, Y+7	; 0x07
    145c:	98 85       	ldd	r25, Y+8	; 0x08
    145e:	0e 94 20 0c 	call	0x1840	; 0x1840 <prvIsQueueEmpty>
    1462:	88 23       	and	r24, r24
    1464:	a1 f0       	breq	.+40     	; 0x148e <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1466:	8f 81       	ldd	r24, Y+7	; 0x07
    1468:	98 85       	ldd	r25, Y+8	; 0x08
    146a:	41 96       	adiw	r24, 0x11	; 17
    146c:	2b 85       	ldd	r18, Y+11	; 0x0b
    146e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1470:	b9 01       	movw	r22, r18
    1472:	0e 94 18 13 	call	0x2630	; 0x2630 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1476:	8f 81       	ldd	r24, Y+7	; 0x07
    1478:	98 85       	ldd	r25, Y+8	; 0x08
    147a:	0e 94 cc 0b 	call	0x1798	; 0x1798 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    147e:	0e 94 13 11 	call	0x2226	; 0x2226 <xTaskResumeAll>
    1482:	88 23       	and	r24, r24
    1484:	09 f0       	breq	.+2      	; 0x1488 <xQueueGenericReceive+0x14a>
    1486:	6d cf       	rjmp	.-294    	; 0x1362 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1488:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortYield>
    148c:	6a cf       	rjmp	.-300    	; 0x1362 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    148e:	8f 81       	ldd	r24, Y+7	; 0x07
    1490:	98 85       	ldd	r25, Y+8	; 0x08
    1492:	0e 94 cc 0b 	call	0x1798	; 0x1798 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1496:	0e 94 13 11 	call	0x2226	; 0x2226 <xTaskResumeAll>
    149a:	63 cf       	rjmp	.-314    	; 0x1362 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    149c:	8f 81       	ldd	r24, Y+7	; 0x07
    149e:	98 85       	ldd	r25, Y+8	; 0x08
    14a0:	0e 94 cc 0b 	call	0x1798	; 0x1798 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    14a4:	0e 94 13 11 	call	0x2226	; 0x2226 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    14a8:	1e 86       	std	Y+14, r1	; 0x0e
    14aa:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    14ac:	2e 96       	adiw	r28, 0x0e	; 14
    14ae:	0f b6       	in	r0, 0x3f	; 63
    14b0:	f8 94       	cli
    14b2:	de bf       	out	0x3e, r29	; 62
    14b4:	0f be       	out	0x3f, r0	; 63
    14b6:	cd bf       	out	0x3d, r28	; 61
    14b8:	cf 91       	pop	r28
    14ba:	df 91       	pop	r29
    14bc:	08 95       	ret

000014be <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    14be:	df 93       	push	r29
    14c0:	cf 93       	push	r28
    14c2:	cd b7       	in	r28, 0x3d	; 61
    14c4:	de b7       	in	r29, 0x3e	; 62
    14c6:	28 97       	sbiw	r28, 0x08	; 8
    14c8:	0f b6       	in	r0, 0x3f	; 63
    14ca:	f8 94       	cli
    14cc:	de bf       	out	0x3e, r29	; 62
    14ce:	0f be       	out	0x3f, r0	; 63
    14d0:	cd bf       	out	0x3d, r28	; 61
    14d2:	9c 83       	std	Y+4, r25	; 0x04
    14d4:	8b 83       	std	Y+3, r24	; 0x03
    14d6:	7e 83       	std	Y+6, r23	; 0x06
    14d8:	6d 83       	std	Y+5, r22	; 0x05
    14da:	58 87       	std	Y+8, r21	; 0x08
    14dc:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    14de:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    14e0:	eb 81       	ldd	r30, Y+3	; 0x03
    14e2:	fc 81       	ldd	r31, Y+4	; 0x04
    14e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    14e6:	88 23       	and	r24, r24
    14e8:	71 f1       	breq	.+92     	; 0x1546 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    14ea:	8b 81       	ldd	r24, Y+3	; 0x03
    14ec:	9c 81       	ldd	r25, Y+4	; 0x04
    14ee:	2d 81       	ldd	r18, Y+5	; 0x05
    14f0:	3e 81       	ldd	r19, Y+6	; 0x06
    14f2:	b9 01       	movw	r22, r18
    14f4:	0e 94 84 0b 	call	0x1708	; 0x1708 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    14f8:	eb 81       	ldd	r30, Y+3	; 0x03
    14fa:	fc 81       	ldd	r31, Y+4	; 0x04
    14fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    14fe:	81 50       	subi	r24, 0x01	; 1
    1500:	eb 81       	ldd	r30, Y+3	; 0x03
    1502:	fc 81       	ldd	r31, Y+4	; 0x04
    1504:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1506:	eb 81       	ldd	r30, Y+3	; 0x03
    1508:	fc 81       	ldd	r31, Y+4	; 0x04
    150a:	85 8d       	ldd	r24, Z+29	; 0x1d
    150c:	8f 3f       	cpi	r24, 0xFF	; 255
    150e:	89 f4       	brne	.+34     	; 0x1532 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1510:	eb 81       	ldd	r30, Y+3	; 0x03
    1512:	fc 81       	ldd	r31, Y+4	; 0x04
    1514:	80 85       	ldd	r24, Z+8	; 0x08
    1516:	88 23       	and	r24, r24
    1518:	99 f0       	breq	.+38     	; 0x1540 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    151a:	8b 81       	ldd	r24, Y+3	; 0x03
    151c:	9c 81       	ldd	r25, Y+4	; 0x04
    151e:	08 96       	adiw	r24, 0x08	; 8
    1520:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskRemoveFromEventList>
    1524:	88 23       	and	r24, r24
    1526:	61 f0       	breq	.+24     	; 0x1540 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1528:	ef 81       	ldd	r30, Y+7	; 0x07
    152a:	f8 85       	ldd	r31, Y+8	; 0x08
    152c:	81 e0       	ldi	r24, 0x01	; 1
    152e:	80 83       	st	Z, r24
    1530:	07 c0       	rjmp	.+14     	; 0x1540 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1532:	eb 81       	ldd	r30, Y+3	; 0x03
    1534:	fc 81       	ldd	r31, Y+4	; 0x04
    1536:	85 8d       	ldd	r24, Z+29	; 0x1d
    1538:	8f 5f       	subi	r24, 0xFF	; 255
    153a:	eb 81       	ldd	r30, Y+3	; 0x03
    153c:	fc 81       	ldd	r31, Y+4	; 0x04
    153e:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1540:	81 e0       	ldi	r24, 0x01	; 1
    1542:	8a 83       	std	Y+2, r24	; 0x02
    1544:	01 c0       	rjmp	.+2      	; 0x1548 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1546:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1548:	8a 81       	ldd	r24, Y+2	; 0x02
}
    154a:	28 96       	adiw	r28, 0x08	; 8
    154c:	0f b6       	in	r0, 0x3f	; 63
    154e:	f8 94       	cli
    1550:	de bf       	out	0x3e, r29	; 62
    1552:	0f be       	out	0x3f, r0	; 63
    1554:	cd bf       	out	0x3d, r28	; 61
    1556:	cf 91       	pop	r28
    1558:	df 91       	pop	r29
    155a:	08 95       	ret

0000155c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    155c:	df 93       	push	r29
    155e:	cf 93       	push	r28
    1560:	00 d0       	rcall	.+0      	; 0x1562 <uxQueueMessagesWaiting+0x6>
    1562:	0f 92       	push	r0
    1564:	cd b7       	in	r28, 0x3d	; 61
    1566:	de b7       	in	r29, 0x3e	; 62
    1568:	9b 83       	std	Y+3, r25	; 0x03
    156a:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    156c:	0f b6       	in	r0, 0x3f	; 63
    156e:	f8 94       	cli
    1570:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1572:	ea 81       	ldd	r30, Y+2	; 0x02
    1574:	fb 81       	ldd	r31, Y+3	; 0x03
    1576:	82 8d       	ldd	r24, Z+26	; 0x1a
    1578:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    157a:	0f 90       	pop	r0
    157c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    157e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1580:	0f 90       	pop	r0
    1582:	0f 90       	pop	r0
    1584:	0f 90       	pop	r0
    1586:	cf 91       	pop	r28
    1588:	df 91       	pop	r29
    158a:	08 95       	ret

0000158c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    158c:	df 93       	push	r29
    158e:	cf 93       	push	r28
    1590:	00 d0       	rcall	.+0      	; 0x1592 <uxQueueMessagesWaitingFromISR+0x6>
    1592:	0f 92       	push	r0
    1594:	cd b7       	in	r28, 0x3d	; 61
    1596:	de b7       	in	r29, 0x3e	; 62
    1598:	9b 83       	std	Y+3, r25	; 0x03
    159a:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    159c:	ea 81       	ldd	r30, Y+2	; 0x02
    159e:	fb 81       	ldd	r31, Y+3	; 0x03
    15a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    15a2:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    15a4:	89 81       	ldd	r24, Y+1	; 0x01
}
    15a6:	0f 90       	pop	r0
    15a8:	0f 90       	pop	r0
    15aa:	0f 90       	pop	r0
    15ac:	cf 91       	pop	r28
    15ae:	df 91       	pop	r29
    15b0:	08 95       	ret

000015b2 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    15b2:	df 93       	push	r29
    15b4:	cf 93       	push	r28
    15b6:	00 d0       	rcall	.+0      	; 0x15b8 <vQueueDelete+0x6>
    15b8:	cd b7       	in	r28, 0x3d	; 61
    15ba:	de b7       	in	r29, 0x3e	; 62
    15bc:	9a 83       	std	Y+2, r25	; 0x02
    15be:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    15c0:	e9 81       	ldd	r30, Y+1	; 0x01
    15c2:	fa 81       	ldd	r31, Y+2	; 0x02
    15c4:	80 81       	ld	r24, Z
    15c6:	91 81       	ldd	r25, Z+1	; 0x01
    15c8:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <vPortFree>
	vPortFree( pxQueue );
    15cc:	89 81       	ldd	r24, Y+1	; 0x01
    15ce:	9a 81       	ldd	r25, Y+2	; 0x02
    15d0:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <vPortFree>
}
    15d4:	0f 90       	pop	r0
    15d6:	0f 90       	pop	r0
    15d8:	cf 91       	pop	r28
    15da:	df 91       	pop	r29
    15dc:	08 95       	ret

000015de <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    15de:	df 93       	push	r29
    15e0:	cf 93       	push	r28
    15e2:	00 d0       	rcall	.+0      	; 0x15e4 <prvCopyDataToQueue+0x6>
    15e4:	00 d0       	rcall	.+0      	; 0x15e6 <prvCopyDataToQueue+0x8>
    15e6:	0f 92       	push	r0
    15e8:	cd b7       	in	r28, 0x3d	; 61
    15ea:	de b7       	in	r29, 0x3e	; 62
    15ec:	9a 83       	std	Y+2, r25	; 0x02
    15ee:	89 83       	std	Y+1, r24	; 0x01
    15f0:	7c 83       	std	Y+4, r23	; 0x04
    15f2:	6b 83       	std	Y+3, r22	; 0x03
    15f4:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    15f6:	e9 81       	ldd	r30, Y+1	; 0x01
    15f8:	fa 81       	ldd	r31, Y+2	; 0x02
    15fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    15fc:	88 23       	and	r24, r24
    15fe:	09 f4       	brne	.+2      	; 0x1602 <prvCopyDataToQueue+0x24>
    1600:	74 c0       	rjmp	.+232    	; 0x16ea <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1602:	8d 81       	ldd	r24, Y+5	; 0x05
    1604:	88 23       	and	r24, r24
    1606:	99 f5       	brne	.+102    	; 0x166e <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1608:	e9 81       	ldd	r30, Y+1	; 0x01
    160a:	fa 81       	ldd	r31, Y+2	; 0x02
    160c:	64 81       	ldd	r22, Z+4	; 0x04
    160e:	75 81       	ldd	r23, Z+5	; 0x05
    1610:	e9 81       	ldd	r30, Y+1	; 0x01
    1612:	fa 81       	ldd	r31, Y+2	; 0x02
    1614:	84 8d       	ldd	r24, Z+28	; 0x1c
    1616:	48 2f       	mov	r20, r24
    1618:	50 e0       	ldi	r21, 0x00	; 0
    161a:	2b 81       	ldd	r18, Y+3	; 0x03
    161c:	3c 81       	ldd	r19, Y+4	; 0x04
    161e:	cb 01       	movw	r24, r22
    1620:	b9 01       	movw	r22, r18
    1622:	0e 94 64 16 	call	0x2cc8	; 0x2cc8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1626:	e9 81       	ldd	r30, Y+1	; 0x01
    1628:	fa 81       	ldd	r31, Y+2	; 0x02
    162a:	24 81       	ldd	r18, Z+4	; 0x04
    162c:	35 81       	ldd	r19, Z+5	; 0x05
    162e:	e9 81       	ldd	r30, Y+1	; 0x01
    1630:	fa 81       	ldd	r31, Y+2	; 0x02
    1632:	84 8d       	ldd	r24, Z+28	; 0x1c
    1634:	88 2f       	mov	r24, r24
    1636:	90 e0       	ldi	r25, 0x00	; 0
    1638:	82 0f       	add	r24, r18
    163a:	93 1f       	adc	r25, r19
    163c:	e9 81       	ldd	r30, Y+1	; 0x01
    163e:	fa 81       	ldd	r31, Y+2	; 0x02
    1640:	95 83       	std	Z+5, r25	; 0x05
    1642:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1644:	e9 81       	ldd	r30, Y+1	; 0x01
    1646:	fa 81       	ldd	r31, Y+2	; 0x02
    1648:	24 81       	ldd	r18, Z+4	; 0x04
    164a:	35 81       	ldd	r19, Z+5	; 0x05
    164c:	e9 81       	ldd	r30, Y+1	; 0x01
    164e:	fa 81       	ldd	r31, Y+2	; 0x02
    1650:	82 81       	ldd	r24, Z+2	; 0x02
    1652:	93 81       	ldd	r25, Z+3	; 0x03
    1654:	28 17       	cp	r18, r24
    1656:	39 07       	cpc	r19, r25
    1658:	08 f4       	brcc	.+2      	; 0x165c <prvCopyDataToQueue+0x7e>
    165a:	47 c0       	rjmp	.+142    	; 0x16ea <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    165c:	e9 81       	ldd	r30, Y+1	; 0x01
    165e:	fa 81       	ldd	r31, Y+2	; 0x02
    1660:	80 81       	ld	r24, Z
    1662:	91 81       	ldd	r25, Z+1	; 0x01
    1664:	e9 81       	ldd	r30, Y+1	; 0x01
    1666:	fa 81       	ldd	r31, Y+2	; 0x02
    1668:	95 83       	std	Z+5, r25	; 0x05
    166a:	84 83       	std	Z+4, r24	; 0x04
    166c:	3e c0       	rjmp	.+124    	; 0x16ea <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    166e:	e9 81       	ldd	r30, Y+1	; 0x01
    1670:	fa 81       	ldd	r31, Y+2	; 0x02
    1672:	66 81       	ldd	r22, Z+6	; 0x06
    1674:	77 81       	ldd	r23, Z+7	; 0x07
    1676:	e9 81       	ldd	r30, Y+1	; 0x01
    1678:	fa 81       	ldd	r31, Y+2	; 0x02
    167a:	84 8d       	ldd	r24, Z+28	; 0x1c
    167c:	48 2f       	mov	r20, r24
    167e:	50 e0       	ldi	r21, 0x00	; 0
    1680:	2b 81       	ldd	r18, Y+3	; 0x03
    1682:	3c 81       	ldd	r19, Y+4	; 0x04
    1684:	cb 01       	movw	r24, r22
    1686:	b9 01       	movw	r22, r18
    1688:	0e 94 64 16 	call	0x2cc8	; 0x2cc8 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    168c:	e9 81       	ldd	r30, Y+1	; 0x01
    168e:	fa 81       	ldd	r31, Y+2	; 0x02
    1690:	26 81       	ldd	r18, Z+6	; 0x06
    1692:	37 81       	ldd	r19, Z+7	; 0x07
    1694:	e9 81       	ldd	r30, Y+1	; 0x01
    1696:	fa 81       	ldd	r31, Y+2	; 0x02
    1698:	84 8d       	ldd	r24, Z+28	; 0x1c
    169a:	88 2f       	mov	r24, r24
    169c:	90 e0       	ldi	r25, 0x00	; 0
    169e:	90 95       	com	r25
    16a0:	81 95       	neg	r24
    16a2:	9f 4f       	sbci	r25, 0xFF	; 255
    16a4:	82 0f       	add	r24, r18
    16a6:	93 1f       	adc	r25, r19
    16a8:	e9 81       	ldd	r30, Y+1	; 0x01
    16aa:	fa 81       	ldd	r31, Y+2	; 0x02
    16ac:	97 83       	std	Z+7, r25	; 0x07
    16ae:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    16b0:	e9 81       	ldd	r30, Y+1	; 0x01
    16b2:	fa 81       	ldd	r31, Y+2	; 0x02
    16b4:	26 81       	ldd	r18, Z+6	; 0x06
    16b6:	37 81       	ldd	r19, Z+7	; 0x07
    16b8:	e9 81       	ldd	r30, Y+1	; 0x01
    16ba:	fa 81       	ldd	r31, Y+2	; 0x02
    16bc:	80 81       	ld	r24, Z
    16be:	91 81       	ldd	r25, Z+1	; 0x01
    16c0:	28 17       	cp	r18, r24
    16c2:	39 07       	cpc	r19, r25
    16c4:	90 f4       	brcc	.+36     	; 0x16ea <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    16c6:	e9 81       	ldd	r30, Y+1	; 0x01
    16c8:	fa 81       	ldd	r31, Y+2	; 0x02
    16ca:	22 81       	ldd	r18, Z+2	; 0x02
    16cc:	33 81       	ldd	r19, Z+3	; 0x03
    16ce:	e9 81       	ldd	r30, Y+1	; 0x01
    16d0:	fa 81       	ldd	r31, Y+2	; 0x02
    16d2:	84 8d       	ldd	r24, Z+28	; 0x1c
    16d4:	88 2f       	mov	r24, r24
    16d6:	90 e0       	ldi	r25, 0x00	; 0
    16d8:	90 95       	com	r25
    16da:	81 95       	neg	r24
    16dc:	9f 4f       	sbci	r25, 0xFF	; 255
    16de:	82 0f       	add	r24, r18
    16e0:	93 1f       	adc	r25, r19
    16e2:	e9 81       	ldd	r30, Y+1	; 0x01
    16e4:	fa 81       	ldd	r31, Y+2	; 0x02
    16e6:	97 83       	std	Z+7, r25	; 0x07
    16e8:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    16ea:	e9 81       	ldd	r30, Y+1	; 0x01
    16ec:	fa 81       	ldd	r31, Y+2	; 0x02
    16ee:	82 8d       	ldd	r24, Z+26	; 0x1a
    16f0:	8f 5f       	subi	r24, 0xFF	; 255
    16f2:	e9 81       	ldd	r30, Y+1	; 0x01
    16f4:	fa 81       	ldd	r31, Y+2	; 0x02
    16f6:	82 8f       	std	Z+26, r24	; 0x1a
}
    16f8:	0f 90       	pop	r0
    16fa:	0f 90       	pop	r0
    16fc:	0f 90       	pop	r0
    16fe:	0f 90       	pop	r0
    1700:	0f 90       	pop	r0
    1702:	cf 91       	pop	r28
    1704:	df 91       	pop	r29
    1706:	08 95       	ret

00001708 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1708:	df 93       	push	r29
    170a:	cf 93       	push	r28
    170c:	00 d0       	rcall	.+0      	; 0x170e <prvCopyDataFromQueue+0x6>
    170e:	00 d0       	rcall	.+0      	; 0x1710 <prvCopyDataFromQueue+0x8>
    1710:	cd b7       	in	r28, 0x3d	; 61
    1712:	de b7       	in	r29, 0x3e	; 62
    1714:	9a 83       	std	Y+2, r25	; 0x02
    1716:	89 83       	std	Y+1, r24	; 0x01
    1718:	7c 83       	std	Y+4, r23	; 0x04
    171a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    171c:	e9 81       	ldd	r30, Y+1	; 0x01
    171e:	fa 81       	ldd	r31, Y+2	; 0x02
    1720:	80 81       	ld	r24, Z
    1722:	91 81       	ldd	r25, Z+1	; 0x01
    1724:	00 97       	sbiw	r24, 0x00	; 0
    1726:	89 f1       	breq	.+98     	; 0x178a <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1728:	e9 81       	ldd	r30, Y+1	; 0x01
    172a:	fa 81       	ldd	r31, Y+2	; 0x02
    172c:	26 81       	ldd	r18, Z+6	; 0x06
    172e:	37 81       	ldd	r19, Z+7	; 0x07
    1730:	e9 81       	ldd	r30, Y+1	; 0x01
    1732:	fa 81       	ldd	r31, Y+2	; 0x02
    1734:	84 8d       	ldd	r24, Z+28	; 0x1c
    1736:	88 2f       	mov	r24, r24
    1738:	90 e0       	ldi	r25, 0x00	; 0
    173a:	82 0f       	add	r24, r18
    173c:	93 1f       	adc	r25, r19
    173e:	e9 81       	ldd	r30, Y+1	; 0x01
    1740:	fa 81       	ldd	r31, Y+2	; 0x02
    1742:	97 83       	std	Z+7, r25	; 0x07
    1744:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1746:	e9 81       	ldd	r30, Y+1	; 0x01
    1748:	fa 81       	ldd	r31, Y+2	; 0x02
    174a:	26 81       	ldd	r18, Z+6	; 0x06
    174c:	37 81       	ldd	r19, Z+7	; 0x07
    174e:	e9 81       	ldd	r30, Y+1	; 0x01
    1750:	fa 81       	ldd	r31, Y+2	; 0x02
    1752:	82 81       	ldd	r24, Z+2	; 0x02
    1754:	93 81       	ldd	r25, Z+3	; 0x03
    1756:	28 17       	cp	r18, r24
    1758:	39 07       	cpc	r19, r25
    175a:	40 f0       	brcs	.+16     	; 0x176c <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    175c:	e9 81       	ldd	r30, Y+1	; 0x01
    175e:	fa 81       	ldd	r31, Y+2	; 0x02
    1760:	80 81       	ld	r24, Z
    1762:	91 81       	ldd	r25, Z+1	; 0x01
    1764:	e9 81       	ldd	r30, Y+1	; 0x01
    1766:	fa 81       	ldd	r31, Y+2	; 0x02
    1768:	97 83       	std	Z+7, r25	; 0x07
    176a:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    176c:	e9 81       	ldd	r30, Y+1	; 0x01
    176e:	fa 81       	ldd	r31, Y+2	; 0x02
    1770:	46 81       	ldd	r20, Z+6	; 0x06
    1772:	57 81       	ldd	r21, Z+7	; 0x07
    1774:	e9 81       	ldd	r30, Y+1	; 0x01
    1776:	fa 81       	ldd	r31, Y+2	; 0x02
    1778:	84 8d       	ldd	r24, Z+28	; 0x1c
    177a:	28 2f       	mov	r18, r24
    177c:	30 e0       	ldi	r19, 0x00	; 0
    177e:	8b 81       	ldd	r24, Y+3	; 0x03
    1780:	9c 81       	ldd	r25, Y+4	; 0x04
    1782:	ba 01       	movw	r22, r20
    1784:	a9 01       	movw	r20, r18
    1786:	0e 94 64 16 	call	0x2cc8	; 0x2cc8 <memcpy>
	}
}
    178a:	0f 90       	pop	r0
    178c:	0f 90       	pop	r0
    178e:	0f 90       	pop	r0
    1790:	0f 90       	pop	r0
    1792:	cf 91       	pop	r28
    1794:	df 91       	pop	r29
    1796:	08 95       	ret

00001798 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1798:	df 93       	push	r29
    179a:	cf 93       	push	r28
    179c:	00 d0       	rcall	.+0      	; 0x179e <prvUnlockQueue+0x6>
    179e:	cd b7       	in	r28, 0x3d	; 61
    17a0:	de b7       	in	r29, 0x3e	; 62
    17a2:	9a 83       	std	Y+2, r25	; 0x02
    17a4:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    17a6:	0f b6       	in	r0, 0x3f	; 63
    17a8:	f8 94       	cli
    17aa:	0f 92       	push	r0
    17ac:	15 c0       	rjmp	.+42     	; 0x17d8 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17ae:	e9 81       	ldd	r30, Y+1	; 0x01
    17b0:	fa 81       	ldd	r31, Y+2	; 0x02
    17b2:	81 89       	ldd	r24, Z+17	; 0x11
    17b4:	88 23       	and	r24, r24
    17b6:	a9 f0       	breq	.+42     	; 0x17e2 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17b8:	89 81       	ldd	r24, Y+1	; 0x01
    17ba:	9a 81       	ldd	r25, Y+2	; 0x02
    17bc:	41 96       	adiw	r24, 0x11	; 17
    17be:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskRemoveFromEventList>
    17c2:	88 23       	and	r24, r24
    17c4:	11 f0       	breq	.+4      	; 0x17ca <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    17c6:	0e 94 49 14 	call	0x2892	; 0x2892 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    17ca:	e9 81       	ldd	r30, Y+1	; 0x01
    17cc:	fa 81       	ldd	r31, Y+2	; 0x02
    17ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    17d0:	81 50       	subi	r24, 0x01	; 1
    17d2:	e9 81       	ldd	r30, Y+1	; 0x01
    17d4:	fa 81       	ldd	r31, Y+2	; 0x02
    17d6:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    17d8:	e9 81       	ldd	r30, Y+1	; 0x01
    17da:	fa 81       	ldd	r31, Y+2	; 0x02
    17dc:	86 8d       	ldd	r24, Z+30	; 0x1e
    17de:	18 16       	cp	r1, r24
    17e0:	34 f3       	brlt	.-52     	; 0x17ae <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    17e2:	e9 81       	ldd	r30, Y+1	; 0x01
    17e4:	fa 81       	ldd	r31, Y+2	; 0x02
    17e6:	8f ef       	ldi	r24, 0xFF	; 255
    17e8:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    17ea:	0f 90       	pop	r0
    17ec:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    17ee:	0f b6       	in	r0, 0x3f	; 63
    17f0:	f8 94       	cli
    17f2:	0f 92       	push	r0
    17f4:	15 c0       	rjmp	.+42     	; 0x1820 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17f6:	e9 81       	ldd	r30, Y+1	; 0x01
    17f8:	fa 81       	ldd	r31, Y+2	; 0x02
    17fa:	80 85       	ldd	r24, Z+8	; 0x08
    17fc:	88 23       	and	r24, r24
    17fe:	a9 f0       	breq	.+42     	; 0x182a <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1800:	89 81       	ldd	r24, Y+1	; 0x01
    1802:	9a 81       	ldd	r25, Y+2	; 0x02
    1804:	08 96       	adiw	r24, 0x08	; 8
    1806:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskRemoveFromEventList>
    180a:	88 23       	and	r24, r24
    180c:	11 f0       	breq	.+4      	; 0x1812 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    180e:	0e 94 49 14 	call	0x2892	; 0x2892 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1812:	e9 81       	ldd	r30, Y+1	; 0x01
    1814:	fa 81       	ldd	r31, Y+2	; 0x02
    1816:	85 8d       	ldd	r24, Z+29	; 0x1d
    1818:	81 50       	subi	r24, 0x01	; 1
    181a:	e9 81       	ldd	r30, Y+1	; 0x01
    181c:	fa 81       	ldd	r31, Y+2	; 0x02
    181e:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1820:	e9 81       	ldd	r30, Y+1	; 0x01
    1822:	fa 81       	ldd	r31, Y+2	; 0x02
    1824:	85 8d       	ldd	r24, Z+29	; 0x1d
    1826:	18 16       	cp	r1, r24
    1828:	34 f3       	brlt	.-52     	; 0x17f6 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    182a:	e9 81       	ldd	r30, Y+1	; 0x01
    182c:	fa 81       	ldd	r31, Y+2	; 0x02
    182e:	8f ef       	ldi	r24, 0xFF	; 255
    1830:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1832:	0f 90       	pop	r0
    1834:	0f be       	out	0x3f, r0	; 63
}
    1836:	0f 90       	pop	r0
    1838:	0f 90       	pop	r0
    183a:	cf 91       	pop	r28
    183c:	df 91       	pop	r29
    183e:	08 95       	ret

00001840 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    1840:	df 93       	push	r29
    1842:	cf 93       	push	r28
    1844:	00 d0       	rcall	.+0      	; 0x1846 <prvIsQueueEmpty+0x6>
    1846:	0f 92       	push	r0
    1848:	cd b7       	in	r28, 0x3d	; 61
    184a:	de b7       	in	r29, 0x3e	; 62
    184c:	9b 83       	std	Y+3, r25	; 0x03
    184e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1850:	0f b6       	in	r0, 0x3f	; 63
    1852:	f8 94       	cli
    1854:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1856:	ea 81       	ldd	r30, Y+2	; 0x02
    1858:	fb 81       	ldd	r31, Y+3	; 0x03
    185a:	82 8d       	ldd	r24, Z+26	; 0x1a
    185c:	19 82       	std	Y+1, r1	; 0x01
    185e:	88 23       	and	r24, r24
    1860:	11 f4       	brne	.+4      	; 0x1866 <prvIsQueueEmpty+0x26>
    1862:	81 e0       	ldi	r24, 0x01	; 1
    1864:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1866:	0f 90       	pop	r0
    1868:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    186a:	89 81       	ldd	r24, Y+1	; 0x01
}
    186c:	0f 90       	pop	r0
    186e:	0f 90       	pop	r0
    1870:	0f 90       	pop	r0
    1872:	cf 91       	pop	r28
    1874:	df 91       	pop	r29
    1876:	08 95       	ret

00001878 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1878:	df 93       	push	r29
    187a:	cf 93       	push	r28
    187c:	00 d0       	rcall	.+0      	; 0x187e <xQueueIsQueueEmptyFromISR+0x6>
    187e:	0f 92       	push	r0
    1880:	cd b7       	in	r28, 0x3d	; 61
    1882:	de b7       	in	r29, 0x3e	; 62
    1884:	9b 83       	std	Y+3, r25	; 0x03
    1886:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1888:	ea 81       	ldd	r30, Y+2	; 0x02
    188a:	fb 81       	ldd	r31, Y+3	; 0x03
    188c:	82 8d       	ldd	r24, Z+26	; 0x1a
    188e:	19 82       	std	Y+1, r1	; 0x01
    1890:	88 23       	and	r24, r24
    1892:	11 f4       	brne	.+4      	; 0x1898 <xQueueIsQueueEmptyFromISR+0x20>
    1894:	81 e0       	ldi	r24, 0x01	; 1
    1896:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1898:	89 81       	ldd	r24, Y+1	; 0x01
}
    189a:	0f 90       	pop	r0
    189c:	0f 90       	pop	r0
    189e:	0f 90       	pop	r0
    18a0:	cf 91       	pop	r28
    18a2:	df 91       	pop	r29
    18a4:	08 95       	ret

000018a6 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    18a6:	df 93       	push	r29
    18a8:	cf 93       	push	r28
    18aa:	00 d0       	rcall	.+0      	; 0x18ac <prvIsQueueFull+0x6>
    18ac:	0f 92       	push	r0
    18ae:	cd b7       	in	r28, 0x3d	; 61
    18b0:	de b7       	in	r29, 0x3e	; 62
    18b2:	9b 83       	std	Y+3, r25	; 0x03
    18b4:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    18b6:	0f b6       	in	r0, 0x3f	; 63
    18b8:	f8 94       	cli
    18ba:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    18bc:	ea 81       	ldd	r30, Y+2	; 0x02
    18be:	fb 81       	ldd	r31, Y+3	; 0x03
    18c0:	92 8d       	ldd	r25, Z+26	; 0x1a
    18c2:	ea 81       	ldd	r30, Y+2	; 0x02
    18c4:	fb 81       	ldd	r31, Y+3	; 0x03
    18c6:	83 8d       	ldd	r24, Z+27	; 0x1b
    18c8:	19 82       	std	Y+1, r1	; 0x01
    18ca:	98 17       	cp	r25, r24
    18cc:	11 f4       	brne	.+4      	; 0x18d2 <prvIsQueueFull+0x2c>
    18ce:	81 e0       	ldi	r24, 0x01	; 1
    18d0:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    18d2:	0f 90       	pop	r0
    18d4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    18d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    18d8:	0f 90       	pop	r0
    18da:	0f 90       	pop	r0
    18dc:	0f 90       	pop	r0
    18de:	cf 91       	pop	r28
    18e0:	df 91       	pop	r29
    18e2:	08 95       	ret

000018e4 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    18e4:	df 93       	push	r29
    18e6:	cf 93       	push	r28
    18e8:	00 d0       	rcall	.+0      	; 0x18ea <xQueueIsQueueFullFromISR+0x6>
    18ea:	0f 92       	push	r0
    18ec:	cd b7       	in	r28, 0x3d	; 61
    18ee:	de b7       	in	r29, 0x3e	; 62
    18f0:	9b 83       	std	Y+3, r25	; 0x03
    18f2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    18f4:	ea 81       	ldd	r30, Y+2	; 0x02
    18f6:	fb 81       	ldd	r31, Y+3	; 0x03
    18f8:	92 8d       	ldd	r25, Z+26	; 0x1a
    18fa:	ea 81       	ldd	r30, Y+2	; 0x02
    18fc:	fb 81       	ldd	r31, Y+3	; 0x03
    18fe:	83 8d       	ldd	r24, Z+27	; 0x1b
    1900:	19 82       	std	Y+1, r1	; 0x01
    1902:	98 17       	cp	r25, r24
    1904:	11 f4       	brne	.+4      	; 0x190a <xQueueIsQueueFullFromISR+0x26>
    1906:	81 e0       	ldi	r24, 0x01	; 1
    1908:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    190a:	89 81       	ldd	r24, Y+1	; 0x01
}
    190c:	0f 90       	pop	r0
    190e:	0f 90       	pop	r0
    1910:	0f 90       	pop	r0
    1912:	cf 91       	pop	r28
    1914:	df 91       	pop	r29
    1916:	08 95       	ret

00001918 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1918:	af 92       	push	r10
    191a:	bf 92       	push	r11
    191c:	cf 92       	push	r12
    191e:	df 92       	push	r13
    1920:	ef 92       	push	r14
    1922:	ff 92       	push	r15
    1924:	0f 93       	push	r16
    1926:	1f 93       	push	r17
    1928:	df 93       	push	r29
    192a:	cf 93       	push	r28
    192c:	cd b7       	in	r28, 0x3d	; 61
    192e:	de b7       	in	r29, 0x3e	; 62
    1930:	64 97       	sbiw	r28, 0x14	; 20
    1932:	0f b6       	in	r0, 0x3f	; 63
    1934:	f8 94       	cli
    1936:	de bf       	out	0x3e, r29	; 62
    1938:	0f be       	out	0x3f, r0	; 63
    193a:	cd bf       	out	0x3d, r28	; 61
    193c:	9f 83       	std	Y+7, r25	; 0x07
    193e:	8e 83       	std	Y+6, r24	; 0x06
    1940:	79 87       	std	Y+9, r23	; 0x09
    1942:	68 87       	std	Y+8, r22	; 0x08
    1944:	5b 87       	std	Y+11, r21	; 0x0b
    1946:	4a 87       	std	Y+10, r20	; 0x0a
    1948:	3d 87       	std	Y+13, r19	; 0x0d
    194a:	2c 87       	std	Y+12, r18	; 0x0c
    194c:	0e 87       	std	Y+14, r16	; 0x0e
    194e:	f8 8a       	std	Y+16, r15	; 0x10
    1950:	ef 86       	std	Y+15, r14	; 0x0f
    1952:	da 8a       	std	Y+18, r13	; 0x12
    1954:	c9 8a       	std	Y+17, r12	; 0x11
    1956:	bc 8a       	std	Y+20, r11	; 0x14
    1958:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    195a:	8a 85       	ldd	r24, Y+10	; 0x0a
    195c:	9b 85       	ldd	r25, Y+11	; 0x0b
    195e:	29 89       	ldd	r18, Y+17	; 0x11
    1960:	3a 89       	ldd	r19, Y+18	; 0x12
    1962:	b9 01       	movw	r22, r18
    1964:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <prvAllocateTCBAndStack>
    1968:	9c 83       	std	Y+4, r25	; 0x04
    196a:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    196c:	8b 81       	ldd	r24, Y+3	; 0x03
    196e:	9c 81       	ldd	r25, Y+4	; 0x04
    1970:	00 97       	sbiw	r24, 0x00	; 0
    1972:	09 f4       	brne	.+2      	; 0x1976 <xTaskGenericCreate+0x5e>
    1974:	99 c0       	rjmp	.+306    	; 0x1aa8 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1976:	eb 81       	ldd	r30, Y+3	; 0x03
    1978:	fc 81       	ldd	r31, Y+4	; 0x04
    197a:	27 89       	ldd	r18, Z+23	; 0x17
    197c:	30 8d       	ldd	r19, Z+24	; 0x18
    197e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1980:	9b 85       	ldd	r25, Y+11	; 0x0b
    1982:	01 97       	sbiw	r24, 0x01	; 1
    1984:	82 0f       	add	r24, r18
    1986:	93 1f       	adc	r25, r19
    1988:	9a 83       	std	Y+2, r25	; 0x02
    198a:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    198c:	8b 81       	ldd	r24, Y+3	; 0x03
    198e:	9c 81       	ldd	r25, Y+4	; 0x04
    1990:	28 85       	ldd	r18, Y+8	; 0x08
    1992:	39 85       	ldd	r19, Y+9	; 0x09
    1994:	eb 89       	ldd	r30, Y+19	; 0x13
    1996:	fc 89       	ldd	r31, Y+20	; 0x14
    1998:	aa 85       	ldd	r26, Y+10	; 0x0a
    199a:	bb 85       	ldd	r27, Y+11	; 0x0b
    199c:	b9 01       	movw	r22, r18
    199e:	4e 85       	ldd	r20, Y+14	; 0x0e
    19a0:	9f 01       	movw	r18, r30
    19a2:	8d 01       	movw	r16, r26
    19a4:	0e 94 5d 14 	call	0x28ba	; 0x28ba <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    19a8:	89 81       	ldd	r24, Y+1	; 0x01
    19aa:	9a 81       	ldd	r25, Y+2	; 0x02
    19ac:	2e 81       	ldd	r18, Y+6	; 0x06
    19ae:	3f 81       	ldd	r19, Y+7	; 0x07
    19b0:	4c 85       	ldd	r20, Y+12	; 0x0c
    19b2:	5d 85       	ldd	r21, Y+13	; 0x0d
    19b4:	b9 01       	movw	r22, r18
    19b6:	0e 94 39 05 	call	0xa72	; 0xa72 <pxPortInitialiseStack>
    19ba:	eb 81       	ldd	r30, Y+3	; 0x03
    19bc:	fc 81       	ldd	r31, Y+4	; 0x04
    19be:	91 83       	std	Z+1, r25	; 0x01
    19c0:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    19c2:	8f 85       	ldd	r24, Y+15	; 0x0f
    19c4:	98 89       	ldd	r25, Y+16	; 0x10
    19c6:	00 97       	sbiw	r24, 0x00	; 0
    19c8:	31 f0       	breq	.+12     	; 0x19d6 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    19ca:	ef 85       	ldd	r30, Y+15	; 0x0f
    19cc:	f8 89       	ldd	r31, Y+16	; 0x10
    19ce:	8b 81       	ldd	r24, Y+3	; 0x03
    19d0:	9c 81       	ldd	r25, Y+4	; 0x04
    19d2:	91 83       	std	Z+1, r25	; 0x01
    19d4:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    19d6:	0f b6       	in	r0, 0x3f	; 63
    19d8:	f8 94       	cli
    19da:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    19dc:	80 91 01 03 	lds	r24, 0x0301
    19e0:	8f 5f       	subi	r24, 0xFF	; 255
    19e2:	80 93 01 03 	sts	0x0301, r24
			if( pxCurrentTCB == NULL )
    19e6:	80 91 fc 02 	lds	r24, 0x02FC
    19ea:	90 91 fd 02 	lds	r25, 0x02FD
    19ee:	00 97       	sbiw	r24, 0x00	; 0
    19f0:	69 f4       	brne	.+26     	; 0x1a0c <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    19f2:	8b 81       	ldd	r24, Y+3	; 0x03
    19f4:	9c 81       	ldd	r25, Y+4	; 0x04
    19f6:	90 93 fd 02 	sts	0x02FD, r25
    19fa:	80 93 fc 02 	sts	0x02FC, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    19fe:	80 91 01 03 	lds	r24, 0x0301
    1a02:	81 30       	cpi	r24, 0x01	; 1
    1a04:	a9 f4       	brne	.+42     	; 0x1a30 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1a06:	0e 94 b4 14 	call	0x2968	; 0x2968 <prvInitialiseTaskLists>
    1a0a:	12 c0       	rjmp	.+36     	; 0x1a30 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1a0c:	80 91 06 03 	lds	r24, 0x0306
    1a10:	88 23       	and	r24, r24
    1a12:	71 f4       	brne	.+28     	; 0x1a30 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1a14:	e0 91 fc 02 	lds	r30, 0x02FC
    1a18:	f0 91 fd 02 	lds	r31, 0x02FD
    1a1c:	96 89       	ldd	r25, Z+22	; 0x16
    1a1e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a20:	89 17       	cp	r24, r25
    1a22:	30 f0       	brcs	.+12     	; 0x1a30 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    1a24:	8b 81       	ldd	r24, Y+3	; 0x03
    1a26:	9c 81       	ldd	r25, Y+4	; 0x04
    1a28:	90 93 fd 02 	sts	0x02FD, r25
    1a2c:	80 93 fc 02 	sts	0x02FC, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1a30:	eb 81       	ldd	r30, Y+3	; 0x03
    1a32:	fc 81       	ldd	r31, Y+4	; 0x04
    1a34:	96 89       	ldd	r25, Z+22	; 0x16
    1a36:	80 91 04 03 	lds	r24, 0x0304
    1a3a:	89 17       	cp	r24, r25
    1a3c:	28 f4       	brcc	.+10     	; 0x1a48 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1a3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a40:	fc 81       	ldd	r31, Y+4	; 0x04
    1a42:	86 89       	ldd	r24, Z+22	; 0x16
    1a44:	80 93 04 03 	sts	0x0304, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1a48:	80 91 0b 03 	lds	r24, 0x030B
    1a4c:	8f 5f       	subi	r24, 0xFF	; 255
    1a4e:	80 93 0b 03 	sts	0x030B, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1a52:	eb 81       	ldd	r30, Y+3	; 0x03
    1a54:	fc 81       	ldd	r31, Y+4	; 0x04
    1a56:	96 89       	ldd	r25, Z+22	; 0x16
    1a58:	80 91 05 03 	lds	r24, 0x0305
    1a5c:	89 17       	cp	r24, r25
    1a5e:	28 f4       	brcc	.+10     	; 0x1a6a <xTaskGenericCreate+0x152>
    1a60:	eb 81       	ldd	r30, Y+3	; 0x03
    1a62:	fc 81       	ldd	r31, Y+4	; 0x04
    1a64:	86 89       	ldd	r24, Z+22	; 0x16
    1a66:	80 93 05 03 	sts	0x0305, r24
    1a6a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a6c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a6e:	86 89       	ldd	r24, Z+22	; 0x16
    1a70:	28 2f       	mov	r18, r24
    1a72:	30 e0       	ldi	r19, 0x00	; 0
    1a74:	c9 01       	movw	r24, r18
    1a76:	88 0f       	add	r24, r24
    1a78:	99 1f       	adc	r25, r25
    1a7a:	88 0f       	add	r24, r24
    1a7c:	99 1f       	adc	r25, r25
    1a7e:	88 0f       	add	r24, r24
    1a80:	99 1f       	adc	r25, r25
    1a82:	82 0f       	add	r24, r18
    1a84:	93 1f       	adc	r25, r19
    1a86:	ac 01       	movw	r20, r24
    1a88:	44 5f       	subi	r20, 0xF4	; 244
    1a8a:	5c 4f       	sbci	r21, 0xFC	; 252
    1a8c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a8e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a90:	9c 01       	movw	r18, r24
    1a92:	2e 5f       	subi	r18, 0xFE	; 254
    1a94:	3f 4f       	sbci	r19, 0xFF	; 255
    1a96:	ca 01       	movw	r24, r20
    1a98:	b9 01       	movw	r22, r18
    1a9a:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>

			xReturn = pdPASS;
    1a9e:	81 e0       	ldi	r24, 0x01	; 1
    1aa0:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1aa2:	0f 90       	pop	r0
    1aa4:	0f be       	out	0x3f, r0	; 63
    1aa6:	02 c0       	rjmp	.+4      	; 0x1aac <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1aa8:	8f ef       	ldi	r24, 0xFF	; 255
    1aaa:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1aac:	8d 81       	ldd	r24, Y+5	; 0x05
    1aae:	81 30       	cpi	r24, 0x01	; 1
    1ab0:	71 f4       	brne	.+28     	; 0x1ace <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    1ab2:	80 91 06 03 	lds	r24, 0x0306
    1ab6:	88 23       	and	r24, r24
    1ab8:	51 f0       	breq	.+20     	; 0x1ace <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1aba:	e0 91 fc 02 	lds	r30, 0x02FC
    1abe:	f0 91 fd 02 	lds	r31, 0x02FD
    1ac2:	96 89       	ldd	r25, Z+22	; 0x16
    1ac4:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ac6:	98 17       	cp	r25, r24
    1ac8:	10 f4       	brcc	.+4      	; 0x1ace <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1aca:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortYield>
			}
		}
	}

	return xReturn;
    1ace:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1ad0:	64 96       	adiw	r28, 0x14	; 20
    1ad2:	0f b6       	in	r0, 0x3f	; 63
    1ad4:	f8 94       	cli
    1ad6:	de bf       	out	0x3e, r29	; 62
    1ad8:	0f be       	out	0x3f, r0	; 63
    1ada:	cd bf       	out	0x3d, r28	; 61
    1adc:	cf 91       	pop	r28
    1ade:	df 91       	pop	r29
    1ae0:	1f 91       	pop	r17
    1ae2:	0f 91       	pop	r16
    1ae4:	ff 90       	pop	r15
    1ae6:	ef 90       	pop	r14
    1ae8:	df 90       	pop	r13
    1aea:	cf 90       	pop	r12
    1aec:	bf 90       	pop	r11
    1aee:	af 90       	pop	r10
    1af0:	08 95       	ret

00001af2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1af2:	df 93       	push	r29
    1af4:	cf 93       	push	r28
    1af6:	00 d0       	rcall	.+0      	; 0x1af8 <vTaskDelete+0x6>
    1af8:	00 d0       	rcall	.+0      	; 0x1afa <vTaskDelete+0x8>
    1afa:	00 d0       	rcall	.+0      	; 0x1afc <vTaskDelete+0xa>
    1afc:	cd b7       	in	r28, 0x3d	; 61
    1afe:	de b7       	in	r29, 0x3e	; 62
    1b00:	9c 83       	std	Y+4, r25	; 0x04
    1b02:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1b04:	0f b6       	in	r0, 0x3f	; 63
    1b06:	f8 94       	cli
    1b08:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1b0a:	20 91 fc 02 	lds	r18, 0x02FC
    1b0e:	30 91 fd 02 	lds	r19, 0x02FD
    1b12:	8b 81       	ldd	r24, Y+3	; 0x03
    1b14:	9c 81       	ldd	r25, Y+4	; 0x04
    1b16:	82 17       	cp	r24, r18
    1b18:	93 07       	cpc	r25, r19
    1b1a:	11 f4       	brne	.+4      	; 0x1b20 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1b1c:	1c 82       	std	Y+4, r1	; 0x04
    1b1e:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1b20:	8b 81       	ldd	r24, Y+3	; 0x03
    1b22:	9c 81       	ldd	r25, Y+4	; 0x04
    1b24:	00 97       	sbiw	r24, 0x00	; 0
    1b26:	39 f4       	brne	.+14     	; 0x1b36 <vTaskDelete+0x44>
    1b28:	80 91 fc 02 	lds	r24, 0x02FC
    1b2c:	90 91 fd 02 	lds	r25, 0x02FD
    1b30:	9e 83       	std	Y+6, r25	; 0x06
    1b32:	8d 83       	std	Y+5, r24	; 0x05
    1b34:	04 c0       	rjmp	.+8      	; 0x1b3e <vTaskDelete+0x4c>
    1b36:	8b 81       	ldd	r24, Y+3	; 0x03
    1b38:	9c 81       	ldd	r25, Y+4	; 0x04
    1b3a:	9e 83       	std	Y+6, r25	; 0x06
    1b3c:	8d 83       	std	Y+5, r24	; 0x05
    1b3e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b40:	9e 81       	ldd	r25, Y+6	; 0x06
    1b42:	9a 83       	std	Y+2, r25	; 0x02
    1b44:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1b46:	89 81       	ldd	r24, Y+1	; 0x01
    1b48:	9a 81       	ldd	r25, Y+2	; 0x02
    1b4a:	02 96       	adiw	r24, 0x02	; 2
    1b4c:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1b50:	e9 81       	ldd	r30, Y+1	; 0x01
    1b52:	fa 81       	ldd	r31, Y+2	; 0x02
    1b54:	84 89       	ldd	r24, Z+20	; 0x14
    1b56:	95 89       	ldd	r25, Z+21	; 0x15
    1b58:	00 97       	sbiw	r24, 0x00	; 0
    1b5a:	29 f0       	breq	.+10     	; 0x1b66 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1b5c:	89 81       	ldd	r24, Y+1	; 0x01
    1b5e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b60:	0c 96       	adiw	r24, 0x0c	; 12
    1b62:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1b66:	89 81       	ldd	r24, Y+1	; 0x01
    1b68:	9a 81       	ldd	r25, Y+2	; 0x02
    1b6a:	9c 01       	movw	r18, r24
    1b6c:	2e 5f       	subi	r18, 0xFE	; 254
    1b6e:	3f 4f       	sbci	r19, 0xFF	; 255
    1b70:	86 e4       	ldi	r24, 0x46	; 70
    1b72:	93 e0       	ldi	r25, 0x03	; 3
    1b74:	b9 01       	movw	r22, r18
    1b76:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1b7a:	80 91 fe 02 	lds	r24, 0x02FE
    1b7e:	8f 5f       	subi	r24, 0xFF	; 255
    1b80:	80 93 fe 02 	sts	0x02FE, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1b84:	80 91 0b 03 	lds	r24, 0x030B
    1b88:	8f 5f       	subi	r24, 0xFF	; 255
    1b8a:	80 93 0b 03 	sts	0x030B, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1b8e:	0f 90       	pop	r0
    1b90:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1b92:	80 91 06 03 	lds	r24, 0x0306
    1b96:	88 23       	and	r24, r24
    1b98:	31 f0       	breq	.+12     	; 0x1ba6 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1b9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b9e:	00 97       	sbiw	r24, 0x00	; 0
    1ba0:	11 f4       	brne	.+4      	; 0x1ba6 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1ba2:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortYield>
			}
		}
	}
    1ba6:	26 96       	adiw	r28, 0x06	; 6
    1ba8:	0f b6       	in	r0, 0x3f	; 63
    1baa:	f8 94       	cli
    1bac:	de bf       	out	0x3e, r29	; 62
    1bae:	0f be       	out	0x3f, r0	; 63
    1bb0:	cd bf       	out	0x3d, r28	; 61
    1bb2:	cf 91       	pop	r28
    1bb4:	df 91       	pop	r29
    1bb6:	08 95       	ret

00001bb8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1bb8:	df 93       	push	r29
    1bba:	cf 93       	push	r28
    1bbc:	cd b7       	in	r28, 0x3d	; 61
    1bbe:	de b7       	in	r29, 0x3e	; 62
    1bc0:	28 97       	sbiw	r28, 0x08	; 8
    1bc2:	0f b6       	in	r0, 0x3f	; 63
    1bc4:	f8 94       	cli
    1bc6:	de bf       	out	0x3e, r29	; 62
    1bc8:	0f be       	out	0x3f, r0	; 63
    1bca:	cd bf       	out	0x3d, r28	; 61
    1bcc:	9e 83       	std	Y+6, r25	; 0x06
    1bce:	8d 83       	std	Y+5, r24	; 0x05
    1bd0:	78 87       	std	Y+8, r23	; 0x08
    1bd2:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1bd4:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1bd6:	0e 94 07 11 	call	0x220e	; 0x220e <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1bda:	ed 81       	ldd	r30, Y+5	; 0x05
    1bdc:	fe 81       	ldd	r31, Y+6	; 0x06
    1bde:	20 81       	ld	r18, Z
    1be0:	31 81       	ldd	r19, Z+1	; 0x01
    1be2:	8f 81       	ldd	r24, Y+7	; 0x07
    1be4:	98 85       	ldd	r25, Y+8	; 0x08
    1be6:	82 0f       	add	r24, r18
    1be8:	93 1f       	adc	r25, r19
    1bea:	9c 83       	std	Y+4, r25	; 0x04
    1bec:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    1bee:	ed 81       	ldd	r30, Y+5	; 0x05
    1bf0:	fe 81       	ldd	r31, Y+6	; 0x06
    1bf2:	20 81       	ld	r18, Z
    1bf4:	31 81       	ldd	r19, Z+1	; 0x01
    1bf6:	80 91 02 03 	lds	r24, 0x0302
    1bfa:	90 91 03 03 	lds	r25, 0x0303
    1bfe:	82 17       	cp	r24, r18
    1c00:	93 07       	cpc	r25, r19
    1c02:	a8 f4       	brcc	.+42     	; 0x1c2e <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1c04:	ed 81       	ldd	r30, Y+5	; 0x05
    1c06:	fe 81       	ldd	r31, Y+6	; 0x06
    1c08:	20 81       	ld	r18, Z
    1c0a:	31 81       	ldd	r19, Z+1	; 0x01
    1c0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c0e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c10:	82 17       	cp	r24, r18
    1c12:	93 07       	cpc	r25, r19
    1c14:	00 f5       	brcc	.+64     	; 0x1c56 <vTaskDelayUntil+0x9e>
    1c16:	20 91 02 03 	lds	r18, 0x0302
    1c1a:	30 91 03 03 	lds	r19, 0x0303
    1c1e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c20:	9c 81       	ldd	r25, Y+4	; 0x04
    1c22:	28 17       	cp	r18, r24
    1c24:	39 07       	cpc	r19, r25
    1c26:	b8 f4       	brcc	.+46     	; 0x1c56 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1c28:	81 e0       	ldi	r24, 0x01	; 1
    1c2a:	89 83       	std	Y+1, r24	; 0x01
    1c2c:	14 c0       	rjmp	.+40     	; 0x1c56 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1c2e:	ed 81       	ldd	r30, Y+5	; 0x05
    1c30:	fe 81       	ldd	r31, Y+6	; 0x06
    1c32:	20 81       	ld	r18, Z
    1c34:	31 81       	ldd	r19, Z+1	; 0x01
    1c36:	8b 81       	ldd	r24, Y+3	; 0x03
    1c38:	9c 81       	ldd	r25, Y+4	; 0x04
    1c3a:	82 17       	cp	r24, r18
    1c3c:	93 07       	cpc	r25, r19
    1c3e:	48 f0       	brcs	.+18     	; 0x1c52 <vTaskDelayUntil+0x9a>
    1c40:	20 91 02 03 	lds	r18, 0x0302
    1c44:	30 91 03 03 	lds	r19, 0x0303
    1c48:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c4c:	28 17       	cp	r18, r24
    1c4e:	39 07       	cpc	r19, r25
    1c50:	10 f4       	brcc	.+4      	; 0x1c56 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1c52:	81 e0       	ldi	r24, 0x01	; 1
    1c54:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1c56:	ed 81       	ldd	r30, Y+5	; 0x05
    1c58:	fe 81       	ldd	r31, Y+6	; 0x06
    1c5a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c5c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c5e:	91 83       	std	Z+1, r25	; 0x01
    1c60:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1c62:	89 81       	ldd	r24, Y+1	; 0x01
    1c64:	88 23       	and	r24, r24
    1c66:	59 f0       	breq	.+22     	; 0x1c7e <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c68:	80 91 fc 02 	lds	r24, 0x02FC
    1c6c:	90 91 fd 02 	lds	r25, 0x02FD
    1c70:	02 96       	adiw	r24, 0x02	; 2
    1c72:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1c76:	8b 81       	ldd	r24, Y+3	; 0x03
    1c78:	9c 81       	ldd	r25, Y+4	; 0x04
    1c7a:	0e 94 33 15 	call	0x2a66	; 0x2a66 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1c7e:	0e 94 13 11 	call	0x2226	; 0x2226 <xTaskResumeAll>
    1c82:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1c84:	8a 81       	ldd	r24, Y+2	; 0x02
    1c86:	88 23       	and	r24, r24
    1c88:	11 f4       	brne	.+4      	; 0x1c8e <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    1c8a:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortYield>
		}
	}
    1c8e:	28 96       	adiw	r28, 0x08	; 8
    1c90:	0f b6       	in	r0, 0x3f	; 63
    1c92:	f8 94       	cli
    1c94:	de bf       	out	0x3e, r29	; 62
    1c96:	0f be       	out	0x3f, r0	; 63
    1c98:	cd bf       	out	0x3d, r28	; 61
    1c9a:	cf 91       	pop	r28
    1c9c:	df 91       	pop	r29
    1c9e:	08 95       	ret

00001ca0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1ca0:	df 93       	push	r29
    1ca2:	cf 93       	push	r28
    1ca4:	00 d0       	rcall	.+0      	; 0x1ca6 <vTaskDelay+0x6>
    1ca6:	00 d0       	rcall	.+0      	; 0x1ca8 <vTaskDelay+0x8>
    1ca8:	0f 92       	push	r0
    1caa:	cd b7       	in	r28, 0x3d	; 61
    1cac:	de b7       	in	r29, 0x3e	; 62
    1cae:	9d 83       	std	Y+5, r25	; 0x05
    1cb0:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1cb2:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1cb4:	8c 81       	ldd	r24, Y+4	; 0x04
    1cb6:	9d 81       	ldd	r25, Y+5	; 0x05
    1cb8:	00 97       	sbiw	r24, 0x00	; 0
    1cba:	d1 f0       	breq	.+52     	; 0x1cf0 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    1cbc:	0e 94 07 11 	call	0x220e	; 0x220e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1cc0:	20 91 02 03 	lds	r18, 0x0302
    1cc4:	30 91 03 03 	lds	r19, 0x0303
    1cc8:	8c 81       	ldd	r24, Y+4	; 0x04
    1cca:	9d 81       	ldd	r25, Y+5	; 0x05
    1ccc:	82 0f       	add	r24, r18
    1cce:	93 1f       	adc	r25, r19
    1cd0:	9b 83       	std	Y+3, r25	; 0x03
    1cd2:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1cd4:	80 91 fc 02 	lds	r24, 0x02FC
    1cd8:	90 91 fd 02 	lds	r25, 0x02FD
    1cdc:	02 96       	adiw	r24, 0x02	; 2
    1cde:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1ce2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ce4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ce6:	0e 94 33 15 	call	0x2a66	; 0x2a66 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1cea:	0e 94 13 11 	call	0x2226	; 0x2226 <xTaskResumeAll>
    1cee:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1cf0:	89 81       	ldd	r24, Y+1	; 0x01
    1cf2:	88 23       	and	r24, r24
    1cf4:	11 f4       	brne	.+4      	; 0x1cfa <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    1cf6:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortYield>
		}
	}
    1cfa:	0f 90       	pop	r0
    1cfc:	0f 90       	pop	r0
    1cfe:	0f 90       	pop	r0
    1d00:	0f 90       	pop	r0
    1d02:	0f 90       	pop	r0
    1d04:	cf 91       	pop	r28
    1d06:	df 91       	pop	r29
    1d08:	08 95       	ret

00001d0a <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
    1d0a:	df 93       	push	r29
    1d0c:	cf 93       	push	r28
    1d0e:	cd b7       	in	r28, 0x3d	; 61
    1d10:	de b7       	in	r29, 0x3e	; 62
    1d12:	27 97       	sbiw	r28, 0x07	; 7
    1d14:	0f b6       	in	r0, 0x3f	; 63
    1d16:	f8 94       	cli
    1d18:	de bf       	out	0x3e, r29	; 62
    1d1a:	0f be       	out	0x3f, r0	; 63
    1d1c:	cd bf       	out	0x3d, r28	; 61
    1d1e:	9d 83       	std	Y+5, r25	; 0x05
    1d20:	8c 83       	std	Y+4, r24	; 0x04
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
    1d22:	0f b6       	in	r0, 0x3f	; 63
    1d24:	f8 94       	cli
    1d26:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1d28:	8c 81       	ldd	r24, Y+4	; 0x04
    1d2a:	9d 81       	ldd	r25, Y+5	; 0x05
    1d2c:	00 97       	sbiw	r24, 0x00	; 0
    1d2e:	39 f4       	brne	.+14     	; 0x1d3e <uxTaskPriorityGet+0x34>
    1d30:	80 91 fc 02 	lds	r24, 0x02FC
    1d34:	90 91 fd 02 	lds	r25, 0x02FD
    1d38:	9f 83       	std	Y+7, r25	; 0x07
    1d3a:	8e 83       	std	Y+6, r24	; 0x06
    1d3c:	04 c0       	rjmp	.+8      	; 0x1d46 <uxTaskPriorityGet+0x3c>
    1d3e:	8c 81       	ldd	r24, Y+4	; 0x04
    1d40:	9d 81       	ldd	r25, Y+5	; 0x05
    1d42:	9f 83       	std	Y+7, r25	; 0x07
    1d44:	8e 83       	std	Y+6, r24	; 0x06
    1d46:	8e 81       	ldd	r24, Y+6	; 0x06
    1d48:	9f 81       	ldd	r25, Y+7	; 0x07
    1d4a:	9b 83       	std	Y+3, r25	; 0x03
    1d4c:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    1d4e:	ea 81       	ldd	r30, Y+2	; 0x02
    1d50:	fb 81       	ldd	r31, Y+3	; 0x03
    1d52:	86 89       	ldd	r24, Z+22	; 0x16
    1d54:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    1d56:	0f 90       	pop	r0
    1d58:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    1d5a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    1d5c:	27 96       	adiw	r28, 0x07	; 7
    1d5e:	0f b6       	in	r0, 0x3f	; 63
    1d60:	f8 94       	cli
    1d62:	de bf       	out	0x3e, r29	; 62
    1d64:	0f be       	out	0x3f, r0	; 63
    1d66:	cd bf       	out	0x3d, r28	; 61
    1d68:	cf 91       	pop	r28
    1d6a:	df 91       	pop	r29
    1d6c:	08 95       	ret

00001d6e <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    1d6e:	df 93       	push	r29
    1d70:	cf 93       	push	r28
    1d72:	cd b7       	in	r28, 0x3d	; 61
    1d74:	de b7       	in	r29, 0x3e	; 62
    1d76:	29 97       	sbiw	r28, 0x09	; 9
    1d78:	0f b6       	in	r0, 0x3f	; 63
    1d7a:	f8 94       	cli
    1d7c:	de bf       	out	0x3e, r29	; 62
    1d7e:	0f be       	out	0x3f, r0	; 63
    1d80:	cd bf       	out	0x3d, r28	; 61
    1d82:	9e 83       	std	Y+6, r25	; 0x06
    1d84:	8d 83       	std	Y+5, r24	; 0x05
    1d86:	6f 83       	std	Y+7, r22	; 0x07
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority;
	portBASE_TYPE xYieldRequired = pdFALSE;
    1d88:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= configMAX_PRIORITIES )
    1d8a:	8f 81       	ldd	r24, Y+7	; 0x07
    1d8c:	83 30       	cpi	r24, 0x03	; 3
    1d8e:	10 f0       	brcs	.+4      	; 0x1d94 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    1d90:	82 e0       	ldi	r24, 0x02	; 2
    1d92:	8f 83       	std	Y+7, r24	; 0x07
		}

		taskENTER_CRITICAL();
    1d94:	0f b6       	in	r0, 0x3f	; 63
    1d96:	f8 94       	cli
    1d98:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    1d9a:	20 91 fc 02 	lds	r18, 0x02FC
    1d9e:	30 91 fd 02 	lds	r19, 0x02FD
    1da2:	8d 81       	ldd	r24, Y+5	; 0x05
    1da4:	9e 81       	ldd	r25, Y+6	; 0x06
    1da6:	82 17       	cp	r24, r18
    1da8:	93 07       	cpc	r25, r19
    1daa:	11 f4       	brne	.+4      	; 0x1db0 <vTaskPrioritySet+0x42>
			{
				pxTask = NULL;
    1dac:	1e 82       	std	Y+6, r1	; 0x06
    1dae:	1d 82       	std	Y+5, r1	; 0x05
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1db0:	8d 81       	ldd	r24, Y+5	; 0x05
    1db2:	9e 81       	ldd	r25, Y+6	; 0x06
    1db4:	00 97       	sbiw	r24, 0x00	; 0
    1db6:	39 f4       	brne	.+14     	; 0x1dc6 <vTaskPrioritySet+0x58>
    1db8:	80 91 fc 02 	lds	r24, 0x02FC
    1dbc:	90 91 fd 02 	lds	r25, 0x02FD
    1dc0:	99 87       	std	Y+9, r25	; 0x09
    1dc2:	88 87       	std	Y+8, r24	; 0x08
    1dc4:	04 c0       	rjmp	.+8      	; 0x1dce <vTaskPrioritySet+0x60>
    1dc6:	8d 81       	ldd	r24, Y+5	; 0x05
    1dc8:	9e 81       	ldd	r25, Y+6	; 0x06
    1dca:	99 87       	std	Y+9, r25	; 0x09
    1dcc:	88 87       	std	Y+8, r24	; 0x08
    1dce:	88 85       	ldd	r24, Y+8	; 0x08
    1dd0:	99 85       	ldd	r25, Y+9	; 0x09
    1dd2:	9c 83       	std	Y+4, r25	; 0x04
    1dd4:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
    1dd6:	eb 81       	ldd	r30, Y+3	; 0x03
    1dd8:	fc 81       	ldd	r31, Y+4	; 0x04
    1dda:	86 89       	ldd	r24, Z+22	; 0x16
    1ddc:	8a 83       	std	Y+2, r24	; 0x02
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    1dde:	9a 81       	ldd	r25, Y+2	; 0x02
    1de0:	8f 81       	ldd	r24, Y+7	; 0x07
    1de2:	98 17       	cp	r25, r24
    1de4:	09 f4       	brne	.+2      	; 0x1de8 <vTaskPrioritySet+0x7a>
    1de6:	65 c0       	rjmp	.+202    	; 0x1eb2 <vTaskPrioritySet+0x144>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    1de8:	9f 81       	ldd	r25, Y+7	; 0x07
    1dea:	8a 81       	ldd	r24, Y+2	; 0x02
    1dec:	89 17       	cp	r24, r25
    1dee:	38 f4       	brcc	.+14     	; 0x1dfe <vTaskPrioritySet+0x90>
				{
					if( pxTask != NULL )
    1df0:	8d 81       	ldd	r24, Y+5	; 0x05
    1df2:	9e 81       	ldd	r25, Y+6	; 0x06
    1df4:	00 97       	sbiw	r24, 0x00	; 0
    1df6:	49 f0       	breq	.+18     	; 0x1e0a <vTaskPrioritySet+0x9c>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    1df8:	81 e0       	ldi	r24, 0x01	; 1
    1dfa:	89 83       	std	Y+1, r24	; 0x01
    1dfc:	06 c0       	rjmp	.+12     	; 0x1e0a <vTaskPrioritySet+0x9c>
					}
				}
				else if( pxTask == NULL )
    1dfe:	8d 81       	ldd	r24, Y+5	; 0x05
    1e00:	9e 81       	ldd	r25, Y+6	; 0x06
    1e02:	00 97       	sbiw	r24, 0x00	; 0
    1e04:	11 f4       	brne	.+4      	; 0x1e0a <vTaskPrioritySet+0x9c>
				{
					/* Setting our own priority down means there may now be another
					task of higher priority that is ready to execute. */
					xYieldRequired = pdTRUE;
    1e06:	81 e0       	ldi	r24, 0x01	; 1
    1e08:	89 83       	std	Y+1, r24	; 0x01
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    1e0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e0e:	8f 81       	ldd	r24, Y+7	; 0x07
    1e10:	86 8b       	std	Z+22, r24	; 0x16
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    1e12:	8f 81       	ldd	r24, Y+7	; 0x07
    1e14:	28 2f       	mov	r18, r24
    1e16:	30 e0       	ldi	r19, 0x00	; 0
    1e18:	83 e0       	ldi	r24, 0x03	; 3
    1e1a:	90 e0       	ldi	r25, 0x00	; 0
    1e1c:	82 1b       	sub	r24, r18
    1e1e:	93 0b       	sbc	r25, r19
    1e20:	eb 81       	ldd	r30, Y+3	; 0x03
    1e22:	fc 81       	ldd	r31, Y+4	; 0x04
    1e24:	95 87       	std	Z+13, r25	; 0x0d
    1e26:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    1e28:	eb 81       	ldd	r30, Y+3	; 0x03
    1e2a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e2c:	42 85       	ldd	r20, Z+10	; 0x0a
    1e2e:	53 85       	ldd	r21, Z+11	; 0x0b
    1e30:	8a 81       	ldd	r24, Y+2	; 0x02
    1e32:	28 2f       	mov	r18, r24
    1e34:	30 e0       	ldi	r19, 0x00	; 0
    1e36:	c9 01       	movw	r24, r18
    1e38:	88 0f       	add	r24, r24
    1e3a:	99 1f       	adc	r25, r25
    1e3c:	88 0f       	add	r24, r24
    1e3e:	99 1f       	adc	r25, r25
    1e40:	88 0f       	add	r24, r24
    1e42:	99 1f       	adc	r25, r25
    1e44:	82 0f       	add	r24, r18
    1e46:	93 1f       	adc	r25, r19
    1e48:	84 5f       	subi	r24, 0xF4	; 244
    1e4a:	9c 4f       	sbci	r25, 0xFC	; 252
    1e4c:	48 17       	cp	r20, r24
    1e4e:	59 07       	cpc	r21, r25
    1e50:	59 f5       	brne	.+86     	; 0x1ea8 <vTaskPrioritySet+0x13a>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    1e52:	8b 81       	ldd	r24, Y+3	; 0x03
    1e54:	9c 81       	ldd	r25, Y+4	; 0x04
    1e56:	02 96       	adiw	r24, 0x02	; 2
    1e58:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1e5c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e5e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e60:	96 89       	ldd	r25, Z+22	; 0x16
    1e62:	80 91 05 03 	lds	r24, 0x0305
    1e66:	89 17       	cp	r24, r25
    1e68:	28 f4       	brcc	.+10     	; 0x1e74 <vTaskPrioritySet+0x106>
    1e6a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e6c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e6e:	86 89       	ldd	r24, Z+22	; 0x16
    1e70:	80 93 05 03 	sts	0x0305, r24
    1e74:	eb 81       	ldd	r30, Y+3	; 0x03
    1e76:	fc 81       	ldd	r31, Y+4	; 0x04
    1e78:	86 89       	ldd	r24, Z+22	; 0x16
    1e7a:	28 2f       	mov	r18, r24
    1e7c:	30 e0       	ldi	r19, 0x00	; 0
    1e7e:	c9 01       	movw	r24, r18
    1e80:	88 0f       	add	r24, r24
    1e82:	99 1f       	adc	r25, r25
    1e84:	88 0f       	add	r24, r24
    1e86:	99 1f       	adc	r25, r25
    1e88:	88 0f       	add	r24, r24
    1e8a:	99 1f       	adc	r25, r25
    1e8c:	82 0f       	add	r24, r18
    1e8e:	93 1f       	adc	r25, r19
    1e90:	ac 01       	movw	r20, r24
    1e92:	44 5f       	subi	r20, 0xF4	; 244
    1e94:	5c 4f       	sbci	r21, 0xFC	; 252
    1e96:	8b 81       	ldd	r24, Y+3	; 0x03
    1e98:	9c 81       	ldd	r25, Y+4	; 0x04
    1e9a:	9c 01       	movw	r18, r24
    1e9c:	2e 5f       	subi	r18, 0xFE	; 254
    1e9e:	3f 4f       	sbci	r19, 0xFF	; 255
    1ea0:	ca 01       	movw	r24, r20
    1ea2:	b9 01       	movw	r22, r18
    1ea4:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
    1ea8:	89 81       	ldd	r24, Y+1	; 0x01
    1eaa:	81 30       	cpi	r24, 0x01	; 1
    1eac:	11 f4       	brne	.+4      	; 0x1eb2 <vTaskPrioritySet+0x144>
				{
					portYIELD_WITHIN_API();
    1eae:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortYield>
				}
			}
		}
		taskEXIT_CRITICAL();
    1eb2:	0f 90       	pop	r0
    1eb4:	0f be       	out	0x3f, r0	; 63
	}
    1eb6:	29 96       	adiw	r28, 0x09	; 9
    1eb8:	0f b6       	in	r0, 0x3f	; 63
    1eba:	f8 94       	cli
    1ebc:	de bf       	out	0x3e, r29	; 62
    1ebe:	0f be       	out	0x3f, r0	; 63
    1ec0:	cd bf       	out	0x3d, r28	; 61
    1ec2:	cf 91       	pop	r28
    1ec4:	df 91       	pop	r29
    1ec6:	08 95       	ret

00001ec8 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    1ec8:	df 93       	push	r29
    1eca:	cf 93       	push	r28
    1ecc:	00 d0       	rcall	.+0      	; 0x1ece <vTaskSuspend+0x6>
    1ece:	00 d0       	rcall	.+0      	; 0x1ed0 <vTaskSuspend+0x8>
    1ed0:	00 d0       	rcall	.+0      	; 0x1ed2 <vTaskSuspend+0xa>
    1ed2:	cd b7       	in	r28, 0x3d	; 61
    1ed4:	de b7       	in	r29, 0x3e	; 62
    1ed6:	9c 83       	std	Y+4, r25	; 0x04
    1ed8:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1eda:	0f b6       	in	r0, 0x3f	; 63
    1edc:	f8 94       	cli
    1ede:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    1ee0:	20 91 fc 02 	lds	r18, 0x02FC
    1ee4:	30 91 fd 02 	lds	r19, 0x02FD
    1ee8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eea:	9c 81       	ldd	r25, Y+4	; 0x04
    1eec:	82 17       	cp	r24, r18
    1eee:	93 07       	cpc	r25, r19
    1ef0:	11 f4       	brne	.+4      	; 0x1ef6 <vTaskSuspend+0x2e>
			{
				pxTaskToSuspend = NULL;
    1ef2:	1c 82       	std	Y+4, r1	; 0x04
    1ef4:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1ef6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef8:	9c 81       	ldd	r25, Y+4	; 0x04
    1efa:	00 97       	sbiw	r24, 0x00	; 0
    1efc:	39 f4       	brne	.+14     	; 0x1f0c <vTaskSuspend+0x44>
    1efe:	80 91 fc 02 	lds	r24, 0x02FC
    1f02:	90 91 fd 02 	lds	r25, 0x02FD
    1f06:	9e 83       	std	Y+6, r25	; 0x06
    1f08:	8d 83       	std	Y+5, r24	; 0x05
    1f0a:	04 c0       	rjmp	.+8      	; 0x1f14 <vTaskSuspend+0x4c>
    1f0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f0e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f10:	9e 83       	std	Y+6, r25	; 0x06
    1f12:	8d 83       	std	Y+5, r24	; 0x05
    1f14:	8d 81       	ldd	r24, Y+5	; 0x05
    1f16:	9e 81       	ldd	r25, Y+6	; 0x06
    1f18:	9a 83       	std	Y+2, r25	; 0x02
    1f1a:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1f1c:	89 81       	ldd	r24, Y+1	; 0x01
    1f1e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f20:	02 96       	adiw	r24, 0x02	; 2
    1f22:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1f26:	e9 81       	ldd	r30, Y+1	; 0x01
    1f28:	fa 81       	ldd	r31, Y+2	; 0x02
    1f2a:	84 89       	ldd	r24, Z+20	; 0x14
    1f2c:	95 89       	ldd	r25, Z+21	; 0x15
    1f2e:	00 97       	sbiw	r24, 0x00	; 0
    1f30:	29 f0       	breq	.+10     	; 0x1f3c <vTaskSuspend+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1f32:	89 81       	ldd	r24, Y+1	; 0x01
    1f34:	9a 81       	ldd	r25, Y+2	; 0x02
    1f36:	0c 96       	adiw	r24, 0x0c	; 12
    1f38:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    1f3c:	89 81       	ldd	r24, Y+1	; 0x01
    1f3e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f40:	9c 01       	movw	r18, r24
    1f42:	2e 5f       	subi	r18, 0xFE	; 254
    1f44:	3f 4f       	sbci	r19, 0xFF	; 255
    1f46:	8f e4       	ldi	r24, 0x4F	; 79
    1f48:	93 e0       	ldi	r25, 0x03	; 3
    1f4a:	b9 01       	movw	r22, r18
    1f4c:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    1f50:	0f 90       	pop	r0
    1f52:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    1f54:	8b 81       	ldd	r24, Y+3	; 0x03
    1f56:	9c 81       	ldd	r25, Y+4	; 0x04
    1f58:	00 97       	sbiw	r24, 0x00	; 0
    1f5a:	a1 f4       	brne	.+40     	; 0x1f84 <vTaskSuspend+0xbc>
		{
			if( xSchedulerRunning != pdFALSE )
    1f5c:	80 91 06 03 	lds	r24, 0x0306
    1f60:	88 23       	and	r24, r24
    1f62:	19 f0       	breq	.+6      	; 0x1f6a <vTaskSuspend+0xa2>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    1f64:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortYield>
    1f68:	0d c0       	rjmp	.+26     	; 0x1f84 <vTaskSuspend+0xbc>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    1f6a:	90 91 4f 03 	lds	r25, 0x034F
    1f6e:	80 91 01 03 	lds	r24, 0x0301
    1f72:	98 17       	cp	r25, r24
    1f74:	29 f4       	brne	.+10     	; 0x1f80 <vTaskSuspend+0xb8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    1f76:	10 92 fd 02 	sts	0x02FD, r1
    1f7a:	10 92 fc 02 	sts	0x02FC, r1
    1f7e:	02 c0       	rjmp	.+4      	; 0x1f84 <vTaskSuspend+0xbc>
				}
				else
				{
					vTaskSwitchContext();
    1f80:	0e 94 b2 12 	call	0x2564	; 0x2564 <vTaskSwitchContext>
				}
			}
		}
	}
    1f84:	26 96       	adiw	r28, 0x06	; 6
    1f86:	0f b6       	in	r0, 0x3f	; 63
    1f88:	f8 94       	cli
    1f8a:	de bf       	out	0x3e, r29	; 62
    1f8c:	0f be       	out	0x3f, r0	; 63
    1f8e:	cd bf       	out	0x3d, r28	; 61
    1f90:	cf 91       	pop	r28
    1f92:	df 91       	pop	r29
    1f94:	08 95       	ret

00001f96 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    1f96:	df 93       	push	r29
    1f98:	cf 93       	push	r28
    1f9a:	00 d0       	rcall	.+0      	; 0x1f9c <xTaskIsTaskSuspended+0x6>
    1f9c:	00 d0       	rcall	.+0      	; 0x1f9e <xTaskIsTaskSuspended+0x8>
    1f9e:	0f 92       	push	r0
    1fa0:	cd b7       	in	r28, 0x3d	; 61
    1fa2:	de b7       	in	r29, 0x3e	; 62
    1fa4:	9d 83       	std	Y+5, r25	; 0x05
    1fa6:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
    1fa8:	1b 82       	std	Y+3, r1	; 0x03
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    1faa:	8c 81       	ldd	r24, Y+4	; 0x04
    1fac:	9d 81       	ldd	r25, Y+5	; 0x05
    1fae:	9a 83       	std	Y+2, r25	; 0x02
    1fb0:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1fb2:	e9 81       	ldd	r30, Y+1	; 0x01
    1fb4:	fa 81       	ldd	r31, Y+2	; 0x02
    1fb6:	82 85       	ldd	r24, Z+10	; 0x0a
    1fb8:	93 85       	ldd	r25, Z+11	; 0x0b
    1fba:	23 e0       	ldi	r18, 0x03	; 3
    1fbc:	8f 34       	cpi	r24, 0x4F	; 79
    1fbe:	92 07       	cpc	r25, r18
    1fc0:	81 f4       	brne	.+32     	; 0x1fe2 <xTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    1fc2:	e9 81       	ldd	r30, Y+1	; 0x01
    1fc4:	fa 81       	ldd	r31, Y+2	; 0x02
    1fc6:	84 89       	ldd	r24, Z+20	; 0x14
    1fc8:	95 89       	ldd	r25, Z+21	; 0x15
    1fca:	23 e0       	ldi	r18, 0x03	; 3
    1fcc:	8d 33       	cpi	r24, 0x3D	; 61
    1fce:	92 07       	cpc	r25, r18
    1fd0:	41 f0       	breq	.+16     	; 0x1fe2 <xTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    1fd2:	e9 81       	ldd	r30, Y+1	; 0x01
    1fd4:	fa 81       	ldd	r31, Y+2	; 0x02
    1fd6:	84 89       	ldd	r24, Z+20	; 0x14
    1fd8:	95 89       	ldd	r25, Z+21	; 0x15
    1fda:	00 97       	sbiw	r24, 0x00	; 0
    1fdc:	11 f4       	brne	.+4      	; 0x1fe2 <xTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    1fde:	81 e0       	ldi	r24, 0x01	; 1
    1fe0:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}

		return xReturn;
    1fe2:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    1fe4:	0f 90       	pop	r0
    1fe6:	0f 90       	pop	r0
    1fe8:	0f 90       	pop	r0
    1fea:	0f 90       	pop	r0
    1fec:	0f 90       	pop	r0
    1fee:	cf 91       	pop	r28
    1ff0:	df 91       	pop	r29
    1ff2:	08 95       	ret

00001ff4 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    1ff4:	df 93       	push	r29
    1ff6:	cf 93       	push	r28
    1ff8:	00 d0       	rcall	.+0      	; 0x1ffa <vTaskResume+0x6>
    1ffa:	00 d0       	rcall	.+0      	; 0x1ffc <vTaskResume+0x8>
    1ffc:	cd b7       	in	r28, 0x3d	; 61
    1ffe:	de b7       	in	r29, 0x3e	; 62
    2000:	9c 83       	std	Y+4, r25	; 0x04
    2002:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    2004:	8b 81       	ldd	r24, Y+3	; 0x03
    2006:	9c 81       	ldd	r25, Y+4	; 0x04
    2008:	9a 83       	std	Y+2, r25	; 0x02
    200a:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    200c:	89 81       	ldd	r24, Y+1	; 0x01
    200e:	9a 81       	ldd	r25, Y+2	; 0x02
    2010:	00 97       	sbiw	r24, 0x00	; 0
    2012:	09 f4       	brne	.+2      	; 0x2016 <vTaskResume+0x22>
    2014:	4c c0       	rjmp	.+152    	; 0x20ae <vTaskResume+0xba>
    2016:	20 91 fc 02 	lds	r18, 0x02FC
    201a:	30 91 fd 02 	lds	r19, 0x02FD
    201e:	89 81       	ldd	r24, Y+1	; 0x01
    2020:	9a 81       	ldd	r25, Y+2	; 0x02
    2022:	82 17       	cp	r24, r18
    2024:	93 07       	cpc	r25, r19
    2026:	09 f4       	brne	.+2      	; 0x202a <vTaskResume+0x36>
    2028:	42 c0       	rjmp	.+132    	; 0x20ae <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    202a:	0f b6       	in	r0, 0x3f	; 63
    202c:	f8 94       	cli
    202e:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2030:	89 81       	ldd	r24, Y+1	; 0x01
    2032:	9a 81       	ldd	r25, Y+2	; 0x02
    2034:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <xTaskIsTaskSuspended>
    2038:	81 30       	cpi	r24, 0x01	; 1
    203a:	b9 f5       	brne	.+110    	; 0x20aa <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    203c:	89 81       	ldd	r24, Y+1	; 0x01
    203e:	9a 81       	ldd	r25, Y+2	; 0x02
    2040:	02 96       	adiw	r24, 0x02	; 2
    2042:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2046:	e9 81       	ldd	r30, Y+1	; 0x01
    2048:	fa 81       	ldd	r31, Y+2	; 0x02
    204a:	96 89       	ldd	r25, Z+22	; 0x16
    204c:	80 91 05 03 	lds	r24, 0x0305
    2050:	89 17       	cp	r24, r25
    2052:	28 f4       	brcc	.+10     	; 0x205e <vTaskResume+0x6a>
    2054:	e9 81       	ldd	r30, Y+1	; 0x01
    2056:	fa 81       	ldd	r31, Y+2	; 0x02
    2058:	86 89       	ldd	r24, Z+22	; 0x16
    205a:	80 93 05 03 	sts	0x0305, r24
    205e:	e9 81       	ldd	r30, Y+1	; 0x01
    2060:	fa 81       	ldd	r31, Y+2	; 0x02
    2062:	86 89       	ldd	r24, Z+22	; 0x16
    2064:	28 2f       	mov	r18, r24
    2066:	30 e0       	ldi	r19, 0x00	; 0
    2068:	c9 01       	movw	r24, r18
    206a:	88 0f       	add	r24, r24
    206c:	99 1f       	adc	r25, r25
    206e:	88 0f       	add	r24, r24
    2070:	99 1f       	adc	r25, r25
    2072:	88 0f       	add	r24, r24
    2074:	99 1f       	adc	r25, r25
    2076:	82 0f       	add	r24, r18
    2078:	93 1f       	adc	r25, r19
    207a:	ac 01       	movw	r20, r24
    207c:	44 5f       	subi	r20, 0xF4	; 244
    207e:	5c 4f       	sbci	r21, 0xFC	; 252
    2080:	89 81       	ldd	r24, Y+1	; 0x01
    2082:	9a 81       	ldd	r25, Y+2	; 0x02
    2084:	9c 01       	movw	r18, r24
    2086:	2e 5f       	subi	r18, 0xFE	; 254
    2088:	3f 4f       	sbci	r19, 0xFF	; 255
    208a:	ca 01       	movw	r24, r20
    208c:	b9 01       	movw	r22, r18
    208e:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2092:	e9 81       	ldd	r30, Y+1	; 0x01
    2094:	fa 81       	ldd	r31, Y+2	; 0x02
    2096:	96 89       	ldd	r25, Z+22	; 0x16
    2098:	e0 91 fc 02 	lds	r30, 0x02FC
    209c:	f0 91 fd 02 	lds	r31, 0x02FD
    20a0:	86 89       	ldd	r24, Z+22	; 0x16
    20a2:	98 17       	cp	r25, r24
    20a4:	10 f0       	brcs	.+4      	; 0x20aa <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    20a6:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    20aa:	0f 90       	pop	r0
    20ac:	0f be       	out	0x3f, r0	; 63
		}
	}
    20ae:	0f 90       	pop	r0
    20b0:	0f 90       	pop	r0
    20b2:	0f 90       	pop	r0
    20b4:	0f 90       	pop	r0
    20b6:	cf 91       	pop	r28
    20b8:	df 91       	pop	r29
    20ba:	08 95       	ret

000020bc <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    20bc:	df 93       	push	r29
    20be:	cf 93       	push	r28
    20c0:	00 d0       	rcall	.+0      	; 0x20c2 <xTaskResumeFromISR+0x6>
    20c2:	00 d0       	rcall	.+0      	; 0x20c4 <xTaskResumeFromISR+0x8>
    20c4:	0f 92       	push	r0
    20c6:	cd b7       	in	r28, 0x3d	; 61
    20c8:	de b7       	in	r29, 0x3e	; 62
    20ca:	9d 83       	std	Y+5, r25	; 0x05
    20cc:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xYieldRequired = pdFALSE;
    20ce:	1b 82       	std	Y+3, r1	; 0x03
	tskTCB *pxTCB;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
    20d0:	8c 81       	ldd	r24, Y+4	; 0x04
    20d2:	9d 81       	ldd	r25, Y+5	; 0x05
    20d4:	9a 83       	std	Y+2, r25	; 0x02
    20d6:	89 83       	std	Y+1, r24	; 0x01

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    20d8:	89 81       	ldd	r24, Y+1	; 0x01
    20da:	9a 81       	ldd	r25, Y+2	; 0x02
    20dc:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <xTaskIsTaskSuspended>
    20e0:	81 30       	cpi	r24, 0x01	; 1
    20e2:	09 f0       	breq	.+2      	; 0x20e6 <xTaskResumeFromISR+0x2a>
    20e4:	47 c0       	rjmp	.+142    	; 0x2174 <xTaskResumeFromISR+0xb8>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20e6:	80 91 07 03 	lds	r24, 0x0307
    20ea:	88 23       	and	r24, r24
    20ec:	c9 f5       	brne	.+114    	; 0x2160 <xTaskResumeFromISR+0xa4>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    20ee:	e9 81       	ldd	r30, Y+1	; 0x01
    20f0:	fa 81       	ldd	r31, Y+2	; 0x02
    20f2:	96 89       	ldd	r25, Z+22	; 0x16
    20f4:	e0 91 fc 02 	lds	r30, 0x02FC
    20f8:	f0 91 fd 02 	lds	r31, 0x02FD
    20fc:	86 89       	ldd	r24, Z+22	; 0x16
    20fe:	1b 82       	std	Y+3, r1	; 0x03
    2100:	98 17       	cp	r25, r24
    2102:	10 f0       	brcs	.+4      	; 0x2108 <xTaskResumeFromISR+0x4c>
    2104:	81 e0       	ldi	r24, 0x01	; 1
    2106:	8b 83       	std	Y+3, r24	; 0x03
				vListRemove(  &( pxTCB->xGenericListItem ) );
    2108:	89 81       	ldd	r24, Y+1	; 0x01
    210a:	9a 81       	ldd	r25, Y+2	; 0x02
    210c:	02 96       	adiw	r24, 0x02	; 2
    210e:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    2112:	e9 81       	ldd	r30, Y+1	; 0x01
    2114:	fa 81       	ldd	r31, Y+2	; 0x02
    2116:	96 89       	ldd	r25, Z+22	; 0x16
    2118:	80 91 05 03 	lds	r24, 0x0305
    211c:	89 17       	cp	r24, r25
    211e:	28 f4       	brcc	.+10     	; 0x212a <xTaskResumeFromISR+0x6e>
    2120:	e9 81       	ldd	r30, Y+1	; 0x01
    2122:	fa 81       	ldd	r31, Y+2	; 0x02
    2124:	86 89       	ldd	r24, Z+22	; 0x16
    2126:	80 93 05 03 	sts	0x0305, r24
    212a:	e9 81       	ldd	r30, Y+1	; 0x01
    212c:	fa 81       	ldd	r31, Y+2	; 0x02
    212e:	86 89       	ldd	r24, Z+22	; 0x16
    2130:	28 2f       	mov	r18, r24
    2132:	30 e0       	ldi	r19, 0x00	; 0
    2134:	c9 01       	movw	r24, r18
    2136:	88 0f       	add	r24, r24
    2138:	99 1f       	adc	r25, r25
    213a:	88 0f       	add	r24, r24
    213c:	99 1f       	adc	r25, r25
    213e:	88 0f       	add	r24, r24
    2140:	99 1f       	adc	r25, r25
    2142:	82 0f       	add	r24, r18
    2144:	93 1f       	adc	r25, r19
    2146:	ac 01       	movw	r20, r24
    2148:	44 5f       	subi	r20, 0xF4	; 244
    214a:	5c 4f       	sbci	r21, 0xFC	; 252
    214c:	89 81       	ldd	r24, Y+1	; 0x01
    214e:	9a 81       	ldd	r25, Y+2	; 0x02
    2150:	9c 01       	movw	r18, r24
    2152:	2e 5f       	subi	r18, 0xFE	; 254
    2154:	3f 4f       	sbci	r19, 0xFF	; 255
    2156:	ca 01       	movw	r24, r20
    2158:	b9 01       	movw	r22, r18
    215a:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>
    215e:	0a c0       	rjmp	.+20     	; 0x2174 <xTaskResumeFromISR+0xb8>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2160:	89 81       	ldd	r24, Y+1	; 0x01
    2162:	9a 81       	ldd	r25, Y+2	; 0x02
    2164:	9c 01       	movw	r18, r24
    2166:	24 5f       	subi	r18, 0xF4	; 244
    2168:	3f 4f       	sbci	r19, 0xFF	; 255
    216a:	8d e3       	ldi	r24, 0x3D	; 61
    216c:	93 e0       	ldi	r25, 0x03	; 3
    216e:	b9 01       	movw	r22, r18
    2170:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>
			}
		}

		return xYieldRequired;
    2174:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2176:	0f 90       	pop	r0
    2178:	0f 90       	pop	r0
    217a:	0f 90       	pop	r0
    217c:	0f 90       	pop	r0
    217e:	0f 90       	pop	r0
    2180:	cf 91       	pop	r28
    2182:	df 91       	pop	r29
    2184:	08 95       	ret

00002186 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2186:	af 92       	push	r10
    2188:	bf 92       	push	r11
    218a:	cf 92       	push	r12
    218c:	df 92       	push	r13
    218e:	ef 92       	push	r14
    2190:	ff 92       	push	r15
    2192:	0f 93       	push	r16
    2194:	df 93       	push	r29
    2196:	cf 93       	push	r28
    2198:	0f 92       	push	r0
    219a:	cd b7       	in	r28, 0x3d	; 61
    219c:	de b7       	in	r29, 0x3e	; 62
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
    219e:	20 e6       	ldi	r18, 0x60	; 96
    21a0:	30 e0       	ldi	r19, 0x00	; 0
    21a2:	83 e5       	ldi	r24, 0x53	; 83
    21a4:	94 e1       	ldi	r25, 0x14	; 20
    21a6:	ef ef       	ldi	r30, 0xFF	; 255
    21a8:	f2 e0       	ldi	r31, 0x02	; 2
    21aa:	b9 01       	movw	r22, r18
    21ac:	45 e5       	ldi	r20, 0x55	; 85
    21ae:	50 e0       	ldi	r21, 0x00	; 0
    21b0:	20 e0       	ldi	r18, 0x00	; 0
    21b2:	30 e0       	ldi	r19, 0x00	; 0
    21b4:	00 e0       	ldi	r16, 0x00	; 0
    21b6:	7f 01       	movw	r14, r30
    21b8:	cc 24       	eor	r12, r12
    21ba:	dd 24       	eor	r13, r13
    21bc:	aa 24       	eor	r10, r10
    21be:	bb 24       	eor	r11, r11
    21c0:	0e 94 8c 0c 	call	0x1918	; 0x1918 <xTaskGenericCreate>
    21c4:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    21c6:	89 81       	ldd	r24, Y+1	; 0x01
    21c8:	81 30       	cpi	r24, 0x01	; 1
    21ca:	51 f4       	brne	.+20     	; 0x21e0 <vTaskStartScheduler+0x5a>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    21cc:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    21ce:	81 e0       	ldi	r24, 0x01	; 1
    21d0:	80 93 06 03 	sts	0x0306, r24
		xTickCount = ( portTickType ) 0U;
    21d4:	10 92 03 03 	sts	0x0303, r1
    21d8:	10 92 02 03 	sts	0x0302, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    21dc:	0e 94 bc 06 	call	0xd78	; 0xd78 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    21e0:	0f 90       	pop	r0
    21e2:	cf 91       	pop	r28
    21e4:	df 91       	pop	r29
    21e6:	0f 91       	pop	r16
    21e8:	ff 90       	pop	r15
    21ea:	ef 90       	pop	r14
    21ec:	df 90       	pop	r13
    21ee:	cf 90       	pop	r12
    21f0:	bf 90       	pop	r11
    21f2:	af 90       	pop	r10
    21f4:	08 95       	ret

000021f6 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    21f6:	df 93       	push	r29
    21f8:	cf 93       	push	r28
    21fa:	cd b7       	in	r28, 0x3d	; 61
    21fc:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    21fe:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2200:	10 92 06 03 	sts	0x0306, r1
	vPortEndScheduler();
    2204:	0e 94 f1 06 	call	0xde2	; 0xde2 <vPortEndScheduler>
}
    2208:	cf 91       	pop	r28
    220a:	df 91       	pop	r29
    220c:	08 95       	ret

0000220e <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    220e:	df 93       	push	r29
    2210:	cf 93       	push	r28
    2212:	cd b7       	in	r28, 0x3d	; 61
    2214:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2216:	80 91 07 03 	lds	r24, 0x0307
    221a:	8f 5f       	subi	r24, 0xFF	; 255
    221c:	80 93 07 03 	sts	0x0307, r24
}
    2220:	cf 91       	pop	r28
    2222:	df 91       	pop	r29
    2224:	08 95       	ret

00002226 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2226:	df 93       	push	r29
    2228:	cf 93       	push	r28
    222a:	00 d0       	rcall	.+0      	; 0x222c <xTaskResumeAll+0x6>
    222c:	00 d0       	rcall	.+0      	; 0x222e <xTaskResumeAll+0x8>
    222e:	cd b7       	in	r28, 0x3d	; 61
    2230:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2232:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2234:	0f b6       	in	r0, 0x3f	; 63
    2236:	f8 94       	cli
    2238:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    223a:	80 91 07 03 	lds	r24, 0x0307
    223e:	81 50       	subi	r24, 0x01	; 1
    2240:	80 93 07 03 	sts	0x0307, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2244:	80 91 07 03 	lds	r24, 0x0307
    2248:	88 23       	and	r24, r24
    224a:	09 f0       	breq	.+2      	; 0x224e <xTaskResumeAll+0x28>
    224c:	6c c0       	rjmp	.+216    	; 0x2326 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    224e:	80 91 01 03 	lds	r24, 0x0301
    2252:	88 23       	and	r24, r24
    2254:	09 f4       	brne	.+2      	; 0x2258 <xTaskResumeAll+0x32>
    2256:	67 c0       	rjmp	.+206    	; 0x2326 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    2258:	19 82       	std	Y+1, r1	; 0x01
    225a:	41 c0       	rjmp	.+130    	; 0x22de <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    225c:	e0 91 42 03 	lds	r30, 0x0342
    2260:	f0 91 43 03 	lds	r31, 0x0343
    2264:	86 81       	ldd	r24, Z+6	; 0x06
    2266:	97 81       	ldd	r25, Z+7	; 0x07
    2268:	9c 83       	std	Y+4, r25	; 0x04
    226a:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    226c:	8b 81       	ldd	r24, Y+3	; 0x03
    226e:	9c 81       	ldd	r25, Y+4	; 0x04
    2270:	0c 96       	adiw	r24, 0x0c	; 12
    2272:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2276:	8b 81       	ldd	r24, Y+3	; 0x03
    2278:	9c 81       	ldd	r25, Y+4	; 0x04
    227a:	02 96       	adiw	r24, 0x02	; 2
    227c:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2280:	eb 81       	ldd	r30, Y+3	; 0x03
    2282:	fc 81       	ldd	r31, Y+4	; 0x04
    2284:	96 89       	ldd	r25, Z+22	; 0x16
    2286:	80 91 05 03 	lds	r24, 0x0305
    228a:	89 17       	cp	r24, r25
    228c:	28 f4       	brcc	.+10     	; 0x2298 <xTaskResumeAll+0x72>
    228e:	eb 81       	ldd	r30, Y+3	; 0x03
    2290:	fc 81       	ldd	r31, Y+4	; 0x04
    2292:	86 89       	ldd	r24, Z+22	; 0x16
    2294:	80 93 05 03 	sts	0x0305, r24
    2298:	eb 81       	ldd	r30, Y+3	; 0x03
    229a:	fc 81       	ldd	r31, Y+4	; 0x04
    229c:	86 89       	ldd	r24, Z+22	; 0x16
    229e:	28 2f       	mov	r18, r24
    22a0:	30 e0       	ldi	r19, 0x00	; 0
    22a2:	c9 01       	movw	r24, r18
    22a4:	88 0f       	add	r24, r24
    22a6:	99 1f       	adc	r25, r25
    22a8:	88 0f       	add	r24, r24
    22aa:	99 1f       	adc	r25, r25
    22ac:	88 0f       	add	r24, r24
    22ae:	99 1f       	adc	r25, r25
    22b0:	82 0f       	add	r24, r18
    22b2:	93 1f       	adc	r25, r19
    22b4:	84 5f       	subi	r24, 0xF4	; 244
    22b6:	9c 4f       	sbci	r25, 0xFC	; 252
    22b8:	2b 81       	ldd	r18, Y+3	; 0x03
    22ba:	3c 81       	ldd	r19, Y+4	; 0x04
    22bc:	2e 5f       	subi	r18, 0xFE	; 254
    22be:	3f 4f       	sbci	r19, 0xFF	; 255
    22c0:	b9 01       	movw	r22, r18
    22c2:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    22c6:	eb 81       	ldd	r30, Y+3	; 0x03
    22c8:	fc 81       	ldd	r31, Y+4	; 0x04
    22ca:	96 89       	ldd	r25, Z+22	; 0x16
    22cc:	e0 91 fc 02 	lds	r30, 0x02FC
    22d0:	f0 91 fd 02 	lds	r31, 0x02FD
    22d4:	86 89       	ldd	r24, Z+22	; 0x16
    22d6:	98 17       	cp	r25, r24
    22d8:	10 f0       	brcs	.+4      	; 0x22de <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    22da:	81 e0       	ldi	r24, 0x01	; 1
    22dc:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    22de:	80 91 3d 03 	lds	r24, 0x033D
    22e2:	88 23       	and	r24, r24
    22e4:	09 f0       	breq	.+2      	; 0x22e8 <xTaskResumeAll+0xc2>
    22e6:	ba cf       	rjmp	.-140    	; 0x225c <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    22e8:	80 91 08 03 	lds	r24, 0x0308
    22ec:	88 23       	and	r24, r24
    22ee:	71 f0       	breq	.+28     	; 0x230c <xTaskResumeAll+0xe6>
    22f0:	07 c0       	rjmp	.+14     	; 0x2300 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    22f2:	0e 94 dd 11 	call	0x23ba	; 0x23ba <vTaskIncrementTick>
						--uxMissedTicks;
    22f6:	80 91 08 03 	lds	r24, 0x0308
    22fa:	81 50       	subi	r24, 0x01	; 1
    22fc:	80 93 08 03 	sts	0x0308, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2300:	80 91 08 03 	lds	r24, 0x0308
    2304:	88 23       	and	r24, r24
    2306:	a9 f7       	brne	.-22     	; 0x22f2 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    2308:	81 e0       	ldi	r24, 0x01	; 1
    230a:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    230c:	89 81       	ldd	r24, Y+1	; 0x01
    230e:	81 30       	cpi	r24, 0x01	; 1
    2310:	21 f0       	breq	.+8      	; 0x231a <xTaskResumeAll+0xf4>
    2312:	80 91 09 03 	lds	r24, 0x0309
    2316:	81 30       	cpi	r24, 0x01	; 1
    2318:	31 f4       	brne	.+12     	; 0x2326 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    231a:	81 e0       	ldi	r24, 0x01	; 1
    231c:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    231e:	10 92 09 03 	sts	0x0309, r1
					portYIELD_WITHIN_API();
    2322:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2326:	0f 90       	pop	r0
    2328:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    232a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    232c:	0f 90       	pop	r0
    232e:	0f 90       	pop	r0
    2330:	0f 90       	pop	r0
    2332:	0f 90       	pop	r0
    2334:	cf 91       	pop	r28
    2336:	df 91       	pop	r29
    2338:	08 95       	ret

0000233a <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    233a:	df 93       	push	r29
    233c:	cf 93       	push	r28
    233e:	00 d0       	rcall	.+0      	; 0x2340 <xTaskGetTickCount+0x6>
    2340:	cd b7       	in	r28, 0x3d	; 61
    2342:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2344:	0f b6       	in	r0, 0x3f	; 63
    2346:	f8 94       	cli
    2348:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    234a:	80 91 02 03 	lds	r24, 0x0302
    234e:	90 91 03 03 	lds	r25, 0x0303
    2352:	9a 83       	std	Y+2, r25	; 0x02
    2354:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2356:	0f 90       	pop	r0
    2358:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    235a:	89 81       	ldd	r24, Y+1	; 0x01
    235c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    235e:	0f 90       	pop	r0
    2360:	0f 90       	pop	r0
    2362:	cf 91       	pop	r28
    2364:	df 91       	pop	r29
    2366:	08 95       	ret

00002368 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    2368:	df 93       	push	r29
    236a:	cf 93       	push	r28
    236c:	00 d0       	rcall	.+0      	; 0x236e <xTaskGetTickCountFromISR+0x6>
    236e:	0f 92       	push	r0
    2370:	cd b7       	in	r28, 0x3d	; 61
    2372:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2374:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    2376:	80 91 02 03 	lds	r24, 0x0302
    237a:	90 91 03 03 	lds	r25, 0x0303
    237e:	9b 83       	std	Y+3, r25	; 0x03
    2380:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2382:	8a 81       	ldd	r24, Y+2	; 0x02
    2384:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2386:	0f 90       	pop	r0
    2388:	0f 90       	pop	r0
    238a:	0f 90       	pop	r0
    238c:	cf 91       	pop	r28
    238e:	df 91       	pop	r29
    2390:	08 95       	ret

00002392 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2392:	df 93       	push	r29
    2394:	cf 93       	push	r28
    2396:	cd b7       	in	r28, 0x3d	; 61
    2398:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    239a:	80 91 01 03 	lds	r24, 0x0301
}
    239e:	cf 91       	pop	r28
    23a0:	df 91       	pop	r29
    23a2:	08 95       	ret

000023a4 <xTaskGetIdleTaskHandle>:
/*----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )

	xTaskHandle xTaskGetIdleTaskHandle( void )
	{
    23a4:	df 93       	push	r29
    23a6:	cf 93       	push	r28
    23a8:	cd b7       	in	r28, 0x3d	; 61
    23aa:	de b7       	in	r29, 0x3e	; 62
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
    23ac:	80 91 ff 02 	lds	r24, 0x02FF
    23b0:	90 91 00 03 	lds	r25, 0x0300
	}
    23b4:	cf 91       	pop	r28
    23b6:	df 91       	pop	r29
    23b8:	08 95       	ret

000023ba <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    23ba:	df 93       	push	r29
    23bc:	cf 93       	push	r28
    23be:	00 d0       	rcall	.+0      	; 0x23c0 <vTaskIncrementTick+0x6>
    23c0:	00 d0       	rcall	.+0      	; 0x23c2 <vTaskIncrementTick+0x8>
    23c2:	00 d0       	rcall	.+0      	; 0x23c4 <vTaskIncrementTick+0xa>
    23c4:	cd b7       	in	r28, 0x3d	; 61
    23c6:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    23c8:	80 91 07 03 	lds	r24, 0x0307
    23cc:	88 23       	and	r24, r24
    23ce:	09 f0       	breq	.+2      	; 0x23d2 <vTaskIncrementTick+0x18>
    23d0:	bb c0       	rjmp	.+374    	; 0x2548 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    23d2:	80 91 02 03 	lds	r24, 0x0302
    23d6:	90 91 03 03 	lds	r25, 0x0303
    23da:	01 96       	adiw	r24, 0x01	; 1
    23dc:	90 93 03 03 	sts	0x0303, r25
    23e0:	80 93 02 03 	sts	0x0302, r24
		if( xTickCount == ( portTickType ) 0U )
    23e4:	80 91 02 03 	lds	r24, 0x0302
    23e8:	90 91 03 03 	lds	r25, 0x0303
    23ec:	00 97       	sbiw	r24, 0x00	; 0
    23ee:	d1 f5       	brne	.+116    	; 0x2464 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    23f0:	80 91 39 03 	lds	r24, 0x0339
    23f4:	90 91 3a 03 	lds	r25, 0x033A
    23f8:	9c 83       	std	Y+4, r25	; 0x04
    23fa:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    23fc:	80 91 3b 03 	lds	r24, 0x033B
    2400:	90 91 3c 03 	lds	r25, 0x033C
    2404:	90 93 3a 03 	sts	0x033A, r25
    2408:	80 93 39 03 	sts	0x0339, r24
			pxOverflowDelayedTaskList = pxTemp;
    240c:	8b 81       	ldd	r24, Y+3	; 0x03
    240e:	9c 81       	ldd	r25, Y+4	; 0x04
    2410:	90 93 3c 03 	sts	0x033C, r25
    2414:	80 93 3b 03 	sts	0x033B, r24
			xNumOfOverflows++;
    2418:	80 91 0a 03 	lds	r24, 0x030A
    241c:	8f 5f       	subi	r24, 0xFF	; 255
    241e:	80 93 0a 03 	sts	0x030A, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2422:	e0 91 39 03 	lds	r30, 0x0339
    2426:	f0 91 3a 03 	lds	r31, 0x033A
    242a:	80 81       	ld	r24, Z
    242c:	88 23       	and	r24, r24
    242e:	39 f4       	brne	.+14     	; 0x243e <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2430:	8f ef       	ldi	r24, 0xFF	; 255
    2432:	9f ef       	ldi	r25, 0xFF	; 255
    2434:	90 93 66 00 	sts	0x0066, r25
    2438:	80 93 65 00 	sts	0x0065, r24
    243c:	13 c0       	rjmp	.+38     	; 0x2464 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    243e:	e0 91 39 03 	lds	r30, 0x0339
    2442:	f0 91 3a 03 	lds	r31, 0x033A
    2446:	05 80       	ldd	r0, Z+5	; 0x05
    2448:	f6 81       	ldd	r31, Z+6	; 0x06
    244a:	e0 2d       	mov	r30, r0
    244c:	86 81       	ldd	r24, Z+6	; 0x06
    244e:	97 81       	ldd	r25, Z+7	; 0x07
    2450:	9e 83       	std	Y+6, r25	; 0x06
    2452:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2454:	ed 81       	ldd	r30, Y+5	; 0x05
    2456:	fe 81       	ldd	r31, Y+6	; 0x06
    2458:	82 81       	ldd	r24, Z+2	; 0x02
    245a:	93 81       	ldd	r25, Z+3	; 0x03
    245c:	90 93 66 00 	sts	0x0066, r25
    2460:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2464:	20 91 02 03 	lds	r18, 0x0302
    2468:	30 91 03 03 	lds	r19, 0x0303
    246c:	80 91 65 00 	lds	r24, 0x0065
    2470:	90 91 66 00 	lds	r25, 0x0066
    2474:	28 17       	cp	r18, r24
    2476:	39 07       	cpc	r19, r25
    2478:	08 f4       	brcc	.+2      	; 0x247c <vTaskIncrementTick+0xc2>
    247a:	6b c0       	rjmp	.+214    	; 0x2552 <vTaskIncrementTick+0x198>
    247c:	e0 91 39 03 	lds	r30, 0x0339
    2480:	f0 91 3a 03 	lds	r31, 0x033A
    2484:	80 81       	ld	r24, Z
    2486:	88 23       	and	r24, r24
    2488:	39 f4       	brne	.+14     	; 0x2498 <vTaskIncrementTick+0xde>
    248a:	8f ef       	ldi	r24, 0xFF	; 255
    248c:	9f ef       	ldi	r25, 0xFF	; 255
    248e:	90 93 66 00 	sts	0x0066, r25
    2492:	80 93 65 00 	sts	0x0065, r24
    2496:	5d c0       	rjmp	.+186    	; 0x2552 <vTaskIncrementTick+0x198>
    2498:	e0 91 39 03 	lds	r30, 0x0339
    249c:	f0 91 3a 03 	lds	r31, 0x033A
    24a0:	05 80       	ldd	r0, Z+5	; 0x05
    24a2:	f6 81       	ldd	r31, Z+6	; 0x06
    24a4:	e0 2d       	mov	r30, r0
    24a6:	86 81       	ldd	r24, Z+6	; 0x06
    24a8:	97 81       	ldd	r25, Z+7	; 0x07
    24aa:	9e 83       	std	Y+6, r25	; 0x06
    24ac:	8d 83       	std	Y+5, r24	; 0x05
    24ae:	ed 81       	ldd	r30, Y+5	; 0x05
    24b0:	fe 81       	ldd	r31, Y+6	; 0x06
    24b2:	82 81       	ldd	r24, Z+2	; 0x02
    24b4:	93 81       	ldd	r25, Z+3	; 0x03
    24b6:	9a 83       	std	Y+2, r25	; 0x02
    24b8:	89 83       	std	Y+1, r24	; 0x01
    24ba:	20 91 02 03 	lds	r18, 0x0302
    24be:	30 91 03 03 	lds	r19, 0x0303
    24c2:	89 81       	ldd	r24, Y+1	; 0x01
    24c4:	9a 81       	ldd	r25, Y+2	; 0x02
    24c6:	28 17       	cp	r18, r24
    24c8:	39 07       	cpc	r19, r25
    24ca:	38 f4       	brcc	.+14     	; 0x24da <vTaskIncrementTick+0x120>
    24cc:	89 81       	ldd	r24, Y+1	; 0x01
    24ce:	9a 81       	ldd	r25, Y+2	; 0x02
    24d0:	90 93 66 00 	sts	0x0066, r25
    24d4:	80 93 65 00 	sts	0x0065, r24
    24d8:	3c c0       	rjmp	.+120    	; 0x2552 <vTaskIncrementTick+0x198>
    24da:	8d 81       	ldd	r24, Y+5	; 0x05
    24dc:	9e 81       	ldd	r25, Y+6	; 0x06
    24de:	02 96       	adiw	r24, 0x02	; 2
    24e0:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
    24e4:	ed 81       	ldd	r30, Y+5	; 0x05
    24e6:	fe 81       	ldd	r31, Y+6	; 0x06
    24e8:	84 89       	ldd	r24, Z+20	; 0x14
    24ea:	95 89       	ldd	r25, Z+21	; 0x15
    24ec:	00 97       	sbiw	r24, 0x00	; 0
    24ee:	29 f0       	breq	.+10     	; 0x24fa <vTaskIncrementTick+0x140>
    24f0:	8d 81       	ldd	r24, Y+5	; 0x05
    24f2:	9e 81       	ldd	r25, Y+6	; 0x06
    24f4:	0c 96       	adiw	r24, 0x0c	; 12
    24f6:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
    24fa:	ed 81       	ldd	r30, Y+5	; 0x05
    24fc:	fe 81       	ldd	r31, Y+6	; 0x06
    24fe:	96 89       	ldd	r25, Z+22	; 0x16
    2500:	80 91 05 03 	lds	r24, 0x0305
    2504:	89 17       	cp	r24, r25
    2506:	28 f4       	brcc	.+10     	; 0x2512 <vTaskIncrementTick+0x158>
    2508:	ed 81       	ldd	r30, Y+5	; 0x05
    250a:	fe 81       	ldd	r31, Y+6	; 0x06
    250c:	86 89       	ldd	r24, Z+22	; 0x16
    250e:	80 93 05 03 	sts	0x0305, r24
    2512:	ed 81       	ldd	r30, Y+5	; 0x05
    2514:	fe 81       	ldd	r31, Y+6	; 0x06
    2516:	86 89       	ldd	r24, Z+22	; 0x16
    2518:	28 2f       	mov	r18, r24
    251a:	30 e0       	ldi	r19, 0x00	; 0
    251c:	c9 01       	movw	r24, r18
    251e:	88 0f       	add	r24, r24
    2520:	99 1f       	adc	r25, r25
    2522:	88 0f       	add	r24, r24
    2524:	99 1f       	adc	r25, r25
    2526:	88 0f       	add	r24, r24
    2528:	99 1f       	adc	r25, r25
    252a:	82 0f       	add	r24, r18
    252c:	93 1f       	adc	r25, r19
    252e:	ac 01       	movw	r20, r24
    2530:	44 5f       	subi	r20, 0xF4	; 244
    2532:	5c 4f       	sbci	r21, 0xFC	; 252
    2534:	8d 81       	ldd	r24, Y+5	; 0x05
    2536:	9e 81       	ldd	r25, Y+6	; 0x06
    2538:	9c 01       	movw	r18, r24
    253a:	2e 5f       	subi	r18, 0xFE	; 254
    253c:	3f 4f       	sbci	r19, 0xFF	; 255
    253e:	ca 01       	movw	r24, r20
    2540:	b9 01       	movw	r22, r18
    2542:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>
    2546:	9a cf       	rjmp	.-204    	; 0x247c <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2548:	80 91 08 03 	lds	r24, 0x0308
    254c:	8f 5f       	subi	r24, 0xFF	; 255
    254e:	80 93 08 03 	sts	0x0308, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2552:	26 96       	adiw	r28, 0x06	; 6
    2554:	0f b6       	in	r0, 0x3f	; 63
    2556:	f8 94       	cli
    2558:	de bf       	out	0x3e, r29	; 62
    255a:	0f be       	out	0x3f, r0	; 63
    255c:	cd bf       	out	0x3d, r28	; 61
    255e:	cf 91       	pop	r28
    2560:	df 91       	pop	r29
    2562:	08 95       	ret

00002564 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2564:	df 93       	push	r29
    2566:	cf 93       	push	r28
    2568:	00 d0       	rcall	.+0      	; 0x256a <vTaskSwitchContext+0x6>
    256a:	cd b7       	in	r28, 0x3d	; 61
    256c:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    256e:	80 91 07 03 	lds	r24, 0x0307
    2572:	88 23       	and	r24, r24
    2574:	49 f0       	breq	.+18     	; 0x2588 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2576:	81 e0       	ldi	r24, 0x01	; 1
    2578:	80 93 09 03 	sts	0x0309, r24
    257c:	54 c0       	rjmp	.+168    	; 0x2626 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    257e:	80 91 05 03 	lds	r24, 0x0305
    2582:	81 50       	subi	r24, 0x01	; 1
    2584:	80 93 05 03 	sts	0x0305, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2588:	80 91 05 03 	lds	r24, 0x0305
    258c:	28 2f       	mov	r18, r24
    258e:	30 e0       	ldi	r19, 0x00	; 0
    2590:	c9 01       	movw	r24, r18
    2592:	88 0f       	add	r24, r24
    2594:	99 1f       	adc	r25, r25
    2596:	88 0f       	add	r24, r24
    2598:	99 1f       	adc	r25, r25
    259a:	88 0f       	add	r24, r24
    259c:	99 1f       	adc	r25, r25
    259e:	82 0f       	add	r24, r18
    25a0:	93 1f       	adc	r25, r19
    25a2:	fc 01       	movw	r30, r24
    25a4:	e4 5f       	subi	r30, 0xF4	; 244
    25a6:	fc 4f       	sbci	r31, 0xFC	; 252
    25a8:	80 81       	ld	r24, Z
    25aa:	88 23       	and	r24, r24
    25ac:	41 f3       	breq	.-48     	; 0x257e <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    25ae:	80 91 05 03 	lds	r24, 0x0305
    25b2:	28 2f       	mov	r18, r24
    25b4:	30 e0       	ldi	r19, 0x00	; 0
    25b6:	c9 01       	movw	r24, r18
    25b8:	88 0f       	add	r24, r24
    25ba:	99 1f       	adc	r25, r25
    25bc:	88 0f       	add	r24, r24
    25be:	99 1f       	adc	r25, r25
    25c0:	88 0f       	add	r24, r24
    25c2:	99 1f       	adc	r25, r25
    25c4:	82 0f       	add	r24, r18
    25c6:	93 1f       	adc	r25, r19
    25c8:	84 5f       	subi	r24, 0xF4	; 244
    25ca:	9c 4f       	sbci	r25, 0xFC	; 252
    25cc:	9a 83       	std	Y+2, r25	; 0x02
    25ce:	89 83       	std	Y+1, r24	; 0x01
    25d0:	e9 81       	ldd	r30, Y+1	; 0x01
    25d2:	fa 81       	ldd	r31, Y+2	; 0x02
    25d4:	01 80       	ldd	r0, Z+1	; 0x01
    25d6:	f2 81       	ldd	r31, Z+2	; 0x02
    25d8:	e0 2d       	mov	r30, r0
    25da:	82 81       	ldd	r24, Z+2	; 0x02
    25dc:	93 81       	ldd	r25, Z+3	; 0x03
    25de:	e9 81       	ldd	r30, Y+1	; 0x01
    25e0:	fa 81       	ldd	r31, Y+2	; 0x02
    25e2:	92 83       	std	Z+2, r25	; 0x02
    25e4:	81 83       	std	Z+1, r24	; 0x01
    25e6:	e9 81       	ldd	r30, Y+1	; 0x01
    25e8:	fa 81       	ldd	r31, Y+2	; 0x02
    25ea:	21 81       	ldd	r18, Z+1	; 0x01
    25ec:	32 81       	ldd	r19, Z+2	; 0x02
    25ee:	89 81       	ldd	r24, Y+1	; 0x01
    25f0:	9a 81       	ldd	r25, Y+2	; 0x02
    25f2:	03 96       	adiw	r24, 0x03	; 3
    25f4:	28 17       	cp	r18, r24
    25f6:	39 07       	cpc	r19, r25
    25f8:	59 f4       	brne	.+22     	; 0x2610 <vTaskSwitchContext+0xac>
    25fa:	e9 81       	ldd	r30, Y+1	; 0x01
    25fc:	fa 81       	ldd	r31, Y+2	; 0x02
    25fe:	01 80       	ldd	r0, Z+1	; 0x01
    2600:	f2 81       	ldd	r31, Z+2	; 0x02
    2602:	e0 2d       	mov	r30, r0
    2604:	82 81       	ldd	r24, Z+2	; 0x02
    2606:	93 81       	ldd	r25, Z+3	; 0x03
    2608:	e9 81       	ldd	r30, Y+1	; 0x01
    260a:	fa 81       	ldd	r31, Y+2	; 0x02
    260c:	92 83       	std	Z+2, r25	; 0x02
    260e:	81 83       	std	Z+1, r24	; 0x01
    2610:	e9 81       	ldd	r30, Y+1	; 0x01
    2612:	fa 81       	ldd	r31, Y+2	; 0x02
    2614:	01 80       	ldd	r0, Z+1	; 0x01
    2616:	f2 81       	ldd	r31, Z+2	; 0x02
    2618:	e0 2d       	mov	r30, r0
    261a:	86 81       	ldd	r24, Z+6	; 0x06
    261c:	97 81       	ldd	r25, Z+7	; 0x07
    261e:	90 93 fd 02 	sts	0x02FD, r25
    2622:	80 93 fc 02 	sts	0x02FC, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2626:	0f 90       	pop	r0
    2628:	0f 90       	pop	r0
    262a:	cf 91       	pop	r28
    262c:	df 91       	pop	r29
    262e:	08 95       	ret

00002630 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2630:	df 93       	push	r29
    2632:	cf 93       	push	r28
    2634:	00 d0       	rcall	.+0      	; 0x2636 <vTaskPlaceOnEventList+0x6>
    2636:	00 d0       	rcall	.+0      	; 0x2638 <vTaskPlaceOnEventList+0x8>
    2638:	00 d0       	rcall	.+0      	; 0x263a <vTaskPlaceOnEventList+0xa>
    263a:	cd b7       	in	r28, 0x3d	; 61
    263c:	de b7       	in	r29, 0x3e	; 62
    263e:	9c 83       	std	Y+4, r25	; 0x04
    2640:	8b 83       	std	Y+3, r24	; 0x03
    2642:	7e 83       	std	Y+6, r23	; 0x06
    2644:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2646:	4b 81       	ldd	r20, Y+3	; 0x03
    2648:	5c 81       	ldd	r21, Y+4	; 0x04
    264a:	80 91 fc 02 	lds	r24, 0x02FC
    264e:	90 91 fd 02 	lds	r25, 0x02FD
    2652:	9c 01       	movw	r18, r24
    2654:	24 5f       	subi	r18, 0xF4	; 244
    2656:	3f 4f       	sbci	r19, 0xFF	; 255
    2658:	ca 01       	movw	r24, r20
    265a:	b9 01       	movw	r22, r18
    265c:	0e 94 84 04 	call	0x908	; 0x908 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2660:	80 91 fc 02 	lds	r24, 0x02FC
    2664:	90 91 fd 02 	lds	r25, 0x02FD
    2668:	02 96       	adiw	r24, 0x02	; 2
    266a:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    266e:	8d 81       	ldd	r24, Y+5	; 0x05
    2670:	9e 81       	ldd	r25, Y+6	; 0x06
    2672:	2f ef       	ldi	r18, 0xFF	; 255
    2674:	8f 3f       	cpi	r24, 0xFF	; 255
    2676:	92 07       	cpc	r25, r18
    2678:	69 f4       	brne	.+26     	; 0x2694 <vTaskPlaceOnEventList+0x64>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    267a:	80 91 fc 02 	lds	r24, 0x02FC
    267e:	90 91 fd 02 	lds	r25, 0x02FD
    2682:	9c 01       	movw	r18, r24
    2684:	2e 5f       	subi	r18, 0xFE	; 254
    2686:	3f 4f       	sbci	r19, 0xFF	; 255
    2688:	8f e4       	ldi	r24, 0x4F	; 79
    268a:	93 e0       	ldi	r25, 0x03	; 3
    268c:	b9 01       	movw	r22, r18
    268e:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>
    2692:	0e c0       	rjmp	.+28     	; 0x26b0 <vTaskPlaceOnEventList+0x80>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2694:	20 91 02 03 	lds	r18, 0x0302
    2698:	30 91 03 03 	lds	r19, 0x0303
    269c:	8d 81       	ldd	r24, Y+5	; 0x05
    269e:	9e 81       	ldd	r25, Y+6	; 0x06
    26a0:	82 0f       	add	r24, r18
    26a2:	93 1f       	adc	r25, r19
    26a4:	9a 83       	std	Y+2, r25	; 0x02
    26a6:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    26a8:	89 81       	ldd	r24, Y+1	; 0x01
    26aa:	9a 81       	ldd	r25, Y+2	; 0x02
    26ac:	0e 94 33 15 	call	0x2a66	; 0x2a66 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    26b0:	26 96       	adiw	r28, 0x06	; 6
    26b2:	0f b6       	in	r0, 0x3f	; 63
    26b4:	f8 94       	cli
    26b6:	de bf       	out	0x3e, r29	; 62
    26b8:	0f be       	out	0x3f, r0	; 63
    26ba:	cd bf       	out	0x3d, r28	; 61
    26bc:	cf 91       	pop	r28
    26be:	df 91       	pop	r29
    26c0:	08 95       	ret

000026c2 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    26c2:	df 93       	push	r29
    26c4:	cf 93       	push	r28
    26c6:	00 d0       	rcall	.+0      	; 0x26c8 <xTaskRemoveFromEventList+0x6>
    26c8:	00 d0       	rcall	.+0      	; 0x26ca <xTaskRemoveFromEventList+0x8>
    26ca:	0f 92       	push	r0
    26cc:	cd b7       	in	r28, 0x3d	; 61
    26ce:	de b7       	in	r29, 0x3e	; 62
    26d0:	9d 83       	std	Y+5, r25	; 0x05
    26d2:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    26d4:	ec 81       	ldd	r30, Y+4	; 0x04
    26d6:	fd 81       	ldd	r31, Y+5	; 0x05
    26d8:	05 80       	ldd	r0, Z+5	; 0x05
    26da:	f6 81       	ldd	r31, Z+6	; 0x06
    26dc:	e0 2d       	mov	r30, r0
    26de:	86 81       	ldd	r24, Z+6	; 0x06
    26e0:	97 81       	ldd	r25, Z+7	; 0x07
    26e2:	9b 83       	std	Y+3, r25	; 0x03
    26e4:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    26e6:	8a 81       	ldd	r24, Y+2	; 0x02
    26e8:	9b 81       	ldd	r25, Y+3	; 0x03
    26ea:	0c 96       	adiw	r24, 0x0c	; 12
    26ec:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    26f0:	80 91 07 03 	lds	r24, 0x0307
    26f4:	88 23       	and	r24, r24
    26f6:	61 f5       	brne	.+88     	; 0x2750 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    26f8:	8a 81       	ldd	r24, Y+2	; 0x02
    26fa:	9b 81       	ldd	r25, Y+3	; 0x03
    26fc:	02 96       	adiw	r24, 0x02	; 2
    26fe:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2702:	ea 81       	ldd	r30, Y+2	; 0x02
    2704:	fb 81       	ldd	r31, Y+3	; 0x03
    2706:	96 89       	ldd	r25, Z+22	; 0x16
    2708:	80 91 05 03 	lds	r24, 0x0305
    270c:	89 17       	cp	r24, r25
    270e:	28 f4       	brcc	.+10     	; 0x271a <xTaskRemoveFromEventList+0x58>
    2710:	ea 81       	ldd	r30, Y+2	; 0x02
    2712:	fb 81       	ldd	r31, Y+3	; 0x03
    2714:	86 89       	ldd	r24, Z+22	; 0x16
    2716:	80 93 05 03 	sts	0x0305, r24
    271a:	ea 81       	ldd	r30, Y+2	; 0x02
    271c:	fb 81       	ldd	r31, Y+3	; 0x03
    271e:	86 89       	ldd	r24, Z+22	; 0x16
    2720:	28 2f       	mov	r18, r24
    2722:	30 e0       	ldi	r19, 0x00	; 0
    2724:	c9 01       	movw	r24, r18
    2726:	88 0f       	add	r24, r24
    2728:	99 1f       	adc	r25, r25
    272a:	88 0f       	add	r24, r24
    272c:	99 1f       	adc	r25, r25
    272e:	88 0f       	add	r24, r24
    2730:	99 1f       	adc	r25, r25
    2732:	82 0f       	add	r24, r18
    2734:	93 1f       	adc	r25, r19
    2736:	ac 01       	movw	r20, r24
    2738:	44 5f       	subi	r20, 0xF4	; 244
    273a:	5c 4f       	sbci	r21, 0xFC	; 252
    273c:	8a 81       	ldd	r24, Y+2	; 0x02
    273e:	9b 81       	ldd	r25, Y+3	; 0x03
    2740:	9c 01       	movw	r18, r24
    2742:	2e 5f       	subi	r18, 0xFE	; 254
    2744:	3f 4f       	sbci	r19, 0xFF	; 255
    2746:	ca 01       	movw	r24, r20
    2748:	b9 01       	movw	r22, r18
    274a:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>
    274e:	0a c0       	rjmp	.+20     	; 0x2764 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2750:	8a 81       	ldd	r24, Y+2	; 0x02
    2752:	9b 81       	ldd	r25, Y+3	; 0x03
    2754:	9c 01       	movw	r18, r24
    2756:	24 5f       	subi	r18, 0xF4	; 244
    2758:	3f 4f       	sbci	r19, 0xFF	; 255
    275a:	8d e3       	ldi	r24, 0x3D	; 61
    275c:	93 e0       	ldi	r25, 0x03	; 3
    275e:	b9 01       	movw	r22, r18
    2760:	0e 94 38 04 	call	0x870	; 0x870 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2764:	ea 81       	ldd	r30, Y+2	; 0x02
    2766:	fb 81       	ldd	r31, Y+3	; 0x03
    2768:	96 89       	ldd	r25, Z+22	; 0x16
    276a:	e0 91 fc 02 	lds	r30, 0x02FC
    276e:	f0 91 fd 02 	lds	r31, 0x02FD
    2772:	86 89       	ldd	r24, Z+22	; 0x16
    2774:	98 17       	cp	r25, r24
    2776:	18 f0       	brcs	.+6      	; 0x277e <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2778:	81 e0       	ldi	r24, 0x01	; 1
    277a:	89 83       	std	Y+1, r24	; 0x01
    277c:	01 c0       	rjmp	.+2      	; 0x2780 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    277e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2780:	89 81       	ldd	r24, Y+1	; 0x01
}
    2782:	0f 90       	pop	r0
    2784:	0f 90       	pop	r0
    2786:	0f 90       	pop	r0
    2788:	0f 90       	pop	r0
    278a:	0f 90       	pop	r0
    278c:	cf 91       	pop	r28
    278e:	df 91       	pop	r29
    2790:	08 95       	ret

00002792 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2792:	df 93       	push	r29
    2794:	cf 93       	push	r28
    2796:	00 d0       	rcall	.+0      	; 0x2798 <vTaskSetTimeOutState+0x6>
    2798:	cd b7       	in	r28, 0x3d	; 61
    279a:	de b7       	in	r29, 0x3e	; 62
    279c:	9a 83       	std	Y+2, r25	; 0x02
    279e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    27a0:	80 91 0a 03 	lds	r24, 0x030A
    27a4:	e9 81       	ldd	r30, Y+1	; 0x01
    27a6:	fa 81       	ldd	r31, Y+2	; 0x02
    27a8:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    27aa:	80 91 02 03 	lds	r24, 0x0302
    27ae:	90 91 03 03 	lds	r25, 0x0303
    27b2:	e9 81       	ldd	r30, Y+1	; 0x01
    27b4:	fa 81       	ldd	r31, Y+2	; 0x02
    27b6:	92 83       	std	Z+2, r25	; 0x02
    27b8:	81 83       	std	Z+1, r24	; 0x01
}
    27ba:	0f 90       	pop	r0
    27bc:	0f 90       	pop	r0
    27be:	cf 91       	pop	r28
    27c0:	df 91       	pop	r29
    27c2:	08 95       	ret

000027c4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    27c4:	df 93       	push	r29
    27c6:	cf 93       	push	r28
    27c8:	00 d0       	rcall	.+0      	; 0x27ca <xTaskCheckForTimeOut+0x6>
    27ca:	00 d0       	rcall	.+0      	; 0x27cc <xTaskCheckForTimeOut+0x8>
    27cc:	0f 92       	push	r0
    27ce:	cd b7       	in	r28, 0x3d	; 61
    27d0:	de b7       	in	r29, 0x3e	; 62
    27d2:	9b 83       	std	Y+3, r25	; 0x03
    27d4:	8a 83       	std	Y+2, r24	; 0x02
    27d6:	7d 83       	std	Y+5, r23	; 0x05
    27d8:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    27da:	0f b6       	in	r0, 0x3f	; 63
    27dc:	f8 94       	cli
    27de:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    27e0:	ec 81       	ldd	r30, Y+4	; 0x04
    27e2:	fd 81       	ldd	r31, Y+5	; 0x05
    27e4:	80 81       	ld	r24, Z
    27e6:	91 81       	ldd	r25, Z+1	; 0x01
    27e8:	2f ef       	ldi	r18, 0xFF	; 255
    27ea:	8f 3f       	cpi	r24, 0xFF	; 255
    27ec:	92 07       	cpc	r25, r18
    27ee:	11 f4       	brne	.+4      	; 0x27f4 <xTaskCheckForTimeOut+0x30>
			{
				xReturn = pdFALSE;
    27f0:	19 82       	std	Y+1, r1	; 0x01
    27f2:	44 c0       	rjmp	.+136    	; 0x287c <xTaskCheckForTimeOut+0xb8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    27f4:	ea 81       	ldd	r30, Y+2	; 0x02
    27f6:	fb 81       	ldd	r31, Y+3	; 0x03
    27f8:	90 81       	ld	r25, Z
    27fa:	80 91 0a 03 	lds	r24, 0x030A
    27fe:	98 17       	cp	r25, r24
    2800:	71 f0       	breq	.+28     	; 0x281e <xTaskCheckForTimeOut+0x5a>
    2802:	ea 81       	ldd	r30, Y+2	; 0x02
    2804:	fb 81       	ldd	r31, Y+3	; 0x03
    2806:	21 81       	ldd	r18, Z+1	; 0x01
    2808:	32 81       	ldd	r19, Z+2	; 0x02
    280a:	80 91 02 03 	lds	r24, 0x0302
    280e:	90 91 03 03 	lds	r25, 0x0303
    2812:	82 17       	cp	r24, r18
    2814:	93 07       	cpc	r25, r19
    2816:	18 f0       	brcs	.+6      	; 0x281e <xTaskCheckForTimeOut+0x5a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2818:	81 e0       	ldi	r24, 0x01	; 1
    281a:	89 83       	std	Y+1, r24	; 0x01
    281c:	2f c0       	rjmp	.+94     	; 0x287c <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    281e:	20 91 02 03 	lds	r18, 0x0302
    2822:	30 91 03 03 	lds	r19, 0x0303
    2826:	ea 81       	ldd	r30, Y+2	; 0x02
    2828:	fb 81       	ldd	r31, Y+3	; 0x03
    282a:	81 81       	ldd	r24, Z+1	; 0x01
    282c:	92 81       	ldd	r25, Z+2	; 0x02
    282e:	28 1b       	sub	r18, r24
    2830:	39 0b       	sbc	r19, r25
    2832:	ec 81       	ldd	r30, Y+4	; 0x04
    2834:	fd 81       	ldd	r31, Y+5	; 0x05
    2836:	80 81       	ld	r24, Z
    2838:	91 81       	ldd	r25, Z+1	; 0x01
    283a:	28 17       	cp	r18, r24
    283c:	39 07       	cpc	r19, r25
    283e:	e0 f4       	brcc	.+56     	; 0x2878 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2840:	ec 81       	ldd	r30, Y+4	; 0x04
    2842:	fd 81       	ldd	r31, Y+5	; 0x05
    2844:	40 81       	ld	r20, Z
    2846:	51 81       	ldd	r21, Z+1	; 0x01
    2848:	ea 81       	ldd	r30, Y+2	; 0x02
    284a:	fb 81       	ldd	r31, Y+3	; 0x03
    284c:	21 81       	ldd	r18, Z+1	; 0x01
    284e:	32 81       	ldd	r19, Z+2	; 0x02
    2850:	80 91 02 03 	lds	r24, 0x0302
    2854:	90 91 03 03 	lds	r25, 0x0303
    2858:	b9 01       	movw	r22, r18
    285a:	68 1b       	sub	r22, r24
    285c:	79 0b       	sbc	r23, r25
    285e:	cb 01       	movw	r24, r22
    2860:	84 0f       	add	r24, r20
    2862:	95 1f       	adc	r25, r21
    2864:	ec 81       	ldd	r30, Y+4	; 0x04
    2866:	fd 81       	ldd	r31, Y+5	; 0x05
    2868:	91 83       	std	Z+1, r25	; 0x01
    286a:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    286c:	8a 81       	ldd	r24, Y+2	; 0x02
    286e:	9b 81       	ldd	r25, Y+3	; 0x03
    2870:	0e 94 c9 13 	call	0x2792	; 0x2792 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2874:	19 82       	std	Y+1, r1	; 0x01
    2876:	02 c0       	rjmp	.+4      	; 0x287c <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    2878:	81 e0       	ldi	r24, 0x01	; 1
    287a:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    287c:	0f 90       	pop	r0
    287e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2880:	89 81       	ldd	r24, Y+1	; 0x01
}
    2882:	0f 90       	pop	r0
    2884:	0f 90       	pop	r0
    2886:	0f 90       	pop	r0
    2888:	0f 90       	pop	r0
    288a:	0f 90       	pop	r0
    288c:	cf 91       	pop	r28
    288e:	df 91       	pop	r29
    2890:	08 95       	ret

00002892 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2892:	df 93       	push	r29
    2894:	cf 93       	push	r28
    2896:	cd b7       	in	r28, 0x3d	; 61
    2898:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    289a:	81 e0       	ldi	r24, 0x01	; 1
    289c:	80 93 09 03 	sts	0x0309, r24
}
    28a0:	cf 91       	pop	r28
    28a2:	df 91       	pop	r29
    28a4:	08 95       	ret

000028a6 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    28a6:	df 93       	push	r29
    28a8:	cf 93       	push	r28
    28aa:	00 d0       	rcall	.+0      	; 0x28ac <prvIdleTask+0x6>
    28ac:	cd b7       	in	r28, 0x3d	; 61
    28ae:	de b7       	in	r29, 0x3e	; 62
    28b0:	9a 83       	std	Y+2, r25	; 0x02
    28b2:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    28b4:	0e 94 f5 14 	call	0x29ea	; 0x29ea <prvCheckTasksWaitingTermination>
    28b8:	fd cf       	rjmp	.-6      	; 0x28b4 <prvIdleTask+0xe>

000028ba <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    28ba:	0f 93       	push	r16
    28bc:	1f 93       	push	r17
    28be:	df 93       	push	r29
    28c0:	cf 93       	push	r28
    28c2:	cd b7       	in	r28, 0x3d	; 61
    28c4:	de b7       	in	r29, 0x3e	; 62
    28c6:	29 97       	sbiw	r28, 0x09	; 9
    28c8:	0f b6       	in	r0, 0x3f	; 63
    28ca:	f8 94       	cli
    28cc:	de bf       	out	0x3e, r29	; 62
    28ce:	0f be       	out	0x3f, r0	; 63
    28d0:	cd bf       	out	0x3d, r28	; 61
    28d2:	9a 83       	std	Y+2, r25	; 0x02
    28d4:	89 83       	std	Y+1, r24	; 0x01
    28d6:	7c 83       	std	Y+4, r23	; 0x04
    28d8:	6b 83       	std	Y+3, r22	; 0x03
    28da:	4d 83       	std	Y+5, r20	; 0x05
    28dc:	3f 83       	std	Y+7, r19	; 0x07
    28de:	2e 83       	std	Y+6, r18	; 0x06
    28e0:	19 87       	std	Y+9, r17	; 0x09
    28e2:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    28e4:	89 81       	ldd	r24, Y+1	; 0x01
    28e6:	9a 81       	ldd	r25, Y+2	; 0x02
    28e8:	49 96       	adiw	r24, 0x19	; 25
    28ea:	2b 81       	ldd	r18, Y+3	; 0x03
    28ec:	3c 81       	ldd	r19, Y+4	; 0x04
    28ee:	b9 01       	movw	r22, r18
    28f0:	48 e0       	ldi	r20, 0x08	; 8
    28f2:	50 e0       	ldi	r21, 0x00	; 0
    28f4:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    28f8:	e9 81       	ldd	r30, Y+1	; 0x01
    28fa:	fa 81       	ldd	r31, Y+2	; 0x02
    28fc:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    28fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2900:	83 30       	cpi	r24, 0x03	; 3
    2902:	10 f0       	brcs	.+4      	; 0x2908 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2904:	82 e0       	ldi	r24, 0x02	; 2
    2906:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2908:	e9 81       	ldd	r30, Y+1	; 0x01
    290a:	fa 81       	ldd	r31, Y+2	; 0x02
    290c:	8d 81       	ldd	r24, Y+5	; 0x05
    290e:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2910:	89 81       	ldd	r24, Y+1	; 0x01
    2912:	9a 81       	ldd	r25, Y+2	; 0x02
    2914:	02 96       	adiw	r24, 0x02	; 2
    2916:	0e 94 28 04 	call	0x850	; 0x850 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    291a:	89 81       	ldd	r24, Y+1	; 0x01
    291c:	9a 81       	ldd	r25, Y+2	; 0x02
    291e:	0c 96       	adiw	r24, 0x0c	; 12
    2920:	0e 94 28 04 	call	0x850	; 0x850 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2924:	e9 81       	ldd	r30, Y+1	; 0x01
    2926:	fa 81       	ldd	r31, Y+2	; 0x02
    2928:	89 81       	ldd	r24, Y+1	; 0x01
    292a:	9a 81       	ldd	r25, Y+2	; 0x02
    292c:	91 87       	std	Z+9, r25	; 0x09
    292e:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2930:	8d 81       	ldd	r24, Y+5	; 0x05
    2932:	28 2f       	mov	r18, r24
    2934:	30 e0       	ldi	r19, 0x00	; 0
    2936:	83 e0       	ldi	r24, 0x03	; 3
    2938:	90 e0       	ldi	r25, 0x00	; 0
    293a:	82 1b       	sub	r24, r18
    293c:	93 0b       	sbc	r25, r19
    293e:	e9 81       	ldd	r30, Y+1	; 0x01
    2940:	fa 81       	ldd	r31, Y+2	; 0x02
    2942:	95 87       	std	Z+13, r25	; 0x0d
    2944:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2946:	e9 81       	ldd	r30, Y+1	; 0x01
    2948:	fa 81       	ldd	r31, Y+2	; 0x02
    294a:	89 81       	ldd	r24, Y+1	; 0x01
    294c:	9a 81       	ldd	r25, Y+2	; 0x02
    294e:	93 8b       	std	Z+19, r25	; 0x13
    2950:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2952:	29 96       	adiw	r28, 0x09	; 9
    2954:	0f b6       	in	r0, 0x3f	; 63
    2956:	f8 94       	cli
    2958:	de bf       	out	0x3e, r29	; 62
    295a:	0f be       	out	0x3f, r0	; 63
    295c:	cd bf       	out	0x3d, r28	; 61
    295e:	cf 91       	pop	r28
    2960:	df 91       	pop	r29
    2962:	1f 91       	pop	r17
    2964:	0f 91       	pop	r16
    2966:	08 95       	ret

00002968 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2968:	df 93       	push	r29
    296a:	cf 93       	push	r28
    296c:	0f 92       	push	r0
    296e:	cd b7       	in	r28, 0x3d	; 61
    2970:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2972:	19 82       	std	Y+1, r1	; 0x01
    2974:	13 c0       	rjmp	.+38     	; 0x299c <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2976:	89 81       	ldd	r24, Y+1	; 0x01
    2978:	28 2f       	mov	r18, r24
    297a:	30 e0       	ldi	r19, 0x00	; 0
    297c:	c9 01       	movw	r24, r18
    297e:	88 0f       	add	r24, r24
    2980:	99 1f       	adc	r25, r25
    2982:	88 0f       	add	r24, r24
    2984:	99 1f       	adc	r25, r25
    2986:	88 0f       	add	r24, r24
    2988:	99 1f       	adc	r25, r25
    298a:	82 0f       	add	r24, r18
    298c:	93 1f       	adc	r25, r19
    298e:	84 5f       	subi	r24, 0xF4	; 244
    2990:	9c 4f       	sbci	r25, 0xFC	; 252
    2992:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2996:	89 81       	ldd	r24, Y+1	; 0x01
    2998:	8f 5f       	subi	r24, 0xFF	; 255
    299a:	89 83       	std	Y+1, r24	; 0x01
    299c:	89 81       	ldd	r24, Y+1	; 0x01
    299e:	83 30       	cpi	r24, 0x03	; 3
    29a0:	50 f3       	brcs	.-44     	; 0x2976 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    29a2:	87 e2       	ldi	r24, 0x27	; 39
    29a4:	93 e0       	ldi	r25, 0x03	; 3
    29a6:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    29aa:	80 e3       	ldi	r24, 0x30	; 48
    29ac:	93 e0       	ldi	r25, 0x03	; 3
    29ae:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    29b2:	8d e3       	ldi	r24, 0x3D	; 61
    29b4:	93 e0       	ldi	r25, 0x03	; 3
    29b6:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    29ba:	86 e4       	ldi	r24, 0x46	; 70
    29bc:	93 e0       	ldi	r25, 0x03	; 3
    29be:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    29c2:	8f e4       	ldi	r24, 0x4F	; 79
    29c4:	93 e0       	ldi	r25, 0x03	; 3
    29c6:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    29ca:	87 e2       	ldi	r24, 0x27	; 39
    29cc:	93 e0       	ldi	r25, 0x03	; 3
    29ce:	90 93 3a 03 	sts	0x033A, r25
    29d2:	80 93 39 03 	sts	0x0339, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    29d6:	80 e3       	ldi	r24, 0x30	; 48
    29d8:	93 e0       	ldi	r25, 0x03	; 3
    29da:	90 93 3c 03 	sts	0x033C, r25
    29de:	80 93 3b 03 	sts	0x033B, r24
}
    29e2:	0f 90       	pop	r0
    29e4:	cf 91       	pop	r28
    29e6:	df 91       	pop	r29
    29e8:	08 95       	ret

000029ea <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    29ea:	df 93       	push	r29
    29ec:	cf 93       	push	r28
    29ee:	00 d0       	rcall	.+0      	; 0x29f0 <prvCheckTasksWaitingTermination+0x6>
    29f0:	0f 92       	push	r0
    29f2:	cd b7       	in	r28, 0x3d	; 61
    29f4:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    29f6:	80 91 fe 02 	lds	r24, 0x02FE
    29fa:	88 23       	and	r24, r24
    29fc:	71 f1       	breq	.+92     	; 0x2a5a <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    29fe:	0e 94 07 11 	call	0x220e	; 0x220e <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2a02:	80 91 46 03 	lds	r24, 0x0346
    2a06:	1b 82       	std	Y+3, r1	; 0x03
    2a08:	88 23       	and	r24, r24
    2a0a:	11 f4       	brne	.+4      	; 0x2a10 <prvCheckTasksWaitingTermination+0x26>
    2a0c:	81 e0       	ldi	r24, 0x01	; 1
    2a0e:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    2a10:	0e 94 13 11 	call	0x2226	; 0x2226 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2a14:	8b 81       	ldd	r24, Y+3	; 0x03
    2a16:	88 23       	and	r24, r24
    2a18:	01 f5       	brne	.+64     	; 0x2a5a <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2a1a:	0f b6       	in	r0, 0x3f	; 63
    2a1c:	f8 94       	cli
    2a1e:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2a20:	e0 91 4b 03 	lds	r30, 0x034B
    2a24:	f0 91 4c 03 	lds	r31, 0x034C
    2a28:	86 81       	ldd	r24, Z+6	; 0x06
    2a2a:	97 81       	ldd	r25, Z+7	; 0x07
    2a2c:	9a 83       	std	Y+2, r25	; 0x02
    2a2e:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    2a30:	89 81       	ldd	r24, Y+1	; 0x01
    2a32:	9a 81       	ldd	r25, Y+2	; 0x02
    2a34:	02 96       	adiw	r24, 0x02	; 2
    2a36:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <vListRemove>
					--uxCurrentNumberOfTasks;
    2a3a:	80 91 01 03 	lds	r24, 0x0301
    2a3e:	81 50       	subi	r24, 0x01	; 1
    2a40:	80 93 01 03 	sts	0x0301, r24
					--uxTasksDeleted;
    2a44:	80 91 fe 02 	lds	r24, 0x02FE
    2a48:	81 50       	subi	r24, 0x01	; 1
    2a4a:	80 93 fe 02 	sts	0x02FE, r24
				}
				taskEXIT_CRITICAL();
    2a4e:	0f 90       	pop	r0
    2a50:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2a52:	89 81       	ldd	r24, Y+1	; 0x01
    2a54:	9a 81       	ldd	r25, Y+2	; 0x02
    2a56:	0e 94 23 16 	call	0x2c46	; 0x2c46 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    2a5a:	0f 90       	pop	r0
    2a5c:	0f 90       	pop	r0
    2a5e:	0f 90       	pop	r0
    2a60:	cf 91       	pop	r28
    2a62:	df 91       	pop	r29
    2a64:	08 95       	ret

00002a66 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2a66:	df 93       	push	r29
    2a68:	cf 93       	push	r28
    2a6a:	00 d0       	rcall	.+0      	; 0x2a6c <prvAddCurrentTaskToDelayedList+0x6>
    2a6c:	cd b7       	in	r28, 0x3d	; 61
    2a6e:	de b7       	in	r29, 0x3e	; 62
    2a70:	9a 83       	std	Y+2, r25	; 0x02
    2a72:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2a74:	e0 91 fc 02 	lds	r30, 0x02FC
    2a78:	f0 91 fd 02 	lds	r31, 0x02FD
    2a7c:	89 81       	ldd	r24, Y+1	; 0x01
    2a7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a80:	93 83       	std	Z+3, r25	; 0x03
    2a82:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    2a84:	20 91 02 03 	lds	r18, 0x0302
    2a88:	30 91 03 03 	lds	r19, 0x0303
    2a8c:	89 81       	ldd	r24, Y+1	; 0x01
    2a8e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a90:	82 17       	cp	r24, r18
    2a92:	93 07       	cpc	r25, r19
    2a94:	70 f4       	brcc	.+28     	; 0x2ab2 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2a96:	80 91 3b 03 	lds	r24, 0x033B
    2a9a:	90 91 3c 03 	lds	r25, 0x033C
    2a9e:	20 91 fc 02 	lds	r18, 0x02FC
    2aa2:	30 91 fd 02 	lds	r19, 0x02FD
    2aa6:	2e 5f       	subi	r18, 0xFE	; 254
    2aa8:	3f 4f       	sbci	r19, 0xFF	; 255
    2aaa:	b9 01       	movw	r22, r18
    2aac:	0e 94 84 04 	call	0x908	; 0x908 <vListInsert>
    2ab0:	1e c0       	rjmp	.+60     	; 0x2aee <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2ab2:	40 91 39 03 	lds	r20, 0x0339
    2ab6:	50 91 3a 03 	lds	r21, 0x033A
    2aba:	80 91 fc 02 	lds	r24, 0x02FC
    2abe:	90 91 fd 02 	lds	r25, 0x02FD
    2ac2:	9c 01       	movw	r18, r24
    2ac4:	2e 5f       	subi	r18, 0xFE	; 254
    2ac6:	3f 4f       	sbci	r19, 0xFF	; 255
    2ac8:	ca 01       	movw	r24, r20
    2aca:	b9 01       	movw	r22, r18
    2acc:	0e 94 84 04 	call	0x908	; 0x908 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2ad0:	20 91 65 00 	lds	r18, 0x0065
    2ad4:	30 91 66 00 	lds	r19, 0x0066
    2ad8:	89 81       	ldd	r24, Y+1	; 0x01
    2ada:	9a 81       	ldd	r25, Y+2	; 0x02
    2adc:	82 17       	cp	r24, r18
    2ade:	93 07       	cpc	r25, r19
    2ae0:	30 f4       	brcc	.+12     	; 0x2aee <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2ae2:	89 81       	ldd	r24, Y+1	; 0x01
    2ae4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae6:	90 93 66 00 	sts	0x0066, r25
    2aea:	80 93 65 00 	sts	0x0065, r24
		}
	}
}
    2aee:	0f 90       	pop	r0
    2af0:	0f 90       	pop	r0
    2af2:	cf 91       	pop	r28
    2af4:	df 91       	pop	r29
    2af6:	08 95       	ret

00002af8 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    2af8:	df 93       	push	r29
    2afa:	cf 93       	push	r28
    2afc:	cd b7       	in	r28, 0x3d	; 61
    2afe:	de b7       	in	r29, 0x3e	; 62
    2b00:	28 97       	sbiw	r28, 0x08	; 8
    2b02:	0f b6       	in	r0, 0x3f	; 63
    2b04:	f8 94       	cli
    2b06:	de bf       	out	0x3e, r29	; 62
    2b08:	0f be       	out	0x3f, r0	; 63
    2b0a:	cd bf       	out	0x3d, r28	; 61
    2b0c:	9c 83       	std	Y+4, r25	; 0x04
    2b0e:	8b 83       	std	Y+3, r24	; 0x03
    2b10:	7e 83       	std	Y+6, r23	; 0x06
    2b12:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2b14:	81 e2       	ldi	r24, 0x21	; 33
    2b16:	90 e0       	ldi	r25, 0x00	; 0
    2b18:	0e 94 92 03 	call	0x724	; 0x724 <pvPortMalloc>
    2b1c:	9a 83       	std	Y+2, r25	; 0x02
    2b1e:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    2b20:	89 81       	ldd	r24, Y+1	; 0x01
    2b22:	9a 81       	ldd	r25, Y+2	; 0x02
    2b24:	00 97       	sbiw	r24, 0x00	; 0
    2b26:	69 f1       	breq	.+90     	; 0x2b82 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2b28:	8d 81       	ldd	r24, Y+5	; 0x05
    2b2a:	9e 81       	ldd	r25, Y+6	; 0x06
    2b2c:	00 97       	sbiw	r24, 0x00	; 0
    2b2e:	39 f4       	brne	.+14     	; 0x2b3e <prvAllocateTCBAndStack+0x46>
    2b30:	8b 81       	ldd	r24, Y+3	; 0x03
    2b32:	9c 81       	ldd	r25, Y+4	; 0x04
    2b34:	0e 94 92 03 	call	0x724	; 0x724 <pvPortMalloc>
    2b38:	98 87       	std	Y+8, r25	; 0x08
    2b3a:	8f 83       	std	Y+7, r24	; 0x07
    2b3c:	04 c0       	rjmp	.+8      	; 0x2b46 <prvAllocateTCBAndStack+0x4e>
    2b3e:	8d 81       	ldd	r24, Y+5	; 0x05
    2b40:	9e 81       	ldd	r25, Y+6	; 0x06
    2b42:	98 87       	std	Y+8, r25	; 0x08
    2b44:	8f 83       	std	Y+7, r24	; 0x07
    2b46:	e9 81       	ldd	r30, Y+1	; 0x01
    2b48:	fa 81       	ldd	r31, Y+2	; 0x02
    2b4a:	8f 81       	ldd	r24, Y+7	; 0x07
    2b4c:	98 85       	ldd	r25, Y+8	; 0x08
    2b4e:	90 8f       	std	Z+24, r25	; 0x18
    2b50:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2b52:	e9 81       	ldd	r30, Y+1	; 0x01
    2b54:	fa 81       	ldd	r31, Y+2	; 0x02
    2b56:	87 89       	ldd	r24, Z+23	; 0x17
    2b58:	90 8d       	ldd	r25, Z+24	; 0x18
    2b5a:	00 97       	sbiw	r24, 0x00	; 0
    2b5c:	39 f4       	brne	.+14     	; 0x2b6c <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2b5e:	89 81       	ldd	r24, Y+1	; 0x01
    2b60:	9a 81       	ldd	r25, Y+2	; 0x02
    2b62:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <vPortFree>
			pxNewTCB = NULL;
    2b66:	1a 82       	std	Y+2, r1	; 0x02
    2b68:	19 82       	std	Y+1, r1	; 0x01
    2b6a:	0b c0       	rjmp	.+22     	; 0x2b82 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2b6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b70:	87 89       	ldd	r24, Z+23	; 0x17
    2b72:	90 8d       	ldd	r25, Z+24	; 0x18
    2b74:	2b 81       	ldd	r18, Y+3	; 0x03
    2b76:	3c 81       	ldd	r19, Y+4	; 0x04
    2b78:	65 ea       	ldi	r22, 0xA5	; 165
    2b7a:	70 e0       	ldi	r23, 0x00	; 0
    2b7c:	a9 01       	movw	r20, r18
    2b7e:	0e 94 6d 16 	call	0x2cda	; 0x2cda <memset>
		}
	}

	return pxNewTCB;
    2b82:	89 81       	ldd	r24, Y+1	; 0x01
    2b84:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2b86:	28 96       	adiw	r28, 0x08	; 8
    2b88:	0f b6       	in	r0, 0x3f	; 63
    2b8a:	f8 94       	cli
    2b8c:	de bf       	out	0x3e, r29	; 62
    2b8e:	0f be       	out	0x3f, r0	; 63
    2b90:	cd bf       	out	0x3d, r28	; 61
    2b92:	cf 91       	pop	r28
    2b94:	df 91       	pop	r29
    2b96:	08 95       	ret

00002b98 <usTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
    2b98:	df 93       	push	r29
    2b9a:	cf 93       	push	r28
    2b9c:	00 d0       	rcall	.+0      	; 0x2b9e <usTaskCheckFreeStackSpace+0x6>
    2b9e:	00 d0       	rcall	.+0      	; 0x2ba0 <usTaskCheckFreeStackSpace+0x8>
    2ba0:	cd b7       	in	r28, 0x3d	; 61
    2ba2:	de b7       	in	r29, 0x3e	; 62
    2ba4:	9a 83       	std	Y+2, r25	; 0x02
    2ba6:	89 83       	std	Y+1, r24	; 0x01
	register unsigned short usCount = 0U;
    2ba8:	1c 82       	std	Y+4, r1	; 0x04
    2baa:	1b 82       	std	Y+3, r1	; 0x03
    2bac:	0a c0       	rjmp	.+20     	; 0x2bc2 <usTaskCheckFreeStackSpace+0x2a>

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
    2bae:	89 81       	ldd	r24, Y+1	; 0x01
    2bb0:	9a 81       	ldd	r25, Y+2	; 0x02
    2bb2:	01 96       	adiw	r24, 0x01	; 1
    2bb4:	9a 83       	std	Y+2, r25	; 0x02
    2bb6:	89 83       	std	Y+1, r24	; 0x01
			usCount++;
    2bb8:	8b 81       	ldd	r24, Y+3	; 0x03
    2bba:	9c 81       	ldd	r25, Y+4	; 0x04
    2bbc:	01 96       	adiw	r24, 0x01	; 1
    2bbe:	9c 83       	std	Y+4, r25	; 0x04
    2bc0:	8b 83       	std	Y+3, r24	; 0x03

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2bc2:	e9 81       	ldd	r30, Y+1	; 0x01
    2bc4:	fa 81       	ldd	r31, Y+2	; 0x02
    2bc6:	80 81       	ld	r24, Z
    2bc8:	85 3a       	cpi	r24, 0xA5	; 165
    2bca:	89 f3       	breq	.-30     	; 0x2bae <usTaskCheckFreeStackSpace+0x16>
			usCount++;
		}

		usCount /= sizeof( portSTACK_TYPE );

		return usCount;
    2bcc:	8b 81       	ldd	r24, Y+3	; 0x03
    2bce:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    2bd0:	0f 90       	pop	r0
    2bd2:	0f 90       	pop	r0
    2bd4:	0f 90       	pop	r0
    2bd6:	0f 90       	pop	r0
    2bd8:	cf 91       	pop	r28
    2bda:	df 91       	pop	r29
    2bdc:	08 95       	ret

00002bde <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
    2bde:	df 93       	push	r29
    2be0:	cf 93       	push	r28
    2be2:	cd b7       	in	r28, 0x3d	; 61
    2be4:	de b7       	in	r29, 0x3e	; 62
    2be6:	29 97       	sbiw	r28, 0x09	; 9
    2be8:	0f b6       	in	r0, 0x3f	; 63
    2bea:	f8 94       	cli
    2bec:	de bf       	out	0x3e, r29	; 62
    2bee:	0f be       	out	0x3f, r0	; 63
    2bf0:	cd bf       	out	0x3d, r28	; 61
    2bf2:	9f 83       	std	Y+7, r25	; 0x07
    2bf4:	8e 83       	std	Y+6, r24	; 0x06
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2bf6:	8e 81       	ldd	r24, Y+6	; 0x06
    2bf8:	9f 81       	ldd	r25, Y+7	; 0x07
    2bfa:	00 97       	sbiw	r24, 0x00	; 0
    2bfc:	39 f4       	brne	.+14     	; 0x2c0c <uxTaskGetStackHighWaterMark+0x2e>
    2bfe:	80 91 fc 02 	lds	r24, 0x02FC
    2c02:	90 91 fd 02 	lds	r25, 0x02FD
    2c06:	99 87       	std	Y+9, r25	; 0x09
    2c08:	88 87       	std	Y+8, r24	; 0x08
    2c0a:	04 c0       	rjmp	.+8      	; 0x2c14 <uxTaskGetStackHighWaterMark+0x36>
    2c0c:	8e 81       	ldd	r24, Y+6	; 0x06
    2c0e:	9f 81       	ldd	r25, Y+7	; 0x07
    2c10:	99 87       	std	Y+9, r25	; 0x09
    2c12:	88 87       	std	Y+8, r24	; 0x08
    2c14:	88 85       	ldd	r24, Y+8	; 0x08
    2c16:	99 85       	ldd	r25, Y+9	; 0x09
    2c18:	9d 83       	std	Y+5, r25	; 0x05
    2c1a:	8c 83       	std	Y+4, r24	; 0x04

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2c1c:	ec 81       	ldd	r30, Y+4	; 0x04
    2c1e:	fd 81       	ldd	r31, Y+5	; 0x05
    2c20:	87 89       	ldd	r24, Z+23	; 0x17
    2c22:	90 8d       	ldd	r25, Z+24	; 0x18
    2c24:	9b 83       	std	Y+3, r25	; 0x03
    2c26:	8a 83       	std	Y+2, r24	; 0x02
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
    2c28:	8a 81       	ldd	r24, Y+2	; 0x02
    2c2a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c2c:	0e 94 cc 15 	call	0x2b98	; 0x2b98 <usTaskCheckFreeStackSpace>
    2c30:	89 83       	std	Y+1, r24	; 0x01

		return uxReturn;
    2c32:	89 81       	ldd	r24, Y+1	; 0x01
	}
    2c34:	29 96       	adiw	r28, 0x09	; 9
    2c36:	0f b6       	in	r0, 0x3f	; 63
    2c38:	f8 94       	cli
    2c3a:	de bf       	out	0x3e, r29	; 62
    2c3c:	0f be       	out	0x3f, r0	; 63
    2c3e:	cd bf       	out	0x3d, r28	; 61
    2c40:	cf 91       	pop	r28
    2c42:	df 91       	pop	r29
    2c44:	08 95       	ret

00002c46 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    2c46:	df 93       	push	r29
    2c48:	cf 93       	push	r28
    2c4a:	00 d0       	rcall	.+0      	; 0x2c4c <prvDeleteTCB+0x6>
    2c4c:	cd b7       	in	r28, 0x3d	; 61
    2c4e:	de b7       	in	r29, 0x3e	; 62
    2c50:	9a 83       	std	Y+2, r25	; 0x02
    2c52:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2c54:	e9 81       	ldd	r30, Y+1	; 0x01
    2c56:	fa 81       	ldd	r31, Y+2	; 0x02
    2c58:	87 89       	ldd	r24, Z+23	; 0x17
    2c5a:	90 8d       	ldd	r25, Z+24	; 0x18
    2c5c:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <vPortFree>
		vPortFree( pxTCB );
    2c60:	89 81       	ldd	r24, Y+1	; 0x01
    2c62:	9a 81       	ldd	r25, Y+2	; 0x02
    2c64:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <vPortFree>
	}
    2c68:	0f 90       	pop	r0
    2c6a:	0f 90       	pop	r0
    2c6c:	cf 91       	pop	r28
    2c6e:	df 91       	pop	r29
    2c70:	08 95       	ret

00002c72 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
    2c72:	df 93       	push	r29
    2c74:	cf 93       	push	r28
    2c76:	00 d0       	rcall	.+0      	; 0x2c78 <xTaskGetCurrentTaskHandle+0x6>
    2c78:	cd b7       	in	r28, 0x3d	; 61
    2c7a:	de b7       	in	r29, 0x3e	; 62
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2c7c:	80 91 fc 02 	lds	r24, 0x02FC
    2c80:	90 91 fd 02 	lds	r25, 0x02FD
    2c84:	9a 83       	std	Y+2, r25	; 0x02
    2c86:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    2c88:	89 81       	ldd	r24, Y+1	; 0x01
    2c8a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    2c8c:	0f 90       	pop	r0
    2c8e:	0f 90       	pop	r0
    2c90:	cf 91       	pop	r28
    2c92:	df 91       	pop	r29
    2c94:	08 95       	ret

00002c96 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
    2c96:	df 93       	push	r29
    2c98:	cf 93       	push	r28
    2c9a:	0f 92       	push	r0
    2c9c:	cd b7       	in	r28, 0x3d	; 61
    2c9e:	de b7       	in	r29, 0x3e	; 62
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
    2ca0:	80 91 06 03 	lds	r24, 0x0306
    2ca4:	88 23       	and	r24, r24
    2ca6:	11 f4       	brne	.+4      	; 0x2cac <xTaskGetSchedulerState+0x16>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    2ca8:	19 82       	std	Y+1, r1	; 0x01
    2caa:	09 c0       	rjmp	.+18     	; 0x2cbe <xTaskGetSchedulerState+0x28>
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2cac:	80 91 07 03 	lds	r24, 0x0307
    2cb0:	88 23       	and	r24, r24
    2cb2:	19 f4       	brne	.+6      	; 0x2cba <xTaskGetSchedulerState+0x24>
			{
				xReturn = taskSCHEDULER_RUNNING;
    2cb4:	81 e0       	ldi	r24, 0x01	; 1
    2cb6:	89 83       	std	Y+1, r24	; 0x01
    2cb8:	02 c0       	rjmp	.+4      	; 0x2cbe <xTaskGetSchedulerState+0x28>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    2cba:	82 e0       	ldi	r24, 0x02	; 2
    2cbc:	89 83       	std	Y+1, r24	; 0x01
			}
		}

		return xReturn;
    2cbe:	89 81       	ldd	r24, Y+1	; 0x01
	}
    2cc0:	0f 90       	pop	r0
    2cc2:	cf 91       	pop	r28
    2cc4:	df 91       	pop	r29
    2cc6:	08 95       	ret

00002cc8 <memcpy>:
    2cc8:	fb 01       	movw	r30, r22
    2cca:	dc 01       	movw	r26, r24
    2ccc:	02 c0       	rjmp	.+4      	; 0x2cd2 <memcpy+0xa>
    2cce:	01 90       	ld	r0, Z+
    2cd0:	0d 92       	st	X+, r0
    2cd2:	41 50       	subi	r20, 0x01	; 1
    2cd4:	50 40       	sbci	r21, 0x00	; 0
    2cd6:	d8 f7       	brcc	.-10     	; 0x2cce <memcpy+0x6>
    2cd8:	08 95       	ret

00002cda <memset>:
    2cda:	dc 01       	movw	r26, r24
    2cdc:	01 c0       	rjmp	.+2      	; 0x2ce0 <memset+0x6>
    2cde:	6d 93       	st	X+, r22
    2ce0:	41 50       	subi	r20, 0x01	; 1
    2ce2:	50 40       	sbci	r21, 0x00	; 0
    2ce4:	e0 f7       	brcc	.-8      	; 0x2cde <memset+0x4>
    2ce6:	08 95       	ret

00002ce8 <strncpy>:
    2ce8:	fb 01       	movw	r30, r22
    2cea:	dc 01       	movw	r26, r24
    2cec:	41 50       	subi	r20, 0x01	; 1
    2cee:	50 40       	sbci	r21, 0x00	; 0
    2cf0:	48 f0       	brcs	.+18     	; 0x2d04 <strncpy+0x1c>
    2cf2:	01 90       	ld	r0, Z+
    2cf4:	0d 92       	st	X+, r0
    2cf6:	00 20       	and	r0, r0
    2cf8:	c9 f7       	brne	.-14     	; 0x2cec <strncpy+0x4>
    2cfa:	01 c0       	rjmp	.+2      	; 0x2cfe <strncpy+0x16>
    2cfc:	1d 92       	st	X+, r1
    2cfe:	41 50       	subi	r20, 0x01	; 1
    2d00:	50 40       	sbci	r21, 0x00	; 0
    2d02:	e0 f7       	brcc	.-8      	; 0x2cfc <strncpy+0x14>
    2d04:	08 95       	ret

00002d06 <_exit>:
    2d06:	f8 94       	cli

00002d08 <__stop_program>:
    2d08:	ff cf       	rjmp	.-2      	; 0x2d08 <__stop_program>
