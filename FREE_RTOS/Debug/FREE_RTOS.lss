
FREE_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002732  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  00002732  000027c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e5  00800068  00800068  000027ce  2**0
                  ALLOC
  3 .stab         000043a4  00000000  00000000  000027d0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002950  00000000  00000000  00006b74  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 09 08 	jmp	0x1012	; 0x1012 <__vector_6>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e3       	ldi	r30, 0x32	; 50
      68:	f7 e2       	ldi	r31, 0x27	; 39
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 36       	cpi	r26, 0x68	; 104
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a8 e6       	ldi	r26, 0x68	; 104
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ad 34       	cpi	r26, 0x4D	; 77
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 80 00 	call	0x100	; 0x100 <main>
      8a:	0c 94 97 13 	jmp	0x272e	; 0x272e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Blink_200ms_task>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <Blink_200ms_task+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	9a 83       	std	Y+2, r25	; 0x02
      9e:	89 83       	std	Y+1, r24	; 0x01
      a0:	aa e3       	ldi	r26, 0x3A	; 58
      a2:	b0 e0       	ldi	r27, 0x00	; 0
      a4:	ea e3       	ldi	r30, 0x3A	; 58
      a6:	f0 e0       	ldi	r31, 0x00	; 0
      a8:	80 81       	ld	r24, Z
      aa:	81 60       	ori	r24, 0x01	; 1
      ac:	8c 93       	st	X, r24
      ae:	ab e3       	ldi	r26, 0x3B	; 59
      b0:	b0 e0       	ldi	r27, 0x00	; 0
      b2:	eb e3       	ldi	r30, 0x3B	; 59
      b4:	f0 e0       	ldi	r31, 0x00	; 0
      b6:	90 81       	ld	r25, Z
      b8:	81 e0       	ldi	r24, 0x01	; 1
      ba:	89 27       	eor	r24, r25
      bc:	8c 93       	st	X, r24
      be:	88 ec       	ldi	r24, 0xC8	; 200
      c0:	90 e0       	ldi	r25, 0x00	; 0
      c2:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <vTaskDelay>
      c6:	f3 cf       	rjmp	.-26     	; 0xae <Blink_200ms_task+0x1c>

000000c8 <Blink_1000ms_task>:
		vTaskDelay(200); //OS Delay
	}
}
//--------------------------------------------------
void Blink_1000ms_task( void *pvParameters)
{
      c8:	df 93       	push	r29
      ca:	cf 93       	push	r28
      cc:	00 d0       	rcall	.+0      	; 0xce <Blink_1000ms_task+0x6>
      ce:	00 d0       	rcall	.+0      	; 0xd0 <Blink_1000ms_task+0x8>
      d0:	cd b7       	in	r28, 0x3d	; 61
      d2:	de b7       	in	r29, 0x3e	; 62
      d4:	9c 83       	std	Y+4, r25	; 0x04
      d6:	8b 83       	std	Y+3, r24	; 0x03
	DDRB |=(1<<0); //PB.0 is output
      d8:	a7 e3       	ldi	r26, 0x37	; 55
      da:	b0 e0       	ldi	r27, 0x00	; 0
      dc:	e7 e3       	ldi	r30, 0x37	; 55
      de:	f0 e0       	ldi	r31, 0x00	; 0
      e0:	80 81       	ld	r24, Z
      e2:	81 60       	ori	r24, 0x01	; 1
      e4:	8c 93       	st	X, r24
	portTickType gg;
	while(1)
	{

		PORTB ^= (1<<0); //toggle PB.0
      e6:	a8 e3       	ldi	r26, 0x38	; 56
      e8:	b0 e0       	ldi	r27, 0x00	; 0
      ea:	e8 e3       	ldi	r30, 0x38	; 56
      ec:	f0 e0       	ldi	r31, 0x00	; 0
      ee:	90 81       	ld	r25, Z
      f0:	81 e0       	ldi	r24, 0x01	; 1
      f2:	89 27       	eor	r24, r25
      f4:	8c 93       	st	X, r24
		vTaskDelay(1000); //OS Delay
      f6:	88 ee       	ldi	r24, 0xE8	; 232
      f8:	93 e0       	ldi	r25, 0x03	; 3
      fa:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <vTaskDelay>
      fe:	f3 cf       	rjmp	.-26     	; 0xe6 <Blink_1000ms_task+0x1e>

00000100 <main>:

//================= [Main] ====================
#include <avr/io.h>

int main(void)
{
     100:	af 92       	push	r10
     102:	bf 92       	push	r11
     104:	cf 92       	push	r12
     106:	df 92       	push	r13
     108:	ef 92       	push	r14
     10a:	ff 92       	push	r15
     10c:	0f 93       	push	r16
     10e:	df 93       	push	r29
     110:	cf 93       	push	r28
     112:	cd b7       	in	r28, 0x3d	; 61
     114:	de b7       	in	r29, 0x3e	; 62
	// Create Tasks
	xTaskCreate( Blink_200ms_task,NULL, configMINIMAL_STACK_SIZE, NULL, 2, NULL );
     116:	89 e4       	ldi	r24, 0x49	; 73
     118:	90 e0       	ldi	r25, 0x00	; 0
     11a:	60 e0       	ldi	r22, 0x00	; 0
     11c:	70 e0       	ldi	r23, 0x00	; 0
     11e:	45 e5       	ldi	r20, 0x55	; 85
     120:	50 e0       	ldi	r21, 0x00	; 0
     122:	20 e0       	ldi	r18, 0x00	; 0
     124:	30 e0       	ldi	r19, 0x00	; 0
     126:	02 e0       	ldi	r16, 0x02	; 2
     128:	ee 24       	eor	r14, r14
     12a:	ff 24       	eor	r15, r15
     12c:	cc 24       	eor	r12, r12
     12e:	dd 24       	eor	r13, r13
     130:	aa 24       	eor	r10, r10
     132:	bb 24       	eor	r11, r11
     134:	0e 94 8d 0c 	call	0x191a	; 0x191a <xTaskGenericCreate>
	xTaskCreate( Blink_1000ms_task,NULL, configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     138:	84 e6       	ldi	r24, 0x64	; 100
     13a:	90 e0       	ldi	r25, 0x00	; 0
     13c:	60 e0       	ldi	r22, 0x00	; 0
     13e:	70 e0       	ldi	r23, 0x00	; 0
     140:	45 e5       	ldi	r20, 0x55	; 85
     142:	50 e0       	ldi	r21, 0x00	; 0
     144:	20 e0       	ldi	r18, 0x00	; 0
     146:	30 e0       	ldi	r19, 0x00	; 0
     148:	01 e0       	ldi	r16, 0x01	; 1
     14a:	ee 24       	eor	r14, r14
     14c:	ff 24       	eor	r15, r15
     14e:	cc 24       	eor	r12, r12
     150:	dd 24       	eor	r13, r13
     152:	aa 24       	eor	r10, r10
     154:	bb 24       	eor	r11, r11
     156:	0e 94 8d 0c 	call	0x191a	; 0x191a <xTaskGenericCreate>
	
	// Start FreeRTOS
	vTaskStartScheduler();
     15a:	0e 94 86 0e 	call	0x1d0c	; 0x1d0c <vTaskStartScheduler>
     15e:	80 e0       	ldi	r24, 0x00	; 0
     160:	90 e0       	ldi	r25, 0x00	; 0
	
}
     162:	cf 91       	pop	r28
     164:	df 91       	pop	r29
     166:	0f 91       	pop	r16
     168:	ff 90       	pop	r15
     16a:	ef 90       	pop	r14
     16c:	df 90       	pop	r13
     16e:	cf 90       	pop	r12
     170:	bf 90       	pop	r11
     172:	af 90       	pop	r10
     174:	08 95       	ret

00000176 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     176:	df 93       	push	r29
     178:	cf 93       	push	r28
     17a:	cd b7       	in	r28, 0x3d	; 61
     17c:	de b7       	in	r29, 0x3e	; 62
     17e:	27 97       	sbiw	r28, 0x07	; 7
     180:	0f b6       	in	r0, 0x3f	; 63
     182:	f8 94       	cli
     184:	de bf       	out	0x3e, r29	; 62
     186:	0f be       	out	0x3f, r0	; 63
     188:	cd bf       	out	0x3d, r28	; 61
     18a:	9d 83       	std	Y+5, r25	; 0x05
     18c:	8c 83       	std	Y+4, r24	; 0x04
     18e:	6e 83       	std	Y+6, r22	; 0x06
     190:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     192:	8a e1       	ldi	r24, 0x1A	; 26
     194:	90 e0       	ldi	r25, 0x00	; 0
     196:	0e 94 93 03 	call	0x726	; 0x726 <pvPortMalloc>
     19a:	9a 83       	std	Y+2, r25	; 0x02
     19c:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     19e:	89 81       	ldd	r24, Y+1	; 0x01
     1a0:	9a 81       	ldd	r25, Y+2	; 0x02
     1a2:	00 97       	sbiw	r24, 0x00	; 0
     1a4:	09 f4       	brne	.+2      	; 0x1a8 <xCoRoutineCreate+0x32>
     1a6:	6f c0       	rjmp	.+222    	; 0x286 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     1a8:	80 91 68 00 	lds	r24, 0x0068
     1ac:	90 91 69 00 	lds	r25, 0x0069
     1b0:	00 97       	sbiw	r24, 0x00	; 0
     1b2:	41 f4       	brne	.+16     	; 0x1c4 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     1b4:	89 81       	ldd	r24, Y+1	; 0x01
     1b6:	9a 81       	ldd	r25, Y+2	; 0x02
     1b8:	90 93 69 00 	sts	0x0069, r25
     1bc:	80 93 68 00 	sts	0x0068, r24
			prvInitialiseCoRoutineLists();
     1c0:	0e 94 22 03 	call	0x644	; 0x644 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     1c4:	8e 81       	ldd	r24, Y+6	; 0x06
     1c6:	82 30       	cpi	r24, 0x02	; 2
     1c8:	10 f0       	brcs	.+4      	; 0x1ce <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     1ca:	81 e0       	ldi	r24, 0x01	; 1
     1cc:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     1ce:	e9 81       	ldd	r30, Y+1	; 0x01
     1d0:	fa 81       	ldd	r31, Y+2	; 0x02
     1d2:	11 8e       	std	Z+25, r1	; 0x19
     1d4:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     1d6:	e9 81       	ldd	r30, Y+1	; 0x01
     1d8:	fa 81       	ldd	r31, Y+2	; 0x02
     1da:	8e 81       	ldd	r24, Y+6	; 0x06
     1dc:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     1de:	e9 81       	ldd	r30, Y+1	; 0x01
     1e0:	fa 81       	ldd	r31, Y+2	; 0x02
     1e2:	8f 81       	ldd	r24, Y+7	; 0x07
     1e4:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     1e6:	e9 81       	ldd	r30, Y+1	; 0x01
     1e8:	fa 81       	ldd	r31, Y+2	; 0x02
     1ea:	8c 81       	ldd	r24, Y+4	; 0x04
     1ec:	9d 81       	ldd	r25, Y+5	; 0x05
     1ee:	91 83       	std	Z+1, r25	; 0x01
     1f0:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     1f2:	89 81       	ldd	r24, Y+1	; 0x01
     1f4:	9a 81       	ldd	r25, Y+2	; 0x02
     1f6:	02 96       	adiw	r24, 0x02	; 2
     1f8:	0e 94 29 04 	call	0x852	; 0x852 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     1fc:	89 81       	ldd	r24, Y+1	; 0x01
     1fe:	9a 81       	ldd	r25, Y+2	; 0x02
     200:	0c 96       	adiw	r24, 0x0c	; 12
     202:	0e 94 29 04 	call	0x852	; 0x852 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     206:	e9 81       	ldd	r30, Y+1	; 0x01
     208:	fa 81       	ldd	r31, Y+2	; 0x02
     20a:	89 81       	ldd	r24, Y+1	; 0x01
     20c:	9a 81       	ldd	r25, Y+2	; 0x02
     20e:	91 87       	std	Z+9, r25	; 0x09
     210:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     212:	e9 81       	ldd	r30, Y+1	; 0x01
     214:	fa 81       	ldd	r31, Y+2	; 0x02
     216:	89 81       	ldd	r24, Y+1	; 0x01
     218:	9a 81       	ldd	r25, Y+2	; 0x02
     21a:	93 8b       	std	Z+19, r25	; 0x13
     21c:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     21e:	8e 81       	ldd	r24, Y+6	; 0x06
     220:	28 2f       	mov	r18, r24
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	83 e0       	ldi	r24, 0x03	; 3
     226:	90 e0       	ldi	r25, 0x00	; 0
     228:	82 1b       	sub	r24, r18
     22a:	93 0b       	sbc	r25, r19
     22c:	e9 81       	ldd	r30, Y+1	; 0x01
     22e:	fa 81       	ldd	r31, Y+2	; 0x02
     230:	95 87       	std	Z+13, r25	; 0x0d
     232:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     234:	e9 81       	ldd	r30, Y+1	; 0x01
     236:	fa 81       	ldd	r31, Y+2	; 0x02
     238:	96 89       	ldd	r25, Z+22	; 0x16
     23a:	80 91 6a 00 	lds	r24, 0x006A
     23e:	89 17       	cp	r24, r25
     240:	28 f4       	brcc	.+10     	; 0x24c <xCoRoutineCreate+0xd6>
     242:	e9 81       	ldd	r30, Y+1	; 0x01
     244:	fa 81       	ldd	r31, Y+2	; 0x02
     246:	86 89       	ldd	r24, Z+22	; 0x16
     248:	80 93 6a 00 	sts	0x006A, r24
     24c:	e9 81       	ldd	r30, Y+1	; 0x01
     24e:	fa 81       	ldd	r31, Y+2	; 0x02
     250:	86 89       	ldd	r24, Z+22	; 0x16
     252:	28 2f       	mov	r18, r24
     254:	30 e0       	ldi	r19, 0x00	; 0
     256:	c9 01       	movw	r24, r18
     258:	88 0f       	add	r24, r24
     25a:	99 1f       	adc	r25, r25
     25c:	88 0f       	add	r24, r24
     25e:	99 1f       	adc	r25, r25
     260:	88 0f       	add	r24, r24
     262:	99 1f       	adc	r25, r25
     264:	82 0f       	add	r24, r18
     266:	93 1f       	adc	r25, r19
     268:	ac 01       	movw	r20, r24
     26a:	4f 58       	subi	r20, 0x8F	; 143
     26c:	5f 4f       	sbci	r21, 0xFF	; 255
     26e:	89 81       	ldd	r24, Y+1	; 0x01
     270:	9a 81       	ldd	r25, Y+2	; 0x02
     272:	9c 01       	movw	r18, r24
     274:	2e 5f       	subi	r18, 0xFE	; 254
     276:	3f 4f       	sbci	r19, 0xFF	; 255
     278:	ca 01       	movw	r24, r20
     27a:	b9 01       	movw	r22, r18
     27c:	0e 94 39 04 	call	0x872	; 0x872 <vListInsertEnd>

		xReturn = pdPASS;
     280:	81 e0       	ldi	r24, 0x01	; 1
     282:	8b 83       	std	Y+3, r24	; 0x03
     284:	02 c0       	rjmp	.+4      	; 0x28a <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     286:	8f ef       	ldi	r24, 0xFF	; 255
     288:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     28a:	8b 81       	ldd	r24, Y+3	; 0x03
}
     28c:	27 96       	adiw	r28, 0x07	; 7
     28e:	0f b6       	in	r0, 0x3f	; 63
     290:	f8 94       	cli
     292:	de bf       	out	0x3e, r29	; 62
     294:	0f be       	out	0x3f, r0	; 63
     296:	cd bf       	out	0x3d, r28	; 61
     298:	cf 91       	pop	r28
     29a:	df 91       	pop	r29
     29c:	08 95       	ret

0000029e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     29e:	df 93       	push	r29
     2a0:	cf 93       	push	r28
     2a2:	00 d0       	rcall	.+0      	; 0x2a4 <vCoRoutineAddToDelayedList+0x6>
     2a4:	00 d0       	rcall	.+0      	; 0x2a6 <vCoRoutineAddToDelayedList+0x8>
     2a6:	00 d0       	rcall	.+0      	; 0x2a8 <vCoRoutineAddToDelayedList+0xa>
     2a8:	cd b7       	in	r28, 0x3d	; 61
     2aa:	de b7       	in	r29, 0x3e	; 62
     2ac:	9c 83       	std	Y+4, r25	; 0x04
     2ae:	8b 83       	std	Y+3, r24	; 0x03
     2b0:	7e 83       	std	Y+6, r23	; 0x06
     2b2:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     2b4:	20 91 6b 00 	lds	r18, 0x006B
     2b8:	30 91 6c 00 	lds	r19, 0x006C
     2bc:	8b 81       	ldd	r24, Y+3	; 0x03
     2be:	9c 81       	ldd	r25, Y+4	; 0x04
     2c0:	82 0f       	add	r24, r18
     2c2:	93 1f       	adc	r25, r19
     2c4:	9a 83       	std	Y+2, r25	; 0x02
     2c6:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2c8:	80 91 68 00 	lds	r24, 0x0068
     2cc:	90 91 69 00 	lds	r25, 0x0069
     2d0:	02 96       	adiw	r24, 0x02	; 2
     2d2:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     2d6:	e0 91 68 00 	lds	r30, 0x0068
     2da:	f0 91 69 00 	lds	r31, 0x0069
     2de:	89 81       	ldd	r24, Y+1	; 0x01
     2e0:	9a 81       	ldd	r25, Y+2	; 0x02
     2e2:	93 83       	std	Z+3, r25	; 0x03
     2e4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     2e6:	20 91 6b 00 	lds	r18, 0x006B
     2ea:	30 91 6c 00 	lds	r19, 0x006C
     2ee:	89 81       	ldd	r24, Y+1	; 0x01
     2f0:	9a 81       	ldd	r25, Y+2	; 0x02
     2f2:	82 17       	cp	r24, r18
     2f4:	93 07       	cpc	r25, r19
     2f6:	70 f4       	brcc	.+28     	; 0x314 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2f8:	80 91 97 00 	lds	r24, 0x0097
     2fc:	90 91 98 00 	lds	r25, 0x0098
     300:	20 91 68 00 	lds	r18, 0x0068
     304:	30 91 69 00 	lds	r19, 0x0069
     308:	2e 5f       	subi	r18, 0xFE	; 254
     30a:	3f 4f       	sbci	r19, 0xFF	; 255
     30c:	b9 01       	movw	r22, r18
     30e:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsert>
     312:	0d c0       	rjmp	.+26     	; 0x32e <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     314:	80 91 95 00 	lds	r24, 0x0095
     318:	90 91 96 00 	lds	r25, 0x0096
     31c:	20 91 68 00 	lds	r18, 0x0068
     320:	30 91 69 00 	lds	r19, 0x0069
     324:	2e 5f       	subi	r18, 0xFE	; 254
     326:	3f 4f       	sbci	r19, 0xFF	; 255
     328:	b9 01       	movw	r22, r18
     32a:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsert>
	}

	if( pxEventList )
     32e:	8d 81       	ldd	r24, Y+5	; 0x05
     330:	9e 81       	ldd	r25, Y+6	; 0x06
     332:	00 97       	sbiw	r24, 0x00	; 0
     334:	61 f0       	breq	.+24     	; 0x34e <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     336:	80 91 68 00 	lds	r24, 0x0068
     33a:	90 91 69 00 	lds	r25, 0x0069
     33e:	9c 01       	movw	r18, r24
     340:	24 5f       	subi	r18, 0xF4	; 244
     342:	3f 4f       	sbci	r19, 0xFF	; 255
     344:	8d 81       	ldd	r24, Y+5	; 0x05
     346:	9e 81       	ldd	r25, Y+6	; 0x06
     348:	b9 01       	movw	r22, r18
     34a:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsert>
	}
}
     34e:	26 96       	adiw	r28, 0x06	; 6
     350:	0f b6       	in	r0, 0x3f	; 63
     352:	f8 94       	cli
     354:	de bf       	out	0x3e, r29	; 62
     356:	0f be       	out	0x3f, r0	; 63
     358:	cd bf       	out	0x3d, r28	; 61
     35a:	cf 91       	pop	r28
     35c:	df 91       	pop	r29
     35e:	08 95       	ret

00000360 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     360:	df 93       	push	r29
     362:	cf 93       	push	r28
     364:	00 d0       	rcall	.+0      	; 0x366 <prvCheckPendingReadyList+0x6>
     366:	cd b7       	in	r28, 0x3d	; 61
     368:	de b7       	in	r29, 0x3e	; 62
     36a:	3a c0       	rjmp	.+116    	; 0x3e0 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     36c:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     36e:	e0 91 9e 00 	lds	r30, 0x009E
     372:	f0 91 9f 00 	lds	r31, 0x009F
     376:	86 81       	ldd	r24, Z+6	; 0x06
     378:	97 81       	ldd	r25, Z+7	; 0x07
     37a:	9a 83       	std	Y+2, r25	; 0x02
     37c:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     37e:	89 81       	ldd	r24, Y+1	; 0x01
     380:	9a 81       	ldd	r25, Y+2	; 0x02
     382:	0c 96       	adiw	r24, 0x0c	; 12
     384:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     388:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     38a:	89 81       	ldd	r24, Y+1	; 0x01
     38c:	9a 81       	ldd	r25, Y+2	; 0x02
     38e:	02 96       	adiw	r24, 0x02	; 2
     390:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     394:	e9 81       	ldd	r30, Y+1	; 0x01
     396:	fa 81       	ldd	r31, Y+2	; 0x02
     398:	96 89       	ldd	r25, Z+22	; 0x16
     39a:	80 91 6a 00 	lds	r24, 0x006A
     39e:	89 17       	cp	r24, r25
     3a0:	28 f4       	brcc	.+10     	; 0x3ac <prvCheckPendingReadyList+0x4c>
     3a2:	e9 81       	ldd	r30, Y+1	; 0x01
     3a4:	fa 81       	ldd	r31, Y+2	; 0x02
     3a6:	86 89       	ldd	r24, Z+22	; 0x16
     3a8:	80 93 6a 00 	sts	0x006A, r24
     3ac:	e9 81       	ldd	r30, Y+1	; 0x01
     3ae:	fa 81       	ldd	r31, Y+2	; 0x02
     3b0:	86 89       	ldd	r24, Z+22	; 0x16
     3b2:	28 2f       	mov	r18, r24
     3b4:	30 e0       	ldi	r19, 0x00	; 0
     3b6:	c9 01       	movw	r24, r18
     3b8:	88 0f       	add	r24, r24
     3ba:	99 1f       	adc	r25, r25
     3bc:	88 0f       	add	r24, r24
     3be:	99 1f       	adc	r25, r25
     3c0:	88 0f       	add	r24, r24
     3c2:	99 1f       	adc	r25, r25
     3c4:	82 0f       	add	r24, r18
     3c6:	93 1f       	adc	r25, r19
     3c8:	ac 01       	movw	r20, r24
     3ca:	4f 58       	subi	r20, 0x8F	; 143
     3cc:	5f 4f       	sbci	r21, 0xFF	; 255
     3ce:	89 81       	ldd	r24, Y+1	; 0x01
     3d0:	9a 81       	ldd	r25, Y+2	; 0x02
     3d2:	9c 01       	movw	r18, r24
     3d4:	2e 5f       	subi	r18, 0xFE	; 254
     3d6:	3f 4f       	sbci	r19, 0xFF	; 255
     3d8:	ca 01       	movw	r24, r20
     3da:	b9 01       	movw	r22, r18
     3dc:	0e 94 39 04 	call	0x872	; 0x872 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     3e0:	80 91 99 00 	lds	r24, 0x0099
     3e4:	88 23       	and	r24, r24
     3e6:	09 f0       	breq	.+2      	; 0x3ea <prvCheckPendingReadyList+0x8a>
     3e8:	c1 cf       	rjmp	.-126    	; 0x36c <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     3ea:	0f 90       	pop	r0
     3ec:	0f 90       	pop	r0
     3ee:	cf 91       	pop	r28
     3f0:	df 91       	pop	r29
     3f2:	08 95       	ret

000003f4 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     3f4:	df 93       	push	r29
     3f6:	cf 93       	push	r28
     3f8:	00 d0       	rcall	.+0      	; 0x3fa <prvCheckDelayedList+0x6>
     3fa:	00 d0       	rcall	.+0      	; 0x3fc <prvCheckDelayedList+0x8>
     3fc:	cd b7       	in	r28, 0x3d	; 61
     3fe:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     400:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <xTaskGetTickCount>
     404:	20 91 6d 00 	lds	r18, 0x006D
     408:	30 91 6e 00 	lds	r19, 0x006E
     40c:	82 1b       	sub	r24, r18
     40e:	93 0b       	sbc	r25, r19
     410:	90 93 70 00 	sts	0x0070, r25
     414:	80 93 6f 00 	sts	0x006F, r24
     418:	85 c0       	rjmp	.+266    	; 0x524 <__stack+0xc5>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     41a:	80 91 6b 00 	lds	r24, 0x006B
     41e:	90 91 6c 00 	lds	r25, 0x006C
     422:	01 96       	adiw	r24, 0x01	; 1
     424:	90 93 6c 00 	sts	0x006C, r25
     428:	80 93 6b 00 	sts	0x006B, r24
		xPassedTicks--;
     42c:	80 91 6f 00 	lds	r24, 0x006F
     430:	90 91 70 00 	lds	r25, 0x0070
     434:	01 97       	sbiw	r24, 0x01	; 1
     436:	90 93 70 00 	sts	0x0070, r25
     43a:	80 93 6f 00 	sts	0x006F, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     43e:	80 91 6b 00 	lds	r24, 0x006B
     442:	90 91 6c 00 	lds	r25, 0x006C
     446:	00 97       	sbiw	r24, 0x00	; 0
     448:	09 f0       	breq	.+2      	; 0x44c <prvCheckDelayedList+0x58>
     44a:	64 c0       	rjmp	.+200    	; 0x514 <__stack+0xb5>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     44c:	80 91 95 00 	lds	r24, 0x0095
     450:	90 91 96 00 	lds	r25, 0x0096
     454:	9a 83       	std	Y+2, r25	; 0x02
     456:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     458:	80 91 97 00 	lds	r24, 0x0097
     45c:	90 91 98 00 	lds	r25, 0x0098
     460:	90 93 96 00 	sts	0x0096, r25
     464:	80 93 95 00 	sts	0x0095, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     468:	89 81       	ldd	r24, Y+1	; 0x01
     46a:	9a 81       	ldd	r25, Y+2	; 0x02
     46c:	90 93 98 00 	sts	0x0098, r25
     470:	80 93 97 00 	sts	0x0097, r24
     474:	4f c0       	rjmp	.+158    	; 0x514 <__stack+0xb5>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     476:	e0 91 95 00 	lds	r30, 0x0095
     47a:	f0 91 96 00 	lds	r31, 0x0096
     47e:	05 80       	ldd	r0, Z+5	; 0x05
     480:	f6 81       	ldd	r31, Z+6	; 0x06
     482:	e0 2d       	mov	r30, r0
     484:	86 81       	ldd	r24, Z+6	; 0x06
     486:	97 81       	ldd	r25, Z+7	; 0x07
     488:	9c 83       	std	Y+4, r25	; 0x04
     48a:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     48c:	eb 81       	ldd	r30, Y+3	; 0x03
     48e:	fc 81       	ldd	r31, Y+4	; 0x04
     490:	22 81       	ldd	r18, Z+2	; 0x02
     492:	33 81       	ldd	r19, Z+3	; 0x03
     494:	80 91 6b 00 	lds	r24, 0x006B
     498:	90 91 6c 00 	lds	r25, 0x006C
     49c:	82 17       	cp	r24, r18
     49e:	93 07       	cpc	r25, r19
     4a0:	08 f4       	brcc	.+2      	; 0x4a4 <__stack+0x45>
     4a2:	40 c0       	rjmp	.+128    	; 0x524 <__stack+0xc5>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     4a4:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     4a6:	8b 81       	ldd	r24, Y+3	; 0x03
     4a8:	9c 81       	ldd	r25, Y+4	; 0x04
     4aa:	02 96       	adiw	r24, 0x02	; 2
     4ac:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     4b0:	eb 81       	ldd	r30, Y+3	; 0x03
     4b2:	fc 81       	ldd	r31, Y+4	; 0x04
     4b4:	84 89       	ldd	r24, Z+20	; 0x14
     4b6:	95 89       	ldd	r25, Z+21	; 0x15
     4b8:	00 97       	sbiw	r24, 0x00	; 0
     4ba:	29 f0       	breq	.+10     	; 0x4c6 <__stack+0x67>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     4bc:	8b 81       	ldd	r24, Y+3	; 0x03
     4be:	9c 81       	ldd	r25, Y+4	; 0x04
     4c0:	0c 96       	adiw	r24, 0x0c	; 12
     4c2:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     4c6:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     4c8:	eb 81       	ldd	r30, Y+3	; 0x03
     4ca:	fc 81       	ldd	r31, Y+4	; 0x04
     4cc:	96 89       	ldd	r25, Z+22	; 0x16
     4ce:	80 91 6a 00 	lds	r24, 0x006A
     4d2:	89 17       	cp	r24, r25
     4d4:	28 f4       	brcc	.+10     	; 0x4e0 <__stack+0x81>
     4d6:	eb 81       	ldd	r30, Y+3	; 0x03
     4d8:	fc 81       	ldd	r31, Y+4	; 0x04
     4da:	86 89       	ldd	r24, Z+22	; 0x16
     4dc:	80 93 6a 00 	sts	0x006A, r24
     4e0:	eb 81       	ldd	r30, Y+3	; 0x03
     4e2:	fc 81       	ldd	r31, Y+4	; 0x04
     4e4:	86 89       	ldd	r24, Z+22	; 0x16
     4e6:	28 2f       	mov	r18, r24
     4e8:	30 e0       	ldi	r19, 0x00	; 0
     4ea:	c9 01       	movw	r24, r18
     4ec:	88 0f       	add	r24, r24
     4ee:	99 1f       	adc	r25, r25
     4f0:	88 0f       	add	r24, r24
     4f2:	99 1f       	adc	r25, r25
     4f4:	88 0f       	add	r24, r24
     4f6:	99 1f       	adc	r25, r25
     4f8:	82 0f       	add	r24, r18
     4fa:	93 1f       	adc	r25, r19
     4fc:	ac 01       	movw	r20, r24
     4fe:	4f 58       	subi	r20, 0x8F	; 143
     500:	5f 4f       	sbci	r21, 0xFF	; 255
     502:	8b 81       	ldd	r24, Y+3	; 0x03
     504:	9c 81       	ldd	r25, Y+4	; 0x04
     506:	9c 01       	movw	r18, r24
     508:	2e 5f       	subi	r18, 0xFE	; 254
     50a:	3f 4f       	sbci	r19, 0xFF	; 255
     50c:	ca 01       	movw	r24, r20
     50e:	b9 01       	movw	r22, r18
     510:	0e 94 39 04 	call	0x872	; 0x872 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     514:	e0 91 95 00 	lds	r30, 0x0095
     518:	f0 91 96 00 	lds	r31, 0x0096
     51c:	80 81       	ld	r24, Z
     51e:	88 23       	and	r24, r24
     520:	09 f0       	breq	.+2      	; 0x524 <__stack+0xc5>
     522:	a9 cf       	rjmp	.-174    	; 0x476 <__stack+0x17>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     524:	80 91 6f 00 	lds	r24, 0x006F
     528:	90 91 70 00 	lds	r25, 0x0070
     52c:	00 97       	sbiw	r24, 0x00	; 0
     52e:	09 f0       	breq	.+2      	; 0x532 <__stack+0xd3>
     530:	74 cf       	rjmp	.-280    	; 0x41a <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     532:	80 91 6b 00 	lds	r24, 0x006B
     536:	90 91 6c 00 	lds	r25, 0x006C
     53a:	90 93 6e 00 	sts	0x006E, r25
     53e:	80 93 6d 00 	sts	0x006D, r24
}
     542:	0f 90       	pop	r0
     544:	0f 90       	pop	r0
     546:	0f 90       	pop	r0
     548:	0f 90       	pop	r0
     54a:	cf 91       	pop	r28
     54c:	df 91       	pop	r29
     54e:	08 95       	ret

00000550 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     550:	df 93       	push	r29
     552:	cf 93       	push	r28
     554:	00 d0       	rcall	.+0      	; 0x556 <vCoRoutineSchedule+0x6>
     556:	cd b7       	in	r28, 0x3d	; 61
     558:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     55a:	0e 94 b0 01 	call	0x360	; 0x360 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     55e:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <prvCheckDelayedList>
     562:	0a c0       	rjmp	.+20     	; 0x578 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     564:	80 91 6a 00 	lds	r24, 0x006A
     568:	88 23       	and	r24, r24
     56a:	09 f4       	brne	.+2      	; 0x56e <vCoRoutineSchedule+0x1e>
     56c:	66 c0       	rjmp	.+204    	; 0x63a <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     56e:	80 91 6a 00 	lds	r24, 0x006A
     572:	81 50       	subi	r24, 0x01	; 1
     574:	80 93 6a 00 	sts	0x006A, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     578:	80 91 6a 00 	lds	r24, 0x006A
     57c:	28 2f       	mov	r18, r24
     57e:	30 e0       	ldi	r19, 0x00	; 0
     580:	c9 01       	movw	r24, r18
     582:	88 0f       	add	r24, r24
     584:	99 1f       	adc	r25, r25
     586:	88 0f       	add	r24, r24
     588:	99 1f       	adc	r25, r25
     58a:	88 0f       	add	r24, r24
     58c:	99 1f       	adc	r25, r25
     58e:	82 0f       	add	r24, r18
     590:	93 1f       	adc	r25, r19
     592:	fc 01       	movw	r30, r24
     594:	ef 58       	subi	r30, 0x8F	; 143
     596:	ff 4f       	sbci	r31, 0xFF	; 255
     598:	80 81       	ld	r24, Z
     59a:	88 23       	and	r24, r24
     59c:	19 f3       	breq	.-58     	; 0x564 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     59e:	80 91 6a 00 	lds	r24, 0x006A
     5a2:	28 2f       	mov	r18, r24
     5a4:	30 e0       	ldi	r19, 0x00	; 0
     5a6:	c9 01       	movw	r24, r18
     5a8:	88 0f       	add	r24, r24
     5aa:	99 1f       	adc	r25, r25
     5ac:	88 0f       	add	r24, r24
     5ae:	99 1f       	adc	r25, r25
     5b0:	88 0f       	add	r24, r24
     5b2:	99 1f       	adc	r25, r25
     5b4:	82 0f       	add	r24, r18
     5b6:	93 1f       	adc	r25, r19
     5b8:	8f 58       	subi	r24, 0x8F	; 143
     5ba:	9f 4f       	sbci	r25, 0xFF	; 255
     5bc:	9a 83       	std	Y+2, r25	; 0x02
     5be:	89 83       	std	Y+1, r24	; 0x01
     5c0:	e9 81       	ldd	r30, Y+1	; 0x01
     5c2:	fa 81       	ldd	r31, Y+2	; 0x02
     5c4:	01 80       	ldd	r0, Z+1	; 0x01
     5c6:	f2 81       	ldd	r31, Z+2	; 0x02
     5c8:	e0 2d       	mov	r30, r0
     5ca:	82 81       	ldd	r24, Z+2	; 0x02
     5cc:	93 81       	ldd	r25, Z+3	; 0x03
     5ce:	e9 81       	ldd	r30, Y+1	; 0x01
     5d0:	fa 81       	ldd	r31, Y+2	; 0x02
     5d2:	92 83       	std	Z+2, r25	; 0x02
     5d4:	81 83       	std	Z+1, r24	; 0x01
     5d6:	e9 81       	ldd	r30, Y+1	; 0x01
     5d8:	fa 81       	ldd	r31, Y+2	; 0x02
     5da:	21 81       	ldd	r18, Z+1	; 0x01
     5dc:	32 81       	ldd	r19, Z+2	; 0x02
     5de:	89 81       	ldd	r24, Y+1	; 0x01
     5e0:	9a 81       	ldd	r25, Y+2	; 0x02
     5e2:	03 96       	adiw	r24, 0x03	; 3
     5e4:	28 17       	cp	r18, r24
     5e6:	39 07       	cpc	r19, r25
     5e8:	59 f4       	brne	.+22     	; 0x600 <vCoRoutineSchedule+0xb0>
     5ea:	e9 81       	ldd	r30, Y+1	; 0x01
     5ec:	fa 81       	ldd	r31, Y+2	; 0x02
     5ee:	01 80       	ldd	r0, Z+1	; 0x01
     5f0:	f2 81       	ldd	r31, Z+2	; 0x02
     5f2:	e0 2d       	mov	r30, r0
     5f4:	82 81       	ldd	r24, Z+2	; 0x02
     5f6:	93 81       	ldd	r25, Z+3	; 0x03
     5f8:	e9 81       	ldd	r30, Y+1	; 0x01
     5fa:	fa 81       	ldd	r31, Y+2	; 0x02
     5fc:	92 83       	std	Z+2, r25	; 0x02
     5fe:	81 83       	std	Z+1, r24	; 0x01
     600:	e9 81       	ldd	r30, Y+1	; 0x01
     602:	fa 81       	ldd	r31, Y+2	; 0x02
     604:	01 80       	ldd	r0, Z+1	; 0x01
     606:	f2 81       	ldd	r31, Z+2	; 0x02
     608:	e0 2d       	mov	r30, r0
     60a:	86 81       	ldd	r24, Z+6	; 0x06
     60c:	97 81       	ldd	r25, Z+7	; 0x07
     60e:	90 93 69 00 	sts	0x0069, r25
     612:	80 93 68 00 	sts	0x0068, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     616:	e0 91 68 00 	lds	r30, 0x0068
     61a:	f0 91 69 00 	lds	r31, 0x0069
     61e:	40 81       	ld	r20, Z
     620:	51 81       	ldd	r21, Z+1	; 0x01
     622:	80 91 68 00 	lds	r24, 0x0068
     626:	90 91 69 00 	lds	r25, 0x0069
     62a:	e0 91 68 00 	lds	r30, 0x0068
     62e:	f0 91 69 00 	lds	r31, 0x0069
     632:	27 89       	ldd	r18, Z+23	; 0x17
     634:	62 2f       	mov	r22, r18
     636:	fa 01       	movw	r30, r20
     638:	09 95       	icall

	return;
}
     63a:	0f 90       	pop	r0
     63c:	0f 90       	pop	r0
     63e:	cf 91       	pop	r28
     640:	df 91       	pop	r29
     642:	08 95       	ret

00000644 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     644:	df 93       	push	r29
     646:	cf 93       	push	r28
     648:	0f 92       	push	r0
     64a:	cd b7       	in	r28, 0x3d	; 61
     64c:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     64e:	19 82       	std	Y+1, r1	; 0x01
     650:	13 c0       	rjmp	.+38     	; 0x678 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     652:	89 81       	ldd	r24, Y+1	; 0x01
     654:	28 2f       	mov	r18, r24
     656:	30 e0       	ldi	r19, 0x00	; 0
     658:	c9 01       	movw	r24, r18
     65a:	88 0f       	add	r24, r24
     65c:	99 1f       	adc	r25, r25
     65e:	88 0f       	add	r24, r24
     660:	99 1f       	adc	r25, r25
     662:	88 0f       	add	r24, r24
     664:	99 1f       	adc	r25, r25
     666:	82 0f       	add	r24, r18
     668:	93 1f       	adc	r25, r19
     66a:	8f 58       	subi	r24, 0x8F	; 143
     66c:	9f 4f       	sbci	r25, 0xFF	; 255
     66e:	0e 94 ff 03 	call	0x7fe	; 0x7fe <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     672:	89 81       	ldd	r24, Y+1	; 0x01
     674:	8f 5f       	subi	r24, 0xFF	; 255
     676:	89 83       	std	Y+1, r24	; 0x01
     678:	89 81       	ldd	r24, Y+1	; 0x01
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	50 f3       	brcs	.-44     	; 0x652 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     67e:	83 e8       	ldi	r24, 0x83	; 131
     680:	90 e0       	ldi	r25, 0x00	; 0
     682:	0e 94 ff 03 	call	0x7fe	; 0x7fe <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     686:	8c e8       	ldi	r24, 0x8C	; 140
     688:	90 e0       	ldi	r25, 0x00	; 0
     68a:	0e 94 ff 03 	call	0x7fe	; 0x7fe <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     68e:	89 e9       	ldi	r24, 0x99	; 153
     690:	90 e0       	ldi	r25, 0x00	; 0
     692:	0e 94 ff 03 	call	0x7fe	; 0x7fe <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     696:	83 e8       	ldi	r24, 0x83	; 131
     698:	90 e0       	ldi	r25, 0x00	; 0
     69a:	90 93 96 00 	sts	0x0096, r25
     69e:	80 93 95 00 	sts	0x0095, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     6a2:	8c e8       	ldi	r24, 0x8C	; 140
     6a4:	90 e0       	ldi	r25, 0x00	; 0
     6a6:	90 93 98 00 	sts	0x0098, r25
     6aa:	80 93 97 00 	sts	0x0097, r24
}
     6ae:	0f 90       	pop	r0
     6b0:	cf 91       	pop	r28
     6b2:	df 91       	pop	r29
     6b4:	08 95       	ret

000006b6 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     6b6:	df 93       	push	r29
     6b8:	cf 93       	push	r28
     6ba:	00 d0       	rcall	.+0      	; 0x6bc <xCoRoutineRemoveFromEventList+0x6>
     6bc:	00 d0       	rcall	.+0      	; 0x6be <xCoRoutineRemoveFromEventList+0x8>
     6be:	0f 92       	push	r0
     6c0:	cd b7       	in	r28, 0x3d	; 61
     6c2:	de b7       	in	r29, 0x3e	; 62
     6c4:	9d 83       	std	Y+5, r25	; 0x05
     6c6:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     6c8:	ec 81       	ldd	r30, Y+4	; 0x04
     6ca:	fd 81       	ldd	r31, Y+5	; 0x05
     6cc:	05 80       	ldd	r0, Z+5	; 0x05
     6ce:	f6 81       	ldd	r31, Z+6	; 0x06
     6d0:	e0 2d       	mov	r30, r0
     6d2:	86 81       	ldd	r24, Z+6	; 0x06
     6d4:	97 81       	ldd	r25, Z+7	; 0x07
     6d6:	9b 83       	std	Y+3, r25	; 0x03
     6d8:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     6da:	8a 81       	ldd	r24, Y+2	; 0x02
     6dc:	9b 81       	ldd	r25, Y+3	; 0x03
     6de:	0c 96       	adiw	r24, 0x0c	; 12
     6e0:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     6e4:	8a 81       	ldd	r24, Y+2	; 0x02
     6e6:	9b 81       	ldd	r25, Y+3	; 0x03
     6e8:	9c 01       	movw	r18, r24
     6ea:	24 5f       	subi	r18, 0xF4	; 244
     6ec:	3f 4f       	sbci	r19, 0xFF	; 255
     6ee:	89 e9       	ldi	r24, 0x99	; 153
     6f0:	90 e0       	ldi	r25, 0x00	; 0
     6f2:	b9 01       	movw	r22, r18
     6f4:	0e 94 39 04 	call	0x872	; 0x872 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     6f8:	ea 81       	ldd	r30, Y+2	; 0x02
     6fa:	fb 81       	ldd	r31, Y+3	; 0x03
     6fc:	96 89       	ldd	r25, Z+22	; 0x16
     6fe:	e0 91 68 00 	lds	r30, 0x0068
     702:	f0 91 69 00 	lds	r31, 0x0069
     706:	86 89       	ldd	r24, Z+22	; 0x16
     708:	98 17       	cp	r25, r24
     70a:	18 f0       	brcs	.+6      	; 0x712 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     70c:	81 e0       	ldi	r24, 0x01	; 1
     70e:	89 83       	std	Y+1, r24	; 0x01
     710:	01 c0       	rjmp	.+2      	; 0x714 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     712:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     714:	89 81       	ldd	r24, Y+1	; 0x01
}
     716:	0f 90       	pop	r0
     718:	0f 90       	pop	r0
     71a:	0f 90       	pop	r0
     71c:	0f 90       	pop	r0
     71e:	0f 90       	pop	r0
     720:	cf 91       	pop	r28
     722:	df 91       	pop	r29
     724:	08 95       	ret

00000726 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     726:	df 93       	push	r29
     728:	cf 93       	push	r28
     72a:	00 d0       	rcall	.+0      	; 0x72c <pvPortMalloc+0x6>
     72c:	00 d0       	rcall	.+0      	; 0x72e <pvPortMalloc+0x8>
     72e:	cd b7       	in	r28, 0x3d	; 61
     730:	de b7       	in	r29, 0x3e	; 62
     732:	9c 83       	std	Y+4, r25	; 0x04
     734:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     736:	1a 82       	std	Y+2, r1	; 0x02
     738:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     73a:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     73e:	80 91 a2 00 	lds	r24, 0x00A2
     742:	90 91 a3 00 	lds	r25, 0x00A3
     746:	2b 81       	ldd	r18, Y+3	; 0x03
     748:	3c 81       	ldd	r19, Y+4	; 0x04
     74a:	82 0f       	add	r24, r18
     74c:	93 1f       	adc	r25, r19
     74e:	22 e0       	ldi	r18, 0x02	; 2
     750:	88 35       	cpi	r24, 0x58	; 88
     752:	92 07       	cpc	r25, r18
     754:	18 f5       	brcc	.+70     	; 0x79c <pvPortMalloc+0x76>
     756:	20 91 a2 00 	lds	r18, 0x00A2
     75a:	30 91 a3 00 	lds	r19, 0x00A3
     75e:	8b 81       	ldd	r24, Y+3	; 0x03
     760:	9c 81       	ldd	r25, Y+4	; 0x04
     762:	28 0f       	add	r18, r24
     764:	39 1f       	adc	r19, r25
     766:	80 91 a2 00 	lds	r24, 0x00A2
     76a:	90 91 a3 00 	lds	r25, 0x00A3
     76e:	82 17       	cp	r24, r18
     770:	93 07       	cpc	r25, r19
     772:	a0 f4       	brcc	.+40     	; 0x79c <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     774:	80 91 a2 00 	lds	r24, 0x00A2
     778:	90 91 a3 00 	lds	r25, 0x00A3
     77c:	8c 55       	subi	r24, 0x5C	; 92
     77e:	9f 4f       	sbci	r25, 0xFF	; 255
     780:	9a 83       	std	Y+2, r25	; 0x02
     782:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     784:	20 91 a2 00 	lds	r18, 0x00A2
     788:	30 91 a3 00 	lds	r19, 0x00A3
     78c:	8b 81       	ldd	r24, Y+3	; 0x03
     78e:	9c 81       	ldd	r25, Y+4	; 0x04
     790:	82 0f       	add	r24, r18
     792:	93 1f       	adc	r25, r19
     794:	90 93 a3 00 	sts	0x00A3, r25
     798:	80 93 a2 00 	sts	0x00A2, r24
		}	
	}
	xTaskResumeAll();
     79c:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     7a0:	89 81       	ldd	r24, Y+1	; 0x01
     7a2:	9a 81       	ldd	r25, Y+2	; 0x02
}
     7a4:	0f 90       	pop	r0
     7a6:	0f 90       	pop	r0
     7a8:	0f 90       	pop	r0
     7aa:	0f 90       	pop	r0
     7ac:	cf 91       	pop	r28
     7ae:	df 91       	pop	r29
     7b0:	08 95       	ret

000007b2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     7b2:	df 93       	push	r29
     7b4:	cf 93       	push	r28
     7b6:	00 d0       	rcall	.+0      	; 0x7b8 <vPortFree+0x6>
     7b8:	cd b7       	in	r28, 0x3d	; 61
     7ba:	de b7       	in	r29, 0x3e	; 62
     7bc:	9a 83       	std	Y+2, r25	; 0x02
     7be:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     7c0:	0f 90       	pop	r0
     7c2:	0f 90       	pop	r0
     7c4:	cf 91       	pop	r28
     7c6:	df 91       	pop	r29
     7c8:	08 95       	ret

000007ca <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     7ca:	df 93       	push	r29
     7cc:	cf 93       	push	r28
     7ce:	cd b7       	in	r28, 0x3d	; 61
     7d0:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     7d2:	10 92 a3 00 	sts	0x00A3, r1
     7d6:	10 92 a2 00 	sts	0x00A2, r1
}
     7da:	cf 91       	pop	r28
     7dc:	df 91       	pop	r29
     7de:	08 95       	ret

000007e0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     7e0:	df 93       	push	r29
     7e2:	cf 93       	push	r28
     7e4:	cd b7       	in	r28, 0x3d	; 61
     7e6:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     7e8:	20 91 a2 00 	lds	r18, 0x00A2
     7ec:	30 91 a3 00 	lds	r19, 0x00A3
     7f0:	88 e5       	ldi	r24, 0x58	; 88
     7f2:	92 e0       	ldi	r25, 0x02	; 2
     7f4:	82 1b       	sub	r24, r18
     7f6:	93 0b       	sbc	r25, r19
}
     7f8:	cf 91       	pop	r28
     7fa:	df 91       	pop	r29
     7fc:	08 95       	ret

000007fe <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     7fe:	df 93       	push	r29
     800:	cf 93       	push	r28
     802:	00 d0       	rcall	.+0      	; 0x804 <vListInitialise+0x6>
     804:	cd b7       	in	r28, 0x3d	; 61
     806:	de b7       	in	r29, 0x3e	; 62
     808:	9a 83       	std	Y+2, r25	; 0x02
     80a:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     80c:	89 81       	ldd	r24, Y+1	; 0x01
     80e:	9a 81       	ldd	r25, Y+2	; 0x02
     810:	03 96       	adiw	r24, 0x03	; 3
     812:	e9 81       	ldd	r30, Y+1	; 0x01
     814:	fa 81       	ldd	r31, Y+2	; 0x02
     816:	92 83       	std	Z+2, r25	; 0x02
     818:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     81a:	e9 81       	ldd	r30, Y+1	; 0x01
     81c:	fa 81       	ldd	r31, Y+2	; 0x02
     81e:	8f ef       	ldi	r24, 0xFF	; 255
     820:	9f ef       	ldi	r25, 0xFF	; 255
     822:	94 83       	std	Z+4, r25	; 0x04
     824:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     826:	89 81       	ldd	r24, Y+1	; 0x01
     828:	9a 81       	ldd	r25, Y+2	; 0x02
     82a:	03 96       	adiw	r24, 0x03	; 3
     82c:	e9 81       	ldd	r30, Y+1	; 0x01
     82e:	fa 81       	ldd	r31, Y+2	; 0x02
     830:	96 83       	std	Z+6, r25	; 0x06
     832:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     834:	89 81       	ldd	r24, Y+1	; 0x01
     836:	9a 81       	ldd	r25, Y+2	; 0x02
     838:	03 96       	adiw	r24, 0x03	; 3
     83a:	e9 81       	ldd	r30, Y+1	; 0x01
     83c:	fa 81       	ldd	r31, Y+2	; 0x02
     83e:	90 87       	std	Z+8, r25	; 0x08
     840:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     842:	e9 81       	ldd	r30, Y+1	; 0x01
     844:	fa 81       	ldd	r31, Y+2	; 0x02
     846:	10 82       	st	Z, r1
}
     848:	0f 90       	pop	r0
     84a:	0f 90       	pop	r0
     84c:	cf 91       	pop	r28
     84e:	df 91       	pop	r29
     850:	08 95       	ret

00000852 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     852:	df 93       	push	r29
     854:	cf 93       	push	r28
     856:	00 d0       	rcall	.+0      	; 0x858 <vListInitialiseItem+0x6>
     858:	cd b7       	in	r28, 0x3d	; 61
     85a:	de b7       	in	r29, 0x3e	; 62
     85c:	9a 83       	std	Y+2, r25	; 0x02
     85e:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     860:	e9 81       	ldd	r30, Y+1	; 0x01
     862:	fa 81       	ldd	r31, Y+2	; 0x02
     864:	11 86       	std	Z+9, r1	; 0x09
     866:	10 86       	std	Z+8, r1	; 0x08
}
     868:	0f 90       	pop	r0
     86a:	0f 90       	pop	r0
     86c:	cf 91       	pop	r28
     86e:	df 91       	pop	r29
     870:	08 95       	ret

00000872 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     872:	df 93       	push	r29
     874:	cf 93       	push	r28
     876:	00 d0       	rcall	.+0      	; 0x878 <vListInsertEnd+0x6>
     878:	00 d0       	rcall	.+0      	; 0x87a <vListInsertEnd+0x8>
     87a:	00 d0       	rcall	.+0      	; 0x87c <vListInsertEnd+0xa>
     87c:	cd b7       	in	r28, 0x3d	; 61
     87e:	de b7       	in	r29, 0x3e	; 62
     880:	9c 83       	std	Y+4, r25	; 0x04
     882:	8b 83       	std	Y+3, r24	; 0x03
     884:	7e 83       	std	Y+6, r23	; 0x06
     886:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     888:	eb 81       	ldd	r30, Y+3	; 0x03
     88a:	fc 81       	ldd	r31, Y+4	; 0x04
     88c:	81 81       	ldd	r24, Z+1	; 0x01
     88e:	92 81       	ldd	r25, Z+2	; 0x02
     890:	9a 83       	std	Y+2, r25	; 0x02
     892:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     894:	e9 81       	ldd	r30, Y+1	; 0x01
     896:	fa 81       	ldd	r31, Y+2	; 0x02
     898:	82 81       	ldd	r24, Z+2	; 0x02
     89a:	93 81       	ldd	r25, Z+3	; 0x03
     89c:	ed 81       	ldd	r30, Y+5	; 0x05
     89e:	fe 81       	ldd	r31, Y+6	; 0x06
     8a0:	93 83       	std	Z+3, r25	; 0x03
     8a2:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     8a4:	eb 81       	ldd	r30, Y+3	; 0x03
     8a6:	fc 81       	ldd	r31, Y+4	; 0x04
     8a8:	81 81       	ldd	r24, Z+1	; 0x01
     8aa:	92 81       	ldd	r25, Z+2	; 0x02
     8ac:	ed 81       	ldd	r30, Y+5	; 0x05
     8ae:	fe 81       	ldd	r31, Y+6	; 0x06
     8b0:	95 83       	std	Z+5, r25	; 0x05
     8b2:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     8b4:	e9 81       	ldd	r30, Y+1	; 0x01
     8b6:	fa 81       	ldd	r31, Y+2	; 0x02
     8b8:	02 80       	ldd	r0, Z+2	; 0x02
     8ba:	f3 81       	ldd	r31, Z+3	; 0x03
     8bc:	e0 2d       	mov	r30, r0
     8be:	8d 81       	ldd	r24, Y+5	; 0x05
     8c0:	9e 81       	ldd	r25, Y+6	; 0x06
     8c2:	95 83       	std	Z+5, r25	; 0x05
     8c4:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     8c6:	8d 81       	ldd	r24, Y+5	; 0x05
     8c8:	9e 81       	ldd	r25, Y+6	; 0x06
     8ca:	e9 81       	ldd	r30, Y+1	; 0x01
     8cc:	fa 81       	ldd	r31, Y+2	; 0x02
     8ce:	93 83       	std	Z+3, r25	; 0x03
     8d0:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     8d2:	8d 81       	ldd	r24, Y+5	; 0x05
     8d4:	9e 81       	ldd	r25, Y+6	; 0x06
     8d6:	eb 81       	ldd	r30, Y+3	; 0x03
     8d8:	fc 81       	ldd	r31, Y+4	; 0x04
     8da:	92 83       	std	Z+2, r25	; 0x02
     8dc:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8de:	ed 81       	ldd	r30, Y+5	; 0x05
     8e0:	fe 81       	ldd	r31, Y+6	; 0x06
     8e2:	8b 81       	ldd	r24, Y+3	; 0x03
     8e4:	9c 81       	ldd	r25, Y+4	; 0x04
     8e6:	91 87       	std	Z+9, r25	; 0x09
     8e8:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8ea:	eb 81       	ldd	r30, Y+3	; 0x03
     8ec:	fc 81       	ldd	r31, Y+4	; 0x04
     8ee:	80 81       	ld	r24, Z
     8f0:	8f 5f       	subi	r24, 0xFF	; 255
     8f2:	eb 81       	ldd	r30, Y+3	; 0x03
     8f4:	fc 81       	ldd	r31, Y+4	; 0x04
     8f6:	80 83       	st	Z, r24
}
     8f8:	26 96       	adiw	r28, 0x06	; 6
     8fa:	0f b6       	in	r0, 0x3f	; 63
     8fc:	f8 94       	cli
     8fe:	de bf       	out	0x3e, r29	; 62
     900:	0f be       	out	0x3f, r0	; 63
     902:	cd bf       	out	0x3d, r28	; 61
     904:	cf 91       	pop	r28
     906:	df 91       	pop	r29
     908:	08 95       	ret

0000090a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     90a:	df 93       	push	r29
     90c:	cf 93       	push	r28
     90e:	cd b7       	in	r28, 0x3d	; 61
     910:	de b7       	in	r29, 0x3e	; 62
     912:	28 97       	sbiw	r28, 0x08	; 8
     914:	0f b6       	in	r0, 0x3f	; 63
     916:	f8 94       	cli
     918:	de bf       	out	0x3e, r29	; 62
     91a:	0f be       	out	0x3f, r0	; 63
     91c:	cd bf       	out	0x3d, r28	; 61
     91e:	9e 83       	std	Y+6, r25	; 0x06
     920:	8d 83       	std	Y+5, r24	; 0x05
     922:	78 87       	std	Y+8, r23	; 0x08
     924:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     926:	ef 81       	ldd	r30, Y+7	; 0x07
     928:	f8 85       	ldd	r31, Y+8	; 0x08
     92a:	80 81       	ld	r24, Z
     92c:	91 81       	ldd	r25, Z+1	; 0x01
     92e:	9a 83       	std	Y+2, r25	; 0x02
     930:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     932:	89 81       	ldd	r24, Y+1	; 0x01
     934:	9a 81       	ldd	r25, Y+2	; 0x02
     936:	2f ef       	ldi	r18, 0xFF	; 255
     938:	8f 3f       	cpi	r24, 0xFF	; 255
     93a:	92 07       	cpc	r25, r18
     93c:	39 f4       	brne	.+14     	; 0x94c <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     93e:	ed 81       	ldd	r30, Y+5	; 0x05
     940:	fe 81       	ldd	r31, Y+6	; 0x06
     942:	87 81       	ldd	r24, Z+7	; 0x07
     944:	90 85       	ldd	r25, Z+8	; 0x08
     946:	9c 83       	std	Y+4, r25	; 0x04
     948:	8b 83       	std	Y+3, r24	; 0x03
     94a:	18 c0       	rjmp	.+48     	; 0x97c <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     94c:	8d 81       	ldd	r24, Y+5	; 0x05
     94e:	9e 81       	ldd	r25, Y+6	; 0x06
     950:	03 96       	adiw	r24, 0x03	; 3
     952:	9c 83       	std	Y+4, r25	; 0x04
     954:	8b 83       	std	Y+3, r24	; 0x03
     956:	06 c0       	rjmp	.+12     	; 0x964 <vListInsert+0x5a>
     958:	eb 81       	ldd	r30, Y+3	; 0x03
     95a:	fc 81       	ldd	r31, Y+4	; 0x04
     95c:	82 81       	ldd	r24, Z+2	; 0x02
     95e:	93 81       	ldd	r25, Z+3	; 0x03
     960:	9c 83       	std	Y+4, r25	; 0x04
     962:	8b 83       	std	Y+3, r24	; 0x03
     964:	eb 81       	ldd	r30, Y+3	; 0x03
     966:	fc 81       	ldd	r31, Y+4	; 0x04
     968:	02 80       	ldd	r0, Z+2	; 0x02
     96a:	f3 81       	ldd	r31, Z+3	; 0x03
     96c:	e0 2d       	mov	r30, r0
     96e:	20 81       	ld	r18, Z
     970:	31 81       	ldd	r19, Z+1	; 0x01
     972:	89 81       	ldd	r24, Y+1	; 0x01
     974:	9a 81       	ldd	r25, Y+2	; 0x02
     976:	82 17       	cp	r24, r18
     978:	93 07       	cpc	r25, r19
     97a:	70 f7       	brcc	.-36     	; 0x958 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     97c:	eb 81       	ldd	r30, Y+3	; 0x03
     97e:	fc 81       	ldd	r31, Y+4	; 0x04
     980:	82 81       	ldd	r24, Z+2	; 0x02
     982:	93 81       	ldd	r25, Z+3	; 0x03
     984:	ef 81       	ldd	r30, Y+7	; 0x07
     986:	f8 85       	ldd	r31, Y+8	; 0x08
     988:	93 83       	std	Z+3, r25	; 0x03
     98a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     98c:	ef 81       	ldd	r30, Y+7	; 0x07
     98e:	f8 85       	ldd	r31, Y+8	; 0x08
     990:	02 80       	ldd	r0, Z+2	; 0x02
     992:	f3 81       	ldd	r31, Z+3	; 0x03
     994:	e0 2d       	mov	r30, r0
     996:	8f 81       	ldd	r24, Y+7	; 0x07
     998:	98 85       	ldd	r25, Y+8	; 0x08
     99a:	95 83       	std	Z+5, r25	; 0x05
     99c:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     99e:	ef 81       	ldd	r30, Y+7	; 0x07
     9a0:	f8 85       	ldd	r31, Y+8	; 0x08
     9a2:	8b 81       	ldd	r24, Y+3	; 0x03
     9a4:	9c 81       	ldd	r25, Y+4	; 0x04
     9a6:	95 83       	std	Z+5, r25	; 0x05
     9a8:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     9aa:	8f 81       	ldd	r24, Y+7	; 0x07
     9ac:	98 85       	ldd	r25, Y+8	; 0x08
     9ae:	eb 81       	ldd	r30, Y+3	; 0x03
     9b0:	fc 81       	ldd	r31, Y+4	; 0x04
     9b2:	93 83       	std	Z+3, r25	; 0x03
     9b4:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9b6:	ef 81       	ldd	r30, Y+7	; 0x07
     9b8:	f8 85       	ldd	r31, Y+8	; 0x08
     9ba:	8d 81       	ldd	r24, Y+5	; 0x05
     9bc:	9e 81       	ldd	r25, Y+6	; 0x06
     9be:	91 87       	std	Z+9, r25	; 0x09
     9c0:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     9c2:	ed 81       	ldd	r30, Y+5	; 0x05
     9c4:	fe 81       	ldd	r31, Y+6	; 0x06
     9c6:	80 81       	ld	r24, Z
     9c8:	8f 5f       	subi	r24, 0xFF	; 255
     9ca:	ed 81       	ldd	r30, Y+5	; 0x05
     9cc:	fe 81       	ldd	r31, Y+6	; 0x06
     9ce:	80 83       	st	Z, r24
}
     9d0:	28 96       	adiw	r28, 0x08	; 8
     9d2:	0f b6       	in	r0, 0x3f	; 63
     9d4:	f8 94       	cli
     9d6:	de bf       	out	0x3e, r29	; 62
     9d8:	0f be       	out	0x3f, r0	; 63
     9da:	cd bf       	out	0x3d, r28	; 61
     9dc:	cf 91       	pop	r28
     9de:	df 91       	pop	r29
     9e0:	08 95       	ret

000009e2 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     9e2:	df 93       	push	r29
     9e4:	cf 93       	push	r28
     9e6:	00 d0       	rcall	.+0      	; 0x9e8 <vListRemove+0x6>
     9e8:	00 d0       	rcall	.+0      	; 0x9ea <vListRemove+0x8>
     9ea:	cd b7       	in	r28, 0x3d	; 61
     9ec:	de b7       	in	r29, 0x3e	; 62
     9ee:	9c 83       	std	Y+4, r25	; 0x04
     9f0:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     9f2:	eb 81       	ldd	r30, Y+3	; 0x03
     9f4:	fc 81       	ldd	r31, Y+4	; 0x04
     9f6:	a2 81       	ldd	r26, Z+2	; 0x02
     9f8:	b3 81       	ldd	r27, Z+3	; 0x03
     9fa:	eb 81       	ldd	r30, Y+3	; 0x03
     9fc:	fc 81       	ldd	r31, Y+4	; 0x04
     9fe:	84 81       	ldd	r24, Z+4	; 0x04
     a00:	95 81       	ldd	r25, Z+5	; 0x05
     a02:	15 96       	adiw	r26, 0x05	; 5
     a04:	9c 93       	st	X, r25
     a06:	8e 93       	st	-X, r24
     a08:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a0a:	eb 81       	ldd	r30, Y+3	; 0x03
     a0c:	fc 81       	ldd	r31, Y+4	; 0x04
     a0e:	a4 81       	ldd	r26, Z+4	; 0x04
     a10:	b5 81       	ldd	r27, Z+5	; 0x05
     a12:	eb 81       	ldd	r30, Y+3	; 0x03
     a14:	fc 81       	ldd	r31, Y+4	; 0x04
     a16:	82 81       	ldd	r24, Z+2	; 0x02
     a18:	93 81       	ldd	r25, Z+3	; 0x03
     a1a:	13 96       	adiw	r26, 0x03	; 3
     a1c:	9c 93       	st	X, r25
     a1e:	8e 93       	st	-X, r24
     a20:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     a22:	eb 81       	ldd	r30, Y+3	; 0x03
     a24:	fc 81       	ldd	r31, Y+4	; 0x04
     a26:	80 85       	ldd	r24, Z+8	; 0x08
     a28:	91 85       	ldd	r25, Z+9	; 0x09
     a2a:	9a 83       	std	Y+2, r25	; 0x02
     a2c:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a2e:	e9 81       	ldd	r30, Y+1	; 0x01
     a30:	fa 81       	ldd	r31, Y+2	; 0x02
     a32:	21 81       	ldd	r18, Z+1	; 0x01
     a34:	32 81       	ldd	r19, Z+2	; 0x02
     a36:	8b 81       	ldd	r24, Y+3	; 0x03
     a38:	9c 81       	ldd	r25, Y+4	; 0x04
     a3a:	28 17       	cp	r18, r24
     a3c:	39 07       	cpc	r19, r25
     a3e:	41 f4       	brne	.+16     	; 0xa50 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a40:	eb 81       	ldd	r30, Y+3	; 0x03
     a42:	fc 81       	ldd	r31, Y+4	; 0x04
     a44:	84 81       	ldd	r24, Z+4	; 0x04
     a46:	95 81       	ldd	r25, Z+5	; 0x05
     a48:	e9 81       	ldd	r30, Y+1	; 0x01
     a4a:	fa 81       	ldd	r31, Y+2	; 0x02
     a4c:	92 83       	std	Z+2, r25	; 0x02
     a4e:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     a50:	eb 81       	ldd	r30, Y+3	; 0x03
     a52:	fc 81       	ldd	r31, Y+4	; 0x04
     a54:	11 86       	std	Z+9, r1	; 0x09
     a56:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a58:	e9 81       	ldd	r30, Y+1	; 0x01
     a5a:	fa 81       	ldd	r31, Y+2	; 0x02
     a5c:	80 81       	ld	r24, Z
     a5e:	81 50       	subi	r24, 0x01	; 1
     a60:	e9 81       	ldd	r30, Y+1	; 0x01
     a62:	fa 81       	ldd	r31, Y+2	; 0x02
     a64:	80 83       	st	Z, r24
}
     a66:	0f 90       	pop	r0
     a68:	0f 90       	pop	r0
     a6a:	0f 90       	pop	r0
     a6c:	0f 90       	pop	r0
     a6e:	cf 91       	pop	r28
     a70:	df 91       	pop	r29
     a72:	08 95       	ret

00000a74 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     a74:	df 93       	push	r29
     a76:	cf 93       	push	r28
     a78:	cd b7       	in	r28, 0x3d	; 61
     a7a:	de b7       	in	r29, 0x3e	; 62
     a7c:	28 97       	sbiw	r28, 0x08	; 8
     a7e:	0f b6       	in	r0, 0x3f	; 63
     a80:	f8 94       	cli
     a82:	de bf       	out	0x3e, r29	; 62
     a84:	0f be       	out	0x3f, r0	; 63
     a86:	cd bf       	out	0x3d, r28	; 61
     a88:	9c 83       	std	Y+4, r25	; 0x04
     a8a:	8b 83       	std	Y+3, r24	; 0x03
     a8c:	7e 83       	std	Y+6, r23	; 0x06
     a8e:	6d 83       	std	Y+5, r22	; 0x05
     a90:	58 87       	std	Y+8, r21	; 0x08
     a92:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     a94:	eb 81       	ldd	r30, Y+3	; 0x03
     a96:	fc 81       	ldd	r31, Y+4	; 0x04
     a98:	81 e1       	ldi	r24, 0x11	; 17
     a9a:	80 83       	st	Z, r24
	pxTopOfStack--;
     a9c:	8b 81       	ldd	r24, Y+3	; 0x03
     a9e:	9c 81       	ldd	r25, Y+4	; 0x04
     aa0:	01 97       	sbiw	r24, 0x01	; 1
     aa2:	9c 83       	std	Y+4, r25	; 0x04
     aa4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     aa6:	eb 81       	ldd	r30, Y+3	; 0x03
     aa8:	fc 81       	ldd	r31, Y+4	; 0x04
     aaa:	82 e2       	ldi	r24, 0x22	; 34
     aac:	80 83       	st	Z, r24
	pxTopOfStack--;
     aae:	8b 81       	ldd	r24, Y+3	; 0x03
     ab0:	9c 81       	ldd	r25, Y+4	; 0x04
     ab2:	01 97       	sbiw	r24, 0x01	; 1
     ab4:	9c 83       	std	Y+4, r25	; 0x04
     ab6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     ab8:	eb 81       	ldd	r30, Y+3	; 0x03
     aba:	fc 81       	ldd	r31, Y+4	; 0x04
     abc:	83 e3       	ldi	r24, 0x33	; 51
     abe:	80 83       	st	Z, r24
	pxTopOfStack--;
     ac0:	8b 81       	ldd	r24, Y+3	; 0x03
     ac2:	9c 81       	ldd	r25, Y+4	; 0x04
     ac4:	01 97       	sbiw	r24, 0x01	; 1
     ac6:	9c 83       	std	Y+4, r25	; 0x04
     ac8:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     aca:	8d 81       	ldd	r24, Y+5	; 0x05
     acc:	9e 81       	ldd	r25, Y+6	; 0x06
     ace:	9a 83       	std	Y+2, r25	; 0x02
     ad0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     ad2:	89 81       	ldd	r24, Y+1	; 0x01
     ad4:	eb 81       	ldd	r30, Y+3	; 0x03
     ad6:	fc 81       	ldd	r31, Y+4	; 0x04
     ad8:	80 83       	st	Z, r24
	pxTopOfStack--;
     ada:	8b 81       	ldd	r24, Y+3	; 0x03
     adc:	9c 81       	ldd	r25, Y+4	; 0x04
     ade:	01 97       	sbiw	r24, 0x01	; 1
     ae0:	9c 83       	std	Y+4, r25	; 0x04
     ae2:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     ae4:	89 81       	ldd	r24, Y+1	; 0x01
     ae6:	9a 81       	ldd	r25, Y+2	; 0x02
     ae8:	89 2f       	mov	r24, r25
     aea:	99 27       	eor	r25, r25
     aec:	9a 83       	std	Y+2, r25	; 0x02
     aee:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     af0:	89 81       	ldd	r24, Y+1	; 0x01
     af2:	eb 81       	ldd	r30, Y+3	; 0x03
     af4:	fc 81       	ldd	r31, Y+4	; 0x04
     af6:	80 83       	st	Z, r24
	pxTopOfStack--;
     af8:	8b 81       	ldd	r24, Y+3	; 0x03
     afa:	9c 81       	ldd	r25, Y+4	; 0x04
     afc:	01 97       	sbiw	r24, 0x01	; 1
     afe:	9c 83       	std	Y+4, r25	; 0x04
     b00:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     b02:	eb 81       	ldd	r30, Y+3	; 0x03
     b04:	fc 81       	ldd	r31, Y+4	; 0x04
     b06:	10 82       	st	Z, r1
	pxTopOfStack--;
     b08:	8b 81       	ldd	r24, Y+3	; 0x03
     b0a:	9c 81       	ldd	r25, Y+4	; 0x04
     b0c:	01 97       	sbiw	r24, 0x01	; 1
     b0e:	9c 83       	std	Y+4, r25	; 0x04
     b10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     b12:	eb 81       	ldd	r30, Y+3	; 0x03
     b14:	fc 81       	ldd	r31, Y+4	; 0x04
     b16:	80 e8       	ldi	r24, 0x80	; 128
     b18:	80 83       	st	Z, r24
	pxTopOfStack--;
     b1a:	8b 81       	ldd	r24, Y+3	; 0x03
     b1c:	9c 81       	ldd	r25, Y+4	; 0x04
     b1e:	01 97       	sbiw	r24, 0x01	; 1
     b20:	9c 83       	std	Y+4, r25	; 0x04
     b22:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     b24:	eb 81       	ldd	r30, Y+3	; 0x03
     b26:	fc 81       	ldd	r31, Y+4	; 0x04
     b28:	10 82       	st	Z, r1
	pxTopOfStack--;
     b2a:	8b 81       	ldd	r24, Y+3	; 0x03
     b2c:	9c 81       	ldd	r25, Y+4	; 0x04
     b2e:	01 97       	sbiw	r24, 0x01	; 1
     b30:	9c 83       	std	Y+4, r25	; 0x04
     b32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     b34:	eb 81       	ldd	r30, Y+3	; 0x03
     b36:	fc 81       	ldd	r31, Y+4	; 0x04
     b38:	82 e0       	ldi	r24, 0x02	; 2
     b3a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b3c:	8b 81       	ldd	r24, Y+3	; 0x03
     b3e:	9c 81       	ldd	r25, Y+4	; 0x04
     b40:	01 97       	sbiw	r24, 0x01	; 1
     b42:	9c 83       	std	Y+4, r25	; 0x04
     b44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     b46:	eb 81       	ldd	r30, Y+3	; 0x03
     b48:	fc 81       	ldd	r31, Y+4	; 0x04
     b4a:	83 e0       	ldi	r24, 0x03	; 3
     b4c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b4e:	8b 81       	ldd	r24, Y+3	; 0x03
     b50:	9c 81       	ldd	r25, Y+4	; 0x04
     b52:	01 97       	sbiw	r24, 0x01	; 1
     b54:	9c 83       	std	Y+4, r25	; 0x04
     b56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     b58:	eb 81       	ldd	r30, Y+3	; 0x03
     b5a:	fc 81       	ldd	r31, Y+4	; 0x04
     b5c:	84 e0       	ldi	r24, 0x04	; 4
     b5e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b60:	8b 81       	ldd	r24, Y+3	; 0x03
     b62:	9c 81       	ldd	r25, Y+4	; 0x04
     b64:	01 97       	sbiw	r24, 0x01	; 1
     b66:	9c 83       	std	Y+4, r25	; 0x04
     b68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     b6a:	eb 81       	ldd	r30, Y+3	; 0x03
     b6c:	fc 81       	ldd	r31, Y+4	; 0x04
     b6e:	85 e0       	ldi	r24, 0x05	; 5
     b70:	80 83       	st	Z, r24
	pxTopOfStack--;
     b72:	8b 81       	ldd	r24, Y+3	; 0x03
     b74:	9c 81       	ldd	r25, Y+4	; 0x04
     b76:	01 97       	sbiw	r24, 0x01	; 1
     b78:	9c 83       	std	Y+4, r25	; 0x04
     b7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     b7c:	eb 81       	ldd	r30, Y+3	; 0x03
     b7e:	fc 81       	ldd	r31, Y+4	; 0x04
     b80:	86 e0       	ldi	r24, 0x06	; 6
     b82:	80 83       	st	Z, r24
	pxTopOfStack--;
     b84:	8b 81       	ldd	r24, Y+3	; 0x03
     b86:	9c 81       	ldd	r25, Y+4	; 0x04
     b88:	01 97       	sbiw	r24, 0x01	; 1
     b8a:	9c 83       	std	Y+4, r25	; 0x04
     b8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     b8e:	eb 81       	ldd	r30, Y+3	; 0x03
     b90:	fc 81       	ldd	r31, Y+4	; 0x04
     b92:	87 e0       	ldi	r24, 0x07	; 7
     b94:	80 83       	st	Z, r24
	pxTopOfStack--;
     b96:	8b 81       	ldd	r24, Y+3	; 0x03
     b98:	9c 81       	ldd	r25, Y+4	; 0x04
     b9a:	01 97       	sbiw	r24, 0x01	; 1
     b9c:	9c 83       	std	Y+4, r25	; 0x04
     b9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     ba0:	eb 81       	ldd	r30, Y+3	; 0x03
     ba2:	fc 81       	ldd	r31, Y+4	; 0x04
     ba4:	88 e0       	ldi	r24, 0x08	; 8
     ba6:	80 83       	st	Z, r24
	pxTopOfStack--;
     ba8:	8b 81       	ldd	r24, Y+3	; 0x03
     baa:	9c 81       	ldd	r25, Y+4	; 0x04
     bac:	01 97       	sbiw	r24, 0x01	; 1
     bae:	9c 83       	std	Y+4, r25	; 0x04
     bb0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     bb2:	eb 81       	ldd	r30, Y+3	; 0x03
     bb4:	fc 81       	ldd	r31, Y+4	; 0x04
     bb6:	89 e0       	ldi	r24, 0x09	; 9
     bb8:	80 83       	st	Z, r24
	pxTopOfStack--;
     bba:	8b 81       	ldd	r24, Y+3	; 0x03
     bbc:	9c 81       	ldd	r25, Y+4	; 0x04
     bbe:	01 97       	sbiw	r24, 0x01	; 1
     bc0:	9c 83       	std	Y+4, r25	; 0x04
     bc2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     bc4:	eb 81       	ldd	r30, Y+3	; 0x03
     bc6:	fc 81       	ldd	r31, Y+4	; 0x04
     bc8:	80 e1       	ldi	r24, 0x10	; 16
     bca:	80 83       	st	Z, r24
	pxTopOfStack--;
     bcc:	8b 81       	ldd	r24, Y+3	; 0x03
     bce:	9c 81       	ldd	r25, Y+4	; 0x04
     bd0:	01 97       	sbiw	r24, 0x01	; 1
     bd2:	9c 83       	std	Y+4, r25	; 0x04
     bd4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     bd6:	eb 81       	ldd	r30, Y+3	; 0x03
     bd8:	fc 81       	ldd	r31, Y+4	; 0x04
     bda:	81 e1       	ldi	r24, 0x11	; 17
     bdc:	80 83       	st	Z, r24
	pxTopOfStack--;
     bde:	8b 81       	ldd	r24, Y+3	; 0x03
     be0:	9c 81       	ldd	r25, Y+4	; 0x04
     be2:	01 97       	sbiw	r24, 0x01	; 1
     be4:	9c 83       	std	Y+4, r25	; 0x04
     be6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     be8:	eb 81       	ldd	r30, Y+3	; 0x03
     bea:	fc 81       	ldd	r31, Y+4	; 0x04
     bec:	82 e1       	ldi	r24, 0x12	; 18
     bee:	80 83       	st	Z, r24
	pxTopOfStack--;
     bf0:	8b 81       	ldd	r24, Y+3	; 0x03
     bf2:	9c 81       	ldd	r25, Y+4	; 0x04
     bf4:	01 97       	sbiw	r24, 0x01	; 1
     bf6:	9c 83       	std	Y+4, r25	; 0x04
     bf8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     bfa:	eb 81       	ldd	r30, Y+3	; 0x03
     bfc:	fc 81       	ldd	r31, Y+4	; 0x04
     bfe:	83 e1       	ldi	r24, 0x13	; 19
     c00:	80 83       	st	Z, r24
	pxTopOfStack--;
     c02:	8b 81       	ldd	r24, Y+3	; 0x03
     c04:	9c 81       	ldd	r25, Y+4	; 0x04
     c06:	01 97       	sbiw	r24, 0x01	; 1
     c08:	9c 83       	std	Y+4, r25	; 0x04
     c0a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     c0c:	eb 81       	ldd	r30, Y+3	; 0x03
     c0e:	fc 81       	ldd	r31, Y+4	; 0x04
     c10:	84 e1       	ldi	r24, 0x14	; 20
     c12:	80 83       	st	Z, r24
	pxTopOfStack--;
     c14:	8b 81       	ldd	r24, Y+3	; 0x03
     c16:	9c 81       	ldd	r25, Y+4	; 0x04
     c18:	01 97       	sbiw	r24, 0x01	; 1
     c1a:	9c 83       	std	Y+4, r25	; 0x04
     c1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     c1e:	eb 81       	ldd	r30, Y+3	; 0x03
     c20:	fc 81       	ldd	r31, Y+4	; 0x04
     c22:	85 e1       	ldi	r24, 0x15	; 21
     c24:	80 83       	st	Z, r24
	pxTopOfStack--;
     c26:	8b 81       	ldd	r24, Y+3	; 0x03
     c28:	9c 81       	ldd	r25, Y+4	; 0x04
     c2a:	01 97       	sbiw	r24, 0x01	; 1
     c2c:	9c 83       	std	Y+4, r25	; 0x04
     c2e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     c30:	eb 81       	ldd	r30, Y+3	; 0x03
     c32:	fc 81       	ldd	r31, Y+4	; 0x04
     c34:	86 e1       	ldi	r24, 0x16	; 22
     c36:	80 83       	st	Z, r24
	pxTopOfStack--;
     c38:	8b 81       	ldd	r24, Y+3	; 0x03
     c3a:	9c 81       	ldd	r25, Y+4	; 0x04
     c3c:	01 97       	sbiw	r24, 0x01	; 1
     c3e:	9c 83       	std	Y+4, r25	; 0x04
     c40:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     c42:	eb 81       	ldd	r30, Y+3	; 0x03
     c44:	fc 81       	ldd	r31, Y+4	; 0x04
     c46:	87 e1       	ldi	r24, 0x17	; 23
     c48:	80 83       	st	Z, r24
	pxTopOfStack--;
     c4a:	8b 81       	ldd	r24, Y+3	; 0x03
     c4c:	9c 81       	ldd	r25, Y+4	; 0x04
     c4e:	01 97       	sbiw	r24, 0x01	; 1
     c50:	9c 83       	std	Y+4, r25	; 0x04
     c52:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     c54:	eb 81       	ldd	r30, Y+3	; 0x03
     c56:	fc 81       	ldd	r31, Y+4	; 0x04
     c58:	88 e1       	ldi	r24, 0x18	; 24
     c5a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c5c:	8b 81       	ldd	r24, Y+3	; 0x03
     c5e:	9c 81       	ldd	r25, Y+4	; 0x04
     c60:	01 97       	sbiw	r24, 0x01	; 1
     c62:	9c 83       	std	Y+4, r25	; 0x04
     c64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     c66:	eb 81       	ldd	r30, Y+3	; 0x03
     c68:	fc 81       	ldd	r31, Y+4	; 0x04
     c6a:	89 e1       	ldi	r24, 0x19	; 25
     c6c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c6e:	8b 81       	ldd	r24, Y+3	; 0x03
     c70:	9c 81       	ldd	r25, Y+4	; 0x04
     c72:	01 97       	sbiw	r24, 0x01	; 1
     c74:	9c 83       	std	Y+4, r25	; 0x04
     c76:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     c78:	eb 81       	ldd	r30, Y+3	; 0x03
     c7a:	fc 81       	ldd	r31, Y+4	; 0x04
     c7c:	80 e2       	ldi	r24, 0x20	; 32
     c7e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c80:	8b 81       	ldd	r24, Y+3	; 0x03
     c82:	9c 81       	ldd	r25, Y+4	; 0x04
     c84:	01 97       	sbiw	r24, 0x01	; 1
     c86:	9c 83       	std	Y+4, r25	; 0x04
     c88:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     c8a:	eb 81       	ldd	r30, Y+3	; 0x03
     c8c:	fc 81       	ldd	r31, Y+4	; 0x04
     c8e:	81 e2       	ldi	r24, 0x21	; 33
     c90:	80 83       	st	Z, r24
	pxTopOfStack--;
     c92:	8b 81       	ldd	r24, Y+3	; 0x03
     c94:	9c 81       	ldd	r25, Y+4	; 0x04
     c96:	01 97       	sbiw	r24, 0x01	; 1
     c98:	9c 83       	std	Y+4, r25	; 0x04
     c9a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     c9c:	eb 81       	ldd	r30, Y+3	; 0x03
     c9e:	fc 81       	ldd	r31, Y+4	; 0x04
     ca0:	82 e2       	ldi	r24, 0x22	; 34
     ca2:	80 83       	st	Z, r24
	pxTopOfStack--;
     ca4:	8b 81       	ldd	r24, Y+3	; 0x03
     ca6:	9c 81       	ldd	r25, Y+4	; 0x04
     ca8:	01 97       	sbiw	r24, 0x01	; 1
     caa:	9c 83       	std	Y+4, r25	; 0x04
     cac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     cae:	eb 81       	ldd	r30, Y+3	; 0x03
     cb0:	fc 81       	ldd	r31, Y+4	; 0x04
     cb2:	83 e2       	ldi	r24, 0x23	; 35
     cb4:	80 83       	st	Z, r24
	pxTopOfStack--;
     cb6:	8b 81       	ldd	r24, Y+3	; 0x03
     cb8:	9c 81       	ldd	r25, Y+4	; 0x04
     cba:	01 97       	sbiw	r24, 0x01	; 1
     cbc:	9c 83       	std	Y+4, r25	; 0x04
     cbe:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     cc0:	8f 81       	ldd	r24, Y+7	; 0x07
     cc2:	98 85       	ldd	r25, Y+8	; 0x08
     cc4:	9a 83       	std	Y+2, r25	; 0x02
     cc6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     cc8:	89 81       	ldd	r24, Y+1	; 0x01
     cca:	eb 81       	ldd	r30, Y+3	; 0x03
     ccc:	fc 81       	ldd	r31, Y+4	; 0x04
     cce:	80 83       	st	Z, r24
	pxTopOfStack--;
     cd0:	8b 81       	ldd	r24, Y+3	; 0x03
     cd2:	9c 81       	ldd	r25, Y+4	; 0x04
     cd4:	01 97       	sbiw	r24, 0x01	; 1
     cd6:	9c 83       	std	Y+4, r25	; 0x04
     cd8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     cda:	89 81       	ldd	r24, Y+1	; 0x01
     cdc:	9a 81       	ldd	r25, Y+2	; 0x02
     cde:	89 2f       	mov	r24, r25
     ce0:	99 27       	eor	r25, r25
     ce2:	9a 83       	std	Y+2, r25	; 0x02
     ce4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     ce6:	89 81       	ldd	r24, Y+1	; 0x01
     ce8:	eb 81       	ldd	r30, Y+3	; 0x03
     cea:	fc 81       	ldd	r31, Y+4	; 0x04
     cec:	80 83       	st	Z, r24
	pxTopOfStack--;
     cee:	8b 81       	ldd	r24, Y+3	; 0x03
     cf0:	9c 81       	ldd	r25, Y+4	; 0x04
     cf2:	01 97       	sbiw	r24, 0x01	; 1
     cf4:	9c 83       	std	Y+4, r25	; 0x04
     cf6:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     cf8:	eb 81       	ldd	r30, Y+3	; 0x03
     cfa:	fc 81       	ldd	r31, Y+4	; 0x04
     cfc:	86 e2       	ldi	r24, 0x26	; 38
     cfe:	80 83       	st	Z, r24
	pxTopOfStack--;
     d00:	8b 81       	ldd	r24, Y+3	; 0x03
     d02:	9c 81       	ldd	r25, Y+4	; 0x04
     d04:	01 97       	sbiw	r24, 0x01	; 1
     d06:	9c 83       	std	Y+4, r25	; 0x04
     d08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     d0a:	eb 81       	ldd	r30, Y+3	; 0x03
     d0c:	fc 81       	ldd	r31, Y+4	; 0x04
     d0e:	87 e2       	ldi	r24, 0x27	; 39
     d10:	80 83       	st	Z, r24
	pxTopOfStack--;
     d12:	8b 81       	ldd	r24, Y+3	; 0x03
     d14:	9c 81       	ldd	r25, Y+4	; 0x04
     d16:	01 97       	sbiw	r24, 0x01	; 1
     d18:	9c 83       	std	Y+4, r25	; 0x04
     d1a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     d1c:	eb 81       	ldd	r30, Y+3	; 0x03
     d1e:	fc 81       	ldd	r31, Y+4	; 0x04
     d20:	88 e2       	ldi	r24, 0x28	; 40
     d22:	80 83       	st	Z, r24
	pxTopOfStack--;
     d24:	8b 81       	ldd	r24, Y+3	; 0x03
     d26:	9c 81       	ldd	r25, Y+4	; 0x04
     d28:	01 97       	sbiw	r24, 0x01	; 1
     d2a:	9c 83       	std	Y+4, r25	; 0x04
     d2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     d2e:	eb 81       	ldd	r30, Y+3	; 0x03
     d30:	fc 81       	ldd	r31, Y+4	; 0x04
     d32:	89 e2       	ldi	r24, 0x29	; 41
     d34:	80 83       	st	Z, r24
	pxTopOfStack--;
     d36:	8b 81       	ldd	r24, Y+3	; 0x03
     d38:	9c 81       	ldd	r25, Y+4	; 0x04
     d3a:	01 97       	sbiw	r24, 0x01	; 1
     d3c:	9c 83       	std	Y+4, r25	; 0x04
     d3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     d40:	eb 81       	ldd	r30, Y+3	; 0x03
     d42:	fc 81       	ldd	r31, Y+4	; 0x04
     d44:	80 e3       	ldi	r24, 0x30	; 48
     d46:	80 83       	st	Z, r24
	pxTopOfStack--;
     d48:	8b 81       	ldd	r24, Y+3	; 0x03
     d4a:	9c 81       	ldd	r25, Y+4	; 0x04
     d4c:	01 97       	sbiw	r24, 0x01	; 1
     d4e:	9c 83       	std	Y+4, r25	; 0x04
     d50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     d52:	eb 81       	ldd	r30, Y+3	; 0x03
     d54:	fc 81       	ldd	r31, Y+4	; 0x04
     d56:	81 e3       	ldi	r24, 0x31	; 49
     d58:	80 83       	st	Z, r24
	pxTopOfStack--;
     d5a:	8b 81       	ldd	r24, Y+3	; 0x03
     d5c:	9c 81       	ldd	r25, Y+4	; 0x04
     d5e:	01 97       	sbiw	r24, 0x01	; 1
     d60:	9c 83       	std	Y+4, r25	; 0x04
     d62:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     d64:	8b 81       	ldd	r24, Y+3	; 0x03
     d66:	9c 81       	ldd	r25, Y+4	; 0x04
}
     d68:	28 96       	adiw	r28, 0x08	; 8
     d6a:	0f b6       	in	r0, 0x3f	; 63
     d6c:	f8 94       	cli
     d6e:	de bf       	out	0x3e, r29	; 62
     d70:	0f be       	out	0x3f, r0	; 63
     d72:	cd bf       	out	0x3d, r28	; 61
     d74:	cf 91       	pop	r28
     d76:	df 91       	pop	r29
     d78:	08 95       	ret

00000d7a <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     d7a:	df 93       	push	r29
     d7c:	cf 93       	push	r28
     d7e:	cd b7       	in	r28, 0x3d	; 61
     d80:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     d82:	0e 94 ad 07 	call	0xf5a	; 0xf5a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     d86:	a0 91 fc 02 	lds	r26, 0x02FC
     d8a:	b0 91 fd 02 	lds	r27, 0x02FD
     d8e:	cd 91       	ld	r28, X+
     d90:	cd bf       	out	0x3d, r28	; 61
     d92:	dd 91       	ld	r29, X+
     d94:	de bf       	out	0x3e, r29	; 62
     d96:	ff 91       	pop	r31
     d98:	ef 91       	pop	r30
     d9a:	df 91       	pop	r29
     d9c:	cf 91       	pop	r28
     d9e:	bf 91       	pop	r27
     da0:	af 91       	pop	r26
     da2:	9f 91       	pop	r25
     da4:	8f 91       	pop	r24
     da6:	7f 91       	pop	r23
     da8:	6f 91       	pop	r22
     daa:	5f 91       	pop	r21
     dac:	4f 91       	pop	r20
     dae:	3f 91       	pop	r19
     db0:	2f 91       	pop	r18
     db2:	1f 91       	pop	r17
     db4:	0f 91       	pop	r16
     db6:	ff 90       	pop	r15
     db8:	ef 90       	pop	r14
     dba:	df 90       	pop	r13
     dbc:	cf 90       	pop	r12
     dbe:	bf 90       	pop	r11
     dc0:	af 90       	pop	r10
     dc2:	9f 90       	pop	r9
     dc4:	8f 90       	pop	r8
     dc6:	7f 90       	pop	r7
     dc8:	6f 90       	pop	r6
     dca:	5f 90       	pop	r5
     dcc:	4f 90       	pop	r4
     dce:	3f 90       	pop	r3
     dd0:	2f 90       	pop	r2
     dd2:	1f 90       	pop	r1
     dd4:	0f 90       	pop	r0
     dd6:	0f be       	out	0x3f, r0	; 63
     dd8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     dda:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     ddc:	81 e0       	ldi	r24, 0x01	; 1
}
     dde:	cf 91       	pop	r28
     de0:	df 91       	pop	r29
     de2:	08 95       	ret

00000de4 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     de4:	df 93       	push	r29
     de6:	cf 93       	push	r28
     de8:	cd b7       	in	r28, 0x3d	; 61
     dea:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     dec:	cf 91       	pop	r28
     dee:	df 91       	pop	r29
     df0:	08 95       	ret

00000df2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     df2:	0f 92       	push	r0
     df4:	0f b6       	in	r0, 0x3f	; 63
     df6:	f8 94       	cli
     df8:	0f 92       	push	r0
     dfa:	1f 92       	push	r1
     dfc:	11 24       	eor	r1, r1
     dfe:	2f 92       	push	r2
     e00:	3f 92       	push	r3
     e02:	4f 92       	push	r4
     e04:	5f 92       	push	r5
     e06:	6f 92       	push	r6
     e08:	7f 92       	push	r7
     e0a:	8f 92       	push	r8
     e0c:	9f 92       	push	r9
     e0e:	af 92       	push	r10
     e10:	bf 92       	push	r11
     e12:	cf 92       	push	r12
     e14:	df 92       	push	r13
     e16:	ef 92       	push	r14
     e18:	ff 92       	push	r15
     e1a:	0f 93       	push	r16
     e1c:	1f 93       	push	r17
     e1e:	2f 93       	push	r18
     e20:	3f 93       	push	r19
     e22:	4f 93       	push	r20
     e24:	5f 93       	push	r21
     e26:	6f 93       	push	r22
     e28:	7f 93       	push	r23
     e2a:	8f 93       	push	r24
     e2c:	9f 93       	push	r25
     e2e:	af 93       	push	r26
     e30:	bf 93       	push	r27
     e32:	cf 93       	push	r28
     e34:	df 93       	push	r29
     e36:	ef 93       	push	r30
     e38:	ff 93       	push	r31
     e3a:	a0 91 fc 02 	lds	r26, 0x02FC
     e3e:	b0 91 fd 02 	lds	r27, 0x02FD
     e42:	0d b6       	in	r0, 0x3d	; 61
     e44:	0d 92       	st	X+, r0
     e46:	0e b6       	in	r0, 0x3e	; 62
     e48:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e4a:	0e 94 69 10 	call	0x20d2	; 0x20d2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e4e:	a0 91 fc 02 	lds	r26, 0x02FC
     e52:	b0 91 fd 02 	lds	r27, 0x02FD
     e56:	cd 91       	ld	r28, X+
     e58:	cd bf       	out	0x3d, r28	; 61
     e5a:	dd 91       	ld	r29, X+
     e5c:	de bf       	out	0x3e, r29	; 62
     e5e:	ff 91       	pop	r31
     e60:	ef 91       	pop	r30
     e62:	df 91       	pop	r29
     e64:	cf 91       	pop	r28
     e66:	bf 91       	pop	r27
     e68:	af 91       	pop	r26
     e6a:	9f 91       	pop	r25
     e6c:	8f 91       	pop	r24
     e6e:	7f 91       	pop	r23
     e70:	6f 91       	pop	r22
     e72:	5f 91       	pop	r21
     e74:	4f 91       	pop	r20
     e76:	3f 91       	pop	r19
     e78:	2f 91       	pop	r18
     e7a:	1f 91       	pop	r17
     e7c:	0f 91       	pop	r16
     e7e:	ff 90       	pop	r15
     e80:	ef 90       	pop	r14
     e82:	df 90       	pop	r13
     e84:	cf 90       	pop	r12
     e86:	bf 90       	pop	r11
     e88:	af 90       	pop	r10
     e8a:	9f 90       	pop	r9
     e8c:	8f 90       	pop	r8
     e8e:	7f 90       	pop	r7
     e90:	6f 90       	pop	r6
     e92:	5f 90       	pop	r5
     e94:	4f 90       	pop	r4
     e96:	3f 90       	pop	r3
     e98:	2f 90       	pop	r2
     e9a:	1f 90       	pop	r1
     e9c:	0f 90       	pop	r0
     e9e:	0f be       	out	0x3f, r0	; 63
     ea0:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ea2:	08 95       	ret

00000ea4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     ea4:	0f 92       	push	r0
     ea6:	0f b6       	in	r0, 0x3f	; 63
     ea8:	f8 94       	cli
     eaa:	0f 92       	push	r0
     eac:	1f 92       	push	r1
     eae:	11 24       	eor	r1, r1
     eb0:	2f 92       	push	r2
     eb2:	3f 92       	push	r3
     eb4:	4f 92       	push	r4
     eb6:	5f 92       	push	r5
     eb8:	6f 92       	push	r6
     eba:	7f 92       	push	r7
     ebc:	8f 92       	push	r8
     ebe:	9f 92       	push	r9
     ec0:	af 92       	push	r10
     ec2:	bf 92       	push	r11
     ec4:	cf 92       	push	r12
     ec6:	df 92       	push	r13
     ec8:	ef 92       	push	r14
     eca:	ff 92       	push	r15
     ecc:	0f 93       	push	r16
     ece:	1f 93       	push	r17
     ed0:	2f 93       	push	r18
     ed2:	3f 93       	push	r19
     ed4:	4f 93       	push	r20
     ed6:	5f 93       	push	r21
     ed8:	6f 93       	push	r22
     eda:	7f 93       	push	r23
     edc:	8f 93       	push	r24
     ede:	9f 93       	push	r25
     ee0:	af 93       	push	r26
     ee2:	bf 93       	push	r27
     ee4:	cf 93       	push	r28
     ee6:	df 93       	push	r29
     ee8:	ef 93       	push	r30
     eea:	ff 93       	push	r31
     eec:	a0 91 fc 02 	lds	r26, 0x02FC
     ef0:	b0 91 fd 02 	lds	r27, 0x02FD
     ef4:	0d b6       	in	r0, 0x3d	; 61
     ef6:	0d 92       	st	X+, r0
     ef8:	0e b6       	in	r0, 0x3e	; 62
     efa:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     efc:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <vTaskIncrementTick>
	vTaskSwitchContext();
     f00:	0e 94 69 10 	call	0x20d2	; 0x20d2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f04:	a0 91 fc 02 	lds	r26, 0x02FC
     f08:	b0 91 fd 02 	lds	r27, 0x02FD
     f0c:	cd 91       	ld	r28, X+
     f0e:	cd bf       	out	0x3d, r28	; 61
     f10:	dd 91       	ld	r29, X+
     f12:	de bf       	out	0x3e, r29	; 62
     f14:	ff 91       	pop	r31
     f16:	ef 91       	pop	r30
     f18:	df 91       	pop	r29
     f1a:	cf 91       	pop	r28
     f1c:	bf 91       	pop	r27
     f1e:	af 91       	pop	r26
     f20:	9f 91       	pop	r25
     f22:	8f 91       	pop	r24
     f24:	7f 91       	pop	r23
     f26:	6f 91       	pop	r22
     f28:	5f 91       	pop	r21
     f2a:	4f 91       	pop	r20
     f2c:	3f 91       	pop	r19
     f2e:	2f 91       	pop	r18
     f30:	1f 91       	pop	r17
     f32:	0f 91       	pop	r16
     f34:	ff 90       	pop	r15
     f36:	ef 90       	pop	r14
     f38:	df 90       	pop	r13
     f3a:	cf 90       	pop	r12
     f3c:	bf 90       	pop	r11
     f3e:	af 90       	pop	r10
     f40:	9f 90       	pop	r9
     f42:	8f 90       	pop	r8
     f44:	7f 90       	pop	r7
     f46:	6f 90       	pop	r6
     f48:	5f 90       	pop	r5
     f4a:	4f 90       	pop	r4
     f4c:	3f 90       	pop	r3
     f4e:	2f 90       	pop	r2
     f50:	1f 90       	pop	r1
     f52:	0f 90       	pop	r0
     f54:	0f be       	out	0x3f, r0	; 63
     f56:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f58:	08 95       	ret

00000f5a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     f5a:	df 93       	push	r29
     f5c:	cf 93       	push	r28
     f5e:	00 d0       	rcall	.+0      	; 0xf60 <prvSetupTimerInterrupt+0x6>
     f60:	00 d0       	rcall	.+0      	; 0xf62 <prvSetupTimerInterrupt+0x8>
     f62:	00 d0       	rcall	.+0      	; 0xf64 <prvSetupTimerInterrupt+0xa>
     f64:	cd b7       	in	r28, 0x3d	; 61
     f66:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     f68:	88 ee       	ldi	r24, 0xE8	; 232
     f6a:	93 e0       	ldi	r25, 0x03	; 3
     f6c:	a0 e0       	ldi	r26, 0x00	; 0
     f6e:	b0 e0       	ldi	r27, 0x00	; 0
     f70:	8b 83       	std	Y+3, r24	; 0x03
     f72:	9c 83       	std	Y+4, r25	; 0x04
     f74:	ad 83       	std	Y+5, r26	; 0x05
     f76:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     f78:	8b 81       	ldd	r24, Y+3	; 0x03
     f7a:	9c 81       	ldd	r25, Y+4	; 0x04
     f7c:	ad 81       	ldd	r26, Y+5	; 0x05
     f7e:	be 81       	ldd	r27, Y+6	; 0x06
     f80:	68 94       	set
     f82:	15 f8       	bld	r1, 5
     f84:	b6 95       	lsr	r27
     f86:	a7 95       	ror	r26
     f88:	97 95       	ror	r25
     f8a:	87 95       	ror	r24
     f8c:	16 94       	lsr	r1
     f8e:	d1 f7       	brne	.-12     	; 0xf84 <prvSetupTimerInterrupt+0x2a>
     f90:	8b 83       	std	Y+3, r24	; 0x03
     f92:	9c 83       	std	Y+4, r25	; 0x04
     f94:	ad 83       	std	Y+5, r26	; 0x05
     f96:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
     f98:	8b 81       	ldd	r24, Y+3	; 0x03
     f9a:	9c 81       	ldd	r25, Y+4	; 0x04
     f9c:	ad 81       	ldd	r26, Y+5	; 0x05
     f9e:	be 81       	ldd	r27, Y+6	; 0x06
     fa0:	01 97       	sbiw	r24, 0x01	; 1
     fa2:	a1 09       	sbc	r26, r1
     fa4:	b1 09       	sbc	r27, r1
     fa6:	8b 83       	std	Y+3, r24	; 0x03
     fa8:	9c 83       	std	Y+4, r25	; 0x04
     faa:	ad 83       	std	Y+5, r26	; 0x05
     fac:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     fae:	8b 81       	ldd	r24, Y+3	; 0x03
     fb0:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     fb2:	8b 81       	ldd	r24, Y+3	; 0x03
     fb4:	9c 81       	ldd	r25, Y+4	; 0x04
     fb6:	ad 81       	ldd	r26, Y+5	; 0x05
     fb8:	be 81       	ldd	r27, Y+6	; 0x06
     fba:	89 2f       	mov	r24, r25
     fbc:	9a 2f       	mov	r25, r26
     fbe:	ab 2f       	mov	r26, r27
     fc0:	bb 27       	eor	r27, r27
     fc2:	8b 83       	std	Y+3, r24	; 0x03
     fc4:	9c 83       	std	Y+4, r25	; 0x04
     fc6:	ad 83       	std	Y+5, r26	; 0x05
     fc8:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     fca:	8b 81       	ldd	r24, Y+3	; 0x03
     fcc:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     fce:	eb e4       	ldi	r30, 0x4B	; 75
     fd0:	f0 e0       	ldi	r31, 0x00	; 0
     fd2:	8a 81       	ldd	r24, Y+2	; 0x02
     fd4:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     fd6:	ea e4       	ldi	r30, 0x4A	; 74
     fd8:	f0 e0       	ldi	r31, 0x00	; 0
     fda:	89 81       	ldd	r24, Y+1	; 0x01
     fdc:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     fde:	8b e0       	ldi	r24, 0x0B	; 11
     fe0:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     fe2:	ee e4       	ldi	r30, 0x4E	; 78
     fe4:	f0 e0       	ldi	r31, 0x00	; 0
     fe6:	89 81       	ldd	r24, Y+1	; 0x01
     fe8:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     fea:	e9 e5       	ldi	r30, 0x59	; 89
     fec:	f0 e0       	ldi	r31, 0x00	; 0
     fee:	80 81       	ld	r24, Z
     ff0:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     ff2:	89 81       	ldd	r24, Y+1	; 0x01
     ff4:	80 61       	ori	r24, 0x10	; 16
     ff6:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     ff8:	e9 e5       	ldi	r30, 0x59	; 89
     ffa:	f0 e0       	ldi	r31, 0x00	; 0
     ffc:	89 81       	ldd	r24, Y+1	; 0x01
     ffe:	80 83       	st	Z, r24
}
    1000:	26 96       	adiw	r28, 0x06	; 6
    1002:	0f b6       	in	r0, 0x3f	; 63
    1004:	f8 94       	cli
    1006:	de bf       	out	0x3e, r29	; 62
    1008:	0f be       	out	0x3f, r0	; 63
    100a:	cd bf       	out	0x3d, r28	; 61
    100c:	cf 91       	pop	r28
    100e:	df 91       	pop	r29
    1010:	08 95       	ret

00001012 <__vector_6>:
	 * count is incremented after the context is saved.
	 */
	void  TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void  TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1012:	0e 94 52 07 	call	0xea4	; 0xea4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1016:	18 95       	reti

00001018 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1018:	df 93       	push	r29
    101a:	cf 93       	push	r28
    101c:	cd b7       	in	r28, 0x3d	; 61
    101e:	de b7       	in	r29, 0x3e	; 62
    1020:	28 97       	sbiw	r28, 0x08	; 8
    1022:	0f b6       	in	r0, 0x3f	; 63
    1024:	f8 94       	cli
    1026:	de bf       	out	0x3e, r29	; 62
    1028:	0f be       	out	0x3f, r0	; 63
    102a:	cd bf       	out	0x3d, r28	; 61
    102c:	8f 83       	std	Y+7, r24	; 0x07
    102e:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1030:	1a 82       	std	Y+2, r1	; 0x02
    1032:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1034:	8f 81       	ldd	r24, Y+7	; 0x07
    1036:	88 23       	and	r24, r24
    1038:	09 f4       	brne	.+2      	; 0x103c <xQueueCreate+0x24>
    103a:	8c c0       	rjmp	.+280    	; 0x1154 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    103c:	8f e1       	ldi	r24, 0x1F	; 31
    103e:	90 e0       	ldi	r25, 0x00	; 0
    1040:	0e 94 93 03 	call	0x726	; 0x726 <pvPortMalloc>
    1044:	9e 83       	std	Y+6, r25	; 0x06
    1046:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1048:	8d 81       	ldd	r24, Y+5	; 0x05
    104a:	9e 81       	ldd	r25, Y+6	; 0x06
    104c:	00 97       	sbiw	r24, 0x00	; 0
    104e:	09 f4       	brne	.+2      	; 0x1052 <xQueueCreate+0x3a>
    1050:	81 c0       	rjmp	.+258    	; 0x1154 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1052:	8f 81       	ldd	r24, Y+7	; 0x07
    1054:	28 2f       	mov	r18, r24
    1056:	30 e0       	ldi	r19, 0x00	; 0
    1058:	88 85       	ldd	r24, Y+8	; 0x08
    105a:	88 2f       	mov	r24, r24
    105c:	90 e0       	ldi	r25, 0x00	; 0
    105e:	ac 01       	movw	r20, r24
    1060:	24 9f       	mul	r18, r20
    1062:	c0 01       	movw	r24, r0
    1064:	25 9f       	mul	r18, r21
    1066:	90 0d       	add	r25, r0
    1068:	34 9f       	mul	r19, r20
    106a:	90 0d       	add	r25, r0
    106c:	11 24       	eor	r1, r1
    106e:	01 96       	adiw	r24, 0x01	; 1
    1070:	9c 83       	std	Y+4, r25	; 0x04
    1072:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1074:	8b 81       	ldd	r24, Y+3	; 0x03
    1076:	9c 81       	ldd	r25, Y+4	; 0x04
    1078:	0e 94 93 03 	call	0x726	; 0x726 <pvPortMalloc>
    107c:	ed 81       	ldd	r30, Y+5	; 0x05
    107e:	fe 81       	ldd	r31, Y+6	; 0x06
    1080:	91 83       	std	Z+1, r25	; 0x01
    1082:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1084:	ed 81       	ldd	r30, Y+5	; 0x05
    1086:	fe 81       	ldd	r31, Y+6	; 0x06
    1088:	80 81       	ld	r24, Z
    108a:	91 81       	ldd	r25, Z+1	; 0x01
    108c:	00 97       	sbiw	r24, 0x00	; 0
    108e:	09 f4       	brne	.+2      	; 0x1092 <xQueueCreate+0x7a>
    1090:	5d c0       	rjmp	.+186    	; 0x114c <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1092:	ed 81       	ldd	r30, Y+5	; 0x05
    1094:	fe 81       	ldd	r31, Y+6	; 0x06
    1096:	40 81       	ld	r20, Z
    1098:	51 81       	ldd	r21, Z+1	; 0x01
    109a:	8f 81       	ldd	r24, Y+7	; 0x07
    109c:	28 2f       	mov	r18, r24
    109e:	30 e0       	ldi	r19, 0x00	; 0
    10a0:	88 85       	ldd	r24, Y+8	; 0x08
    10a2:	88 2f       	mov	r24, r24
    10a4:	90 e0       	ldi	r25, 0x00	; 0
    10a6:	bc 01       	movw	r22, r24
    10a8:	26 9f       	mul	r18, r22
    10aa:	c0 01       	movw	r24, r0
    10ac:	27 9f       	mul	r18, r23
    10ae:	90 0d       	add	r25, r0
    10b0:	36 9f       	mul	r19, r22
    10b2:	90 0d       	add	r25, r0
    10b4:	11 24       	eor	r1, r1
    10b6:	84 0f       	add	r24, r20
    10b8:	95 1f       	adc	r25, r21
    10ba:	ed 81       	ldd	r30, Y+5	; 0x05
    10bc:	fe 81       	ldd	r31, Y+6	; 0x06
    10be:	93 83       	std	Z+3, r25	; 0x03
    10c0:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    10c2:	ed 81       	ldd	r30, Y+5	; 0x05
    10c4:	fe 81       	ldd	r31, Y+6	; 0x06
    10c6:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    10c8:	ed 81       	ldd	r30, Y+5	; 0x05
    10ca:	fe 81       	ldd	r31, Y+6	; 0x06
    10cc:	80 81       	ld	r24, Z
    10ce:	91 81       	ldd	r25, Z+1	; 0x01
    10d0:	ed 81       	ldd	r30, Y+5	; 0x05
    10d2:	fe 81       	ldd	r31, Y+6	; 0x06
    10d4:	95 83       	std	Z+5, r25	; 0x05
    10d6:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    10d8:	ed 81       	ldd	r30, Y+5	; 0x05
    10da:	fe 81       	ldd	r31, Y+6	; 0x06
    10dc:	40 81       	ld	r20, Z
    10de:	51 81       	ldd	r21, Z+1	; 0x01
    10e0:	8f 81       	ldd	r24, Y+7	; 0x07
    10e2:	88 2f       	mov	r24, r24
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	9c 01       	movw	r18, r24
    10e8:	21 50       	subi	r18, 0x01	; 1
    10ea:	30 40       	sbci	r19, 0x00	; 0
    10ec:	88 85       	ldd	r24, Y+8	; 0x08
    10ee:	88 2f       	mov	r24, r24
    10f0:	90 e0       	ldi	r25, 0x00	; 0
    10f2:	bc 01       	movw	r22, r24
    10f4:	26 9f       	mul	r18, r22
    10f6:	c0 01       	movw	r24, r0
    10f8:	27 9f       	mul	r18, r23
    10fa:	90 0d       	add	r25, r0
    10fc:	36 9f       	mul	r19, r22
    10fe:	90 0d       	add	r25, r0
    1100:	11 24       	eor	r1, r1
    1102:	84 0f       	add	r24, r20
    1104:	95 1f       	adc	r25, r21
    1106:	ed 81       	ldd	r30, Y+5	; 0x05
    1108:	fe 81       	ldd	r31, Y+6	; 0x06
    110a:	97 83       	std	Z+7, r25	; 0x07
    110c:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    110e:	ed 81       	ldd	r30, Y+5	; 0x05
    1110:	fe 81       	ldd	r31, Y+6	; 0x06
    1112:	8f 81       	ldd	r24, Y+7	; 0x07
    1114:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1116:	ed 81       	ldd	r30, Y+5	; 0x05
    1118:	fe 81       	ldd	r31, Y+6	; 0x06
    111a:	88 85       	ldd	r24, Y+8	; 0x08
    111c:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    111e:	ed 81       	ldd	r30, Y+5	; 0x05
    1120:	fe 81       	ldd	r31, Y+6	; 0x06
    1122:	8f ef       	ldi	r24, 0xFF	; 255
    1124:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1126:	ed 81       	ldd	r30, Y+5	; 0x05
    1128:	fe 81       	ldd	r31, Y+6	; 0x06
    112a:	8f ef       	ldi	r24, 0xFF	; 255
    112c:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    112e:	8d 81       	ldd	r24, Y+5	; 0x05
    1130:	9e 81       	ldd	r25, Y+6	; 0x06
    1132:	08 96       	adiw	r24, 0x08	; 8
    1134:	0e 94 ff 03 	call	0x7fe	; 0x7fe <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1138:	8d 81       	ldd	r24, Y+5	; 0x05
    113a:	9e 81       	ldd	r25, Y+6	; 0x06
    113c:	41 96       	adiw	r24, 0x11	; 17
    113e:	0e 94 ff 03 	call	0x7fe	; 0x7fe <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1142:	8d 81       	ldd	r24, Y+5	; 0x05
    1144:	9e 81       	ldd	r25, Y+6	; 0x06
    1146:	9a 83       	std	Y+2, r25	; 0x02
    1148:	89 83       	std	Y+1, r24	; 0x01
    114a:	04 c0       	rjmp	.+8      	; 0x1154 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    114c:	8d 81       	ldd	r24, Y+5	; 0x05
    114e:	9e 81       	ldd	r25, Y+6	; 0x06
    1150:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1154:	89 81       	ldd	r24, Y+1	; 0x01
    1156:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1158:	28 96       	adiw	r28, 0x08	; 8
    115a:	0f b6       	in	r0, 0x3f	; 63
    115c:	f8 94       	cli
    115e:	de bf       	out	0x3e, r29	; 62
    1160:	0f be       	out	0x3f, r0	; 63
    1162:	cd bf       	out	0x3d, r28	; 61
    1164:	cf 91       	pop	r28
    1166:	df 91       	pop	r29
    1168:	08 95       	ret

0000116a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    116a:	df 93       	push	r29
    116c:	cf 93       	push	r28
    116e:	cd b7       	in	r28, 0x3d	; 61
    1170:	de b7       	in	r29, 0x3e	; 62
    1172:	2c 97       	sbiw	r28, 0x0c	; 12
    1174:	0f b6       	in	r0, 0x3f	; 63
    1176:	f8 94       	cli
    1178:	de bf       	out	0x3e, r29	; 62
    117a:	0f be       	out	0x3f, r0	; 63
    117c:	cd bf       	out	0x3d, r28	; 61
    117e:	9e 83       	std	Y+6, r25	; 0x06
    1180:	8d 83       	std	Y+5, r24	; 0x05
    1182:	78 87       	std	Y+8, r23	; 0x08
    1184:	6f 83       	std	Y+7, r22	; 0x07
    1186:	5a 87       	std	Y+10, r21	; 0x0a
    1188:	49 87       	std	Y+9, r20	; 0x09
    118a:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    118c:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    118e:	0f b6       	in	r0, 0x3f	; 63
    1190:	f8 94       	cli
    1192:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1194:	ed 81       	ldd	r30, Y+5	; 0x05
    1196:	fe 81       	ldd	r31, Y+6	; 0x06
    1198:	92 8d       	ldd	r25, Z+26	; 0x1a
    119a:	ed 81       	ldd	r30, Y+5	; 0x05
    119c:	fe 81       	ldd	r31, Y+6	; 0x06
    119e:	83 8d       	ldd	r24, Z+27	; 0x1b
    11a0:	98 17       	cp	r25, r24
    11a2:	d8 f4       	brcc	.+54     	; 0x11da <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    11a4:	8d 81       	ldd	r24, Y+5	; 0x05
    11a6:	9e 81       	ldd	r25, Y+6	; 0x06
    11a8:	2f 81       	ldd	r18, Y+7	; 0x07
    11aa:	38 85       	ldd	r19, Y+8	; 0x08
    11ac:	b9 01       	movw	r22, r18
    11ae:	4b 85       	ldd	r20, Y+11	; 0x0b
    11b0:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    11b4:	ed 81       	ldd	r30, Y+5	; 0x05
    11b6:	fe 81       	ldd	r31, Y+6	; 0x06
    11b8:	81 89       	ldd	r24, Z+17	; 0x11
    11ba:	88 23       	and	r24, r24
    11bc:	49 f0       	breq	.+18     	; 0x11d0 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    11be:	8d 81       	ldd	r24, Y+5	; 0x05
    11c0:	9e 81       	ldd	r25, Y+6	; 0x06
    11c2:	41 96       	adiw	r24, 0x11	; 17
    11c4:	0e 94 05 11 	call	0x220a	; 0x220a <xTaskRemoveFromEventList>
    11c8:	81 30       	cpi	r24, 0x01	; 1
    11ca:	11 f4       	brne	.+4      	; 0x11d0 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    11cc:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    11d0:	0f 90       	pop	r0
    11d2:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    11d4:	81 e0       	ldi	r24, 0x01	; 1
    11d6:	8c 87       	std	Y+12, r24	; 0x0c
    11d8:	5c c0       	rjmp	.+184    	; 0x1292 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    11da:	89 85       	ldd	r24, Y+9	; 0x09
    11dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    11de:	00 97       	sbiw	r24, 0x00	; 0
    11e0:	21 f4       	brne	.+8      	; 0x11ea <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    11e2:	0f 90       	pop	r0
    11e4:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    11e6:	1c 86       	std	Y+12, r1	; 0x0c
    11e8:	54 c0       	rjmp	.+168    	; 0x1292 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    11ea:	89 81       	ldd	r24, Y+1	; 0x01
    11ec:	88 23       	and	r24, r24
    11ee:	31 f4       	brne	.+12     	; 0x11fc <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    11f0:	ce 01       	movw	r24, r28
    11f2:	02 96       	adiw	r24, 0x02	; 2
    11f4:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    11f8:	81 e0       	ldi	r24, 0x01	; 1
    11fa:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    11fc:	0f 90       	pop	r0
    11fe:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1200:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1204:	0f b6       	in	r0, 0x3f	; 63
    1206:	f8 94       	cli
    1208:	0f 92       	push	r0
    120a:	ed 81       	ldd	r30, Y+5	; 0x05
    120c:	fe 81       	ldd	r31, Y+6	; 0x06
    120e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1210:	8f 3f       	cpi	r24, 0xFF	; 255
    1212:	19 f4       	brne	.+6      	; 0x121a <xQueueGenericSend+0xb0>
    1214:	ed 81       	ldd	r30, Y+5	; 0x05
    1216:	fe 81       	ldd	r31, Y+6	; 0x06
    1218:	15 8e       	std	Z+29, r1	; 0x1d
    121a:	ed 81       	ldd	r30, Y+5	; 0x05
    121c:	fe 81       	ldd	r31, Y+6	; 0x06
    121e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1220:	8f 3f       	cpi	r24, 0xFF	; 255
    1222:	19 f4       	brne	.+6      	; 0x122a <xQueueGenericSend+0xc0>
    1224:	ed 81       	ldd	r30, Y+5	; 0x05
    1226:	fe 81       	ldd	r31, Y+6	; 0x06
    1228:	16 8e       	std	Z+30, r1	; 0x1e
    122a:	0f 90       	pop	r0
    122c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    122e:	ce 01       	movw	r24, r28
    1230:	02 96       	adiw	r24, 0x02	; 2
    1232:	9e 01       	movw	r18, r28
    1234:	27 5f       	subi	r18, 0xF7	; 247
    1236:	3f 4f       	sbci	r19, 0xFF	; 255
    1238:	b9 01       	movw	r22, r18
    123a:	0e 94 86 11 	call	0x230c	; 0x230c <xTaskCheckForTimeOut>
    123e:	88 23       	and	r24, r24
    1240:	09 f5       	brne	.+66     	; 0x1284 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1242:	8d 81       	ldd	r24, Y+5	; 0x05
    1244:	9e 81       	ldd	r25, Y+6	; 0x06
    1246:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <prvIsQueueFull>
    124a:	88 23       	and	r24, r24
    124c:	a1 f0       	breq	.+40     	; 0x1276 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    124e:	8d 81       	ldd	r24, Y+5	; 0x05
    1250:	9e 81       	ldd	r25, Y+6	; 0x06
    1252:	08 96       	adiw	r24, 0x08	; 8
    1254:	29 85       	ldd	r18, Y+9	; 0x09
    1256:	3a 85       	ldd	r19, Y+10	; 0x0a
    1258:	b9 01       	movw	r22, r18
    125a:	0e 94 cf 10 	call	0x219e	; 0x219e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    125e:	8d 81       	ldd	r24, Y+5	; 0x05
    1260:	9e 81       	ldd	r25, Y+6	; 0x06
    1262:	0e 94 cd 0b 	call	0x179a	; 0x179a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1266:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <xTaskResumeAll>
    126a:	88 23       	and	r24, r24
    126c:	09 f0       	breq	.+2      	; 0x1270 <xQueueGenericSend+0x106>
    126e:	8f cf       	rjmp	.-226    	; 0x118e <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1270:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vPortYield>
    1274:	8c cf       	rjmp	.-232    	; 0x118e <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1276:	8d 81       	ldd	r24, Y+5	; 0x05
    1278:	9e 81       	ldd	r25, Y+6	; 0x06
    127a:	0e 94 cd 0b 	call	0x179a	; 0x179a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    127e:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <xTaskResumeAll>
    1282:	85 cf       	rjmp	.-246    	; 0x118e <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1284:	8d 81       	ldd	r24, Y+5	; 0x05
    1286:	9e 81       	ldd	r25, Y+6	; 0x06
    1288:	0e 94 cd 0b 	call	0x179a	; 0x179a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    128c:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1290:	1c 86       	std	Y+12, r1	; 0x0c
    1292:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1294:	2c 96       	adiw	r28, 0x0c	; 12
    1296:	0f b6       	in	r0, 0x3f	; 63
    1298:	f8 94       	cli
    129a:	de bf       	out	0x3e, r29	; 62
    129c:	0f be       	out	0x3f, r0	; 63
    129e:	cd bf       	out	0x3d, r28	; 61
    12a0:	cf 91       	pop	r28
    12a2:	df 91       	pop	r29
    12a4:	08 95       	ret

000012a6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    12a6:	df 93       	push	r29
    12a8:	cf 93       	push	r28
    12aa:	cd b7       	in	r28, 0x3d	; 61
    12ac:	de b7       	in	r29, 0x3e	; 62
    12ae:	29 97       	sbiw	r28, 0x09	; 9
    12b0:	0f b6       	in	r0, 0x3f	; 63
    12b2:	f8 94       	cli
    12b4:	de bf       	out	0x3e, r29	; 62
    12b6:	0f be       	out	0x3f, r0	; 63
    12b8:	cd bf       	out	0x3d, r28	; 61
    12ba:	9c 83       	std	Y+4, r25	; 0x04
    12bc:	8b 83       	std	Y+3, r24	; 0x03
    12be:	7e 83       	std	Y+6, r23	; 0x06
    12c0:	6d 83       	std	Y+5, r22	; 0x05
    12c2:	58 87       	std	Y+8, r21	; 0x08
    12c4:	4f 83       	std	Y+7, r20	; 0x07
    12c6:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    12c8:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    12ca:	eb 81       	ldd	r30, Y+3	; 0x03
    12cc:	fc 81       	ldd	r31, Y+4	; 0x04
    12ce:	92 8d       	ldd	r25, Z+26	; 0x1a
    12d0:	eb 81       	ldd	r30, Y+3	; 0x03
    12d2:	fc 81       	ldd	r31, Y+4	; 0x04
    12d4:	83 8d       	ldd	r24, Z+27	; 0x1b
    12d6:	98 17       	cp	r25, r24
    12d8:	40 f5       	brcc	.+80     	; 0x132a <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    12da:	8b 81       	ldd	r24, Y+3	; 0x03
    12dc:	9c 81       	ldd	r25, Y+4	; 0x04
    12de:	2d 81       	ldd	r18, Y+5	; 0x05
    12e0:	3e 81       	ldd	r19, Y+6	; 0x06
    12e2:	b9 01       	movw	r22, r18
    12e4:	49 85       	ldd	r20, Y+9	; 0x09
    12e6:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    12ea:	eb 81       	ldd	r30, Y+3	; 0x03
    12ec:	fc 81       	ldd	r31, Y+4	; 0x04
    12ee:	86 8d       	ldd	r24, Z+30	; 0x1e
    12f0:	8f 3f       	cpi	r24, 0xFF	; 255
    12f2:	89 f4       	brne	.+34     	; 0x1316 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12f4:	eb 81       	ldd	r30, Y+3	; 0x03
    12f6:	fc 81       	ldd	r31, Y+4	; 0x04
    12f8:	81 89       	ldd	r24, Z+17	; 0x11
    12fa:	88 23       	and	r24, r24
    12fc:	99 f0       	breq	.+38     	; 0x1324 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1300:	9c 81       	ldd	r25, Y+4	; 0x04
    1302:	41 96       	adiw	r24, 0x11	; 17
    1304:	0e 94 05 11 	call	0x220a	; 0x220a <xTaskRemoveFromEventList>
    1308:	88 23       	and	r24, r24
    130a:	61 f0       	breq	.+24     	; 0x1324 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    130c:	ef 81       	ldd	r30, Y+7	; 0x07
    130e:	f8 85       	ldd	r31, Y+8	; 0x08
    1310:	81 e0       	ldi	r24, 0x01	; 1
    1312:	80 83       	st	Z, r24
    1314:	07 c0       	rjmp	.+14     	; 0x1324 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1316:	eb 81       	ldd	r30, Y+3	; 0x03
    1318:	fc 81       	ldd	r31, Y+4	; 0x04
    131a:	86 8d       	ldd	r24, Z+30	; 0x1e
    131c:	8f 5f       	subi	r24, 0xFF	; 255
    131e:	eb 81       	ldd	r30, Y+3	; 0x03
    1320:	fc 81       	ldd	r31, Y+4	; 0x04
    1322:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1324:	81 e0       	ldi	r24, 0x01	; 1
    1326:	8a 83       	std	Y+2, r24	; 0x02
    1328:	01 c0       	rjmp	.+2      	; 0x132c <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    132a:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    132c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    132e:	29 96       	adiw	r28, 0x09	; 9
    1330:	0f b6       	in	r0, 0x3f	; 63
    1332:	f8 94       	cli
    1334:	de bf       	out	0x3e, r29	; 62
    1336:	0f be       	out	0x3f, r0	; 63
    1338:	cd bf       	out	0x3d, r28	; 61
    133a:	cf 91       	pop	r28
    133c:	df 91       	pop	r29
    133e:	08 95       	ret

00001340 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1340:	df 93       	push	r29
    1342:	cf 93       	push	r28
    1344:	cd b7       	in	r28, 0x3d	; 61
    1346:	de b7       	in	r29, 0x3e	; 62
    1348:	2e 97       	sbiw	r28, 0x0e	; 14
    134a:	0f b6       	in	r0, 0x3f	; 63
    134c:	f8 94       	cli
    134e:	de bf       	out	0x3e, r29	; 62
    1350:	0f be       	out	0x3f, r0	; 63
    1352:	cd bf       	out	0x3d, r28	; 61
    1354:	98 87       	std	Y+8, r25	; 0x08
    1356:	8f 83       	std	Y+7, r24	; 0x07
    1358:	7a 87       	std	Y+10, r23	; 0x0a
    135a:	69 87       	std	Y+9, r22	; 0x09
    135c:	5c 87       	std	Y+12, r21	; 0x0c
    135e:	4b 87       	std	Y+11, r20	; 0x0b
    1360:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1362:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1364:	0f b6       	in	r0, 0x3f	; 63
    1366:	f8 94       	cli
    1368:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    136a:	ef 81       	ldd	r30, Y+7	; 0x07
    136c:	f8 85       	ldd	r31, Y+8	; 0x08
    136e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1370:	88 23       	and	r24, r24
    1372:	09 f4       	brne	.+2      	; 0x1376 <xQueueGenericReceive+0x36>
    1374:	3f c0       	rjmp	.+126    	; 0x13f4 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1376:	ef 81       	ldd	r30, Y+7	; 0x07
    1378:	f8 85       	ldd	r31, Y+8	; 0x08
    137a:	86 81       	ldd	r24, Z+6	; 0x06
    137c:	97 81       	ldd	r25, Z+7	; 0x07
    137e:	9a 83       	std	Y+2, r25	; 0x02
    1380:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1382:	8f 81       	ldd	r24, Y+7	; 0x07
    1384:	98 85       	ldd	r25, Y+8	; 0x08
    1386:	29 85       	ldd	r18, Y+9	; 0x09
    1388:	3a 85       	ldd	r19, Y+10	; 0x0a
    138a:	b9 01       	movw	r22, r18
    138c:	0e 94 85 0b 	call	0x170a	; 0x170a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1390:	8d 85       	ldd	r24, Y+13	; 0x0d
    1392:	88 23       	and	r24, r24
    1394:	b1 f4       	brne	.+44     	; 0x13c2 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1396:	ef 81       	ldd	r30, Y+7	; 0x07
    1398:	f8 85       	ldd	r31, Y+8	; 0x08
    139a:	82 8d       	ldd	r24, Z+26	; 0x1a
    139c:	81 50       	subi	r24, 0x01	; 1
    139e:	ef 81       	ldd	r30, Y+7	; 0x07
    13a0:	f8 85       	ldd	r31, Y+8	; 0x08
    13a2:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13a4:	ef 81       	ldd	r30, Y+7	; 0x07
    13a6:	f8 85       	ldd	r31, Y+8	; 0x08
    13a8:	80 85       	ldd	r24, Z+8	; 0x08
    13aa:	88 23       	and	r24, r24
    13ac:	f1 f0       	breq	.+60     	; 0x13ea <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    13ae:	8f 81       	ldd	r24, Y+7	; 0x07
    13b0:	98 85       	ldd	r25, Y+8	; 0x08
    13b2:	08 96       	adiw	r24, 0x08	; 8
    13b4:	0e 94 05 11 	call	0x220a	; 0x220a <xTaskRemoveFromEventList>
    13b8:	81 30       	cpi	r24, 0x01	; 1
    13ba:	b9 f4       	brne	.+46     	; 0x13ea <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    13bc:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vPortYield>
    13c0:	14 c0       	rjmp	.+40     	; 0x13ea <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    13c2:	ef 81       	ldd	r30, Y+7	; 0x07
    13c4:	f8 85       	ldd	r31, Y+8	; 0x08
    13c6:	89 81       	ldd	r24, Y+1	; 0x01
    13c8:	9a 81       	ldd	r25, Y+2	; 0x02
    13ca:	97 83       	std	Z+7, r25	; 0x07
    13cc:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13ce:	ef 81       	ldd	r30, Y+7	; 0x07
    13d0:	f8 85       	ldd	r31, Y+8	; 0x08
    13d2:	81 89       	ldd	r24, Z+17	; 0x11
    13d4:	88 23       	and	r24, r24
    13d6:	49 f0       	breq	.+18     	; 0x13ea <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13d8:	8f 81       	ldd	r24, Y+7	; 0x07
    13da:	98 85       	ldd	r25, Y+8	; 0x08
    13dc:	41 96       	adiw	r24, 0x11	; 17
    13de:	0e 94 05 11 	call	0x220a	; 0x220a <xTaskRemoveFromEventList>
    13e2:	88 23       	and	r24, r24
    13e4:	11 f0       	breq	.+4      	; 0x13ea <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    13e6:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    13ea:	0f 90       	pop	r0
    13ec:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    13ee:	81 e0       	ldi	r24, 0x01	; 1
    13f0:	8e 87       	std	Y+14, r24	; 0x0e
    13f2:	5c c0       	rjmp	.+184    	; 0x14ac <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    13f4:	8b 85       	ldd	r24, Y+11	; 0x0b
    13f6:	9c 85       	ldd	r25, Y+12	; 0x0c
    13f8:	00 97       	sbiw	r24, 0x00	; 0
    13fa:	21 f4       	brne	.+8      	; 0x1404 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    13fc:	0f 90       	pop	r0
    13fe:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1400:	1e 86       	std	Y+14, r1	; 0x0e
    1402:	54 c0       	rjmp	.+168    	; 0x14ac <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1404:	8b 81       	ldd	r24, Y+3	; 0x03
    1406:	88 23       	and	r24, r24
    1408:	31 f4       	brne	.+12     	; 0x1416 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    140a:	ce 01       	movw	r24, r28
    140c:	04 96       	adiw	r24, 0x04	; 4
    140e:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1412:	81 e0       	ldi	r24, 0x01	; 1
    1414:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1416:	0f 90       	pop	r0
    1418:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    141a:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    141e:	0f b6       	in	r0, 0x3f	; 63
    1420:	f8 94       	cli
    1422:	0f 92       	push	r0
    1424:	ef 81       	ldd	r30, Y+7	; 0x07
    1426:	f8 85       	ldd	r31, Y+8	; 0x08
    1428:	85 8d       	ldd	r24, Z+29	; 0x1d
    142a:	8f 3f       	cpi	r24, 0xFF	; 255
    142c:	19 f4       	brne	.+6      	; 0x1434 <xQueueGenericReceive+0xf4>
    142e:	ef 81       	ldd	r30, Y+7	; 0x07
    1430:	f8 85       	ldd	r31, Y+8	; 0x08
    1432:	15 8e       	std	Z+29, r1	; 0x1d
    1434:	ef 81       	ldd	r30, Y+7	; 0x07
    1436:	f8 85       	ldd	r31, Y+8	; 0x08
    1438:	86 8d       	ldd	r24, Z+30	; 0x1e
    143a:	8f 3f       	cpi	r24, 0xFF	; 255
    143c:	19 f4       	brne	.+6      	; 0x1444 <xQueueGenericReceive+0x104>
    143e:	ef 81       	ldd	r30, Y+7	; 0x07
    1440:	f8 85       	ldd	r31, Y+8	; 0x08
    1442:	16 8e       	std	Z+30, r1	; 0x1e
    1444:	0f 90       	pop	r0
    1446:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1448:	ce 01       	movw	r24, r28
    144a:	04 96       	adiw	r24, 0x04	; 4
    144c:	9e 01       	movw	r18, r28
    144e:	25 5f       	subi	r18, 0xF5	; 245
    1450:	3f 4f       	sbci	r19, 0xFF	; 255
    1452:	b9 01       	movw	r22, r18
    1454:	0e 94 86 11 	call	0x230c	; 0x230c <xTaskCheckForTimeOut>
    1458:	88 23       	and	r24, r24
    145a:	09 f5       	brne	.+66     	; 0x149e <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    145c:	8f 81       	ldd	r24, Y+7	; 0x07
    145e:	98 85       	ldd	r25, Y+8	; 0x08
    1460:	0e 94 21 0c 	call	0x1842	; 0x1842 <prvIsQueueEmpty>
    1464:	88 23       	and	r24, r24
    1466:	a1 f0       	breq	.+40     	; 0x1490 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1468:	8f 81       	ldd	r24, Y+7	; 0x07
    146a:	98 85       	ldd	r25, Y+8	; 0x08
    146c:	41 96       	adiw	r24, 0x11	; 17
    146e:	2b 85       	ldd	r18, Y+11	; 0x0b
    1470:	3c 85       	ldd	r19, Y+12	; 0x0c
    1472:	b9 01       	movw	r22, r18
    1474:	0e 94 cf 10 	call	0x219e	; 0x219e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1478:	8f 81       	ldd	r24, Y+7	; 0x07
    147a:	98 85       	ldd	r25, Y+8	; 0x08
    147c:	0e 94 cd 0b 	call	0x179a	; 0x179a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1480:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <xTaskResumeAll>
    1484:	88 23       	and	r24, r24
    1486:	09 f0       	breq	.+2      	; 0x148a <xQueueGenericReceive+0x14a>
    1488:	6d cf       	rjmp	.-294    	; 0x1364 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    148a:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vPortYield>
    148e:	6a cf       	rjmp	.-300    	; 0x1364 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1490:	8f 81       	ldd	r24, Y+7	; 0x07
    1492:	98 85       	ldd	r25, Y+8	; 0x08
    1494:	0e 94 cd 0b 	call	0x179a	; 0x179a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1498:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <xTaskResumeAll>
    149c:	63 cf       	rjmp	.-314    	; 0x1364 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    149e:	8f 81       	ldd	r24, Y+7	; 0x07
    14a0:	98 85       	ldd	r25, Y+8	; 0x08
    14a2:	0e 94 cd 0b 	call	0x179a	; 0x179a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    14a6:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    14aa:	1e 86       	std	Y+14, r1	; 0x0e
    14ac:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    14ae:	2e 96       	adiw	r28, 0x0e	; 14
    14b0:	0f b6       	in	r0, 0x3f	; 63
    14b2:	f8 94       	cli
    14b4:	de bf       	out	0x3e, r29	; 62
    14b6:	0f be       	out	0x3f, r0	; 63
    14b8:	cd bf       	out	0x3d, r28	; 61
    14ba:	cf 91       	pop	r28
    14bc:	df 91       	pop	r29
    14be:	08 95       	ret

000014c0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    14c0:	df 93       	push	r29
    14c2:	cf 93       	push	r28
    14c4:	cd b7       	in	r28, 0x3d	; 61
    14c6:	de b7       	in	r29, 0x3e	; 62
    14c8:	28 97       	sbiw	r28, 0x08	; 8
    14ca:	0f b6       	in	r0, 0x3f	; 63
    14cc:	f8 94       	cli
    14ce:	de bf       	out	0x3e, r29	; 62
    14d0:	0f be       	out	0x3f, r0	; 63
    14d2:	cd bf       	out	0x3d, r28	; 61
    14d4:	9c 83       	std	Y+4, r25	; 0x04
    14d6:	8b 83       	std	Y+3, r24	; 0x03
    14d8:	7e 83       	std	Y+6, r23	; 0x06
    14da:	6d 83       	std	Y+5, r22	; 0x05
    14dc:	58 87       	std	Y+8, r21	; 0x08
    14de:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    14e0:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    14e2:	eb 81       	ldd	r30, Y+3	; 0x03
    14e4:	fc 81       	ldd	r31, Y+4	; 0x04
    14e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    14e8:	88 23       	and	r24, r24
    14ea:	71 f1       	breq	.+92     	; 0x1548 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    14ec:	8b 81       	ldd	r24, Y+3	; 0x03
    14ee:	9c 81       	ldd	r25, Y+4	; 0x04
    14f0:	2d 81       	ldd	r18, Y+5	; 0x05
    14f2:	3e 81       	ldd	r19, Y+6	; 0x06
    14f4:	b9 01       	movw	r22, r18
    14f6:	0e 94 85 0b 	call	0x170a	; 0x170a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    14fa:	eb 81       	ldd	r30, Y+3	; 0x03
    14fc:	fc 81       	ldd	r31, Y+4	; 0x04
    14fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    1500:	81 50       	subi	r24, 0x01	; 1
    1502:	eb 81       	ldd	r30, Y+3	; 0x03
    1504:	fc 81       	ldd	r31, Y+4	; 0x04
    1506:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1508:	eb 81       	ldd	r30, Y+3	; 0x03
    150a:	fc 81       	ldd	r31, Y+4	; 0x04
    150c:	85 8d       	ldd	r24, Z+29	; 0x1d
    150e:	8f 3f       	cpi	r24, 0xFF	; 255
    1510:	89 f4       	brne	.+34     	; 0x1534 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1512:	eb 81       	ldd	r30, Y+3	; 0x03
    1514:	fc 81       	ldd	r31, Y+4	; 0x04
    1516:	80 85       	ldd	r24, Z+8	; 0x08
    1518:	88 23       	and	r24, r24
    151a:	99 f0       	breq	.+38     	; 0x1542 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    151c:	8b 81       	ldd	r24, Y+3	; 0x03
    151e:	9c 81       	ldd	r25, Y+4	; 0x04
    1520:	08 96       	adiw	r24, 0x08	; 8
    1522:	0e 94 05 11 	call	0x220a	; 0x220a <xTaskRemoveFromEventList>
    1526:	88 23       	and	r24, r24
    1528:	61 f0       	breq	.+24     	; 0x1542 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    152a:	ef 81       	ldd	r30, Y+7	; 0x07
    152c:	f8 85       	ldd	r31, Y+8	; 0x08
    152e:	81 e0       	ldi	r24, 0x01	; 1
    1530:	80 83       	st	Z, r24
    1532:	07 c0       	rjmp	.+14     	; 0x1542 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1534:	eb 81       	ldd	r30, Y+3	; 0x03
    1536:	fc 81       	ldd	r31, Y+4	; 0x04
    1538:	85 8d       	ldd	r24, Z+29	; 0x1d
    153a:	8f 5f       	subi	r24, 0xFF	; 255
    153c:	eb 81       	ldd	r30, Y+3	; 0x03
    153e:	fc 81       	ldd	r31, Y+4	; 0x04
    1540:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1542:	81 e0       	ldi	r24, 0x01	; 1
    1544:	8a 83       	std	Y+2, r24	; 0x02
    1546:	01 c0       	rjmp	.+2      	; 0x154a <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1548:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    154a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    154c:	28 96       	adiw	r28, 0x08	; 8
    154e:	0f b6       	in	r0, 0x3f	; 63
    1550:	f8 94       	cli
    1552:	de bf       	out	0x3e, r29	; 62
    1554:	0f be       	out	0x3f, r0	; 63
    1556:	cd bf       	out	0x3d, r28	; 61
    1558:	cf 91       	pop	r28
    155a:	df 91       	pop	r29
    155c:	08 95       	ret

0000155e <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    155e:	df 93       	push	r29
    1560:	cf 93       	push	r28
    1562:	00 d0       	rcall	.+0      	; 0x1564 <uxQueueMessagesWaiting+0x6>
    1564:	0f 92       	push	r0
    1566:	cd b7       	in	r28, 0x3d	; 61
    1568:	de b7       	in	r29, 0x3e	; 62
    156a:	9b 83       	std	Y+3, r25	; 0x03
    156c:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    156e:	0f b6       	in	r0, 0x3f	; 63
    1570:	f8 94       	cli
    1572:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1574:	ea 81       	ldd	r30, Y+2	; 0x02
    1576:	fb 81       	ldd	r31, Y+3	; 0x03
    1578:	82 8d       	ldd	r24, Z+26	; 0x1a
    157a:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    157c:	0f 90       	pop	r0
    157e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1580:	89 81       	ldd	r24, Y+1	; 0x01
}
    1582:	0f 90       	pop	r0
    1584:	0f 90       	pop	r0
    1586:	0f 90       	pop	r0
    1588:	cf 91       	pop	r28
    158a:	df 91       	pop	r29
    158c:	08 95       	ret

0000158e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    158e:	df 93       	push	r29
    1590:	cf 93       	push	r28
    1592:	00 d0       	rcall	.+0      	; 0x1594 <uxQueueMessagesWaitingFromISR+0x6>
    1594:	0f 92       	push	r0
    1596:	cd b7       	in	r28, 0x3d	; 61
    1598:	de b7       	in	r29, 0x3e	; 62
    159a:	9b 83       	std	Y+3, r25	; 0x03
    159c:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    159e:	ea 81       	ldd	r30, Y+2	; 0x02
    15a0:	fb 81       	ldd	r31, Y+3	; 0x03
    15a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    15a4:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    15a6:	89 81       	ldd	r24, Y+1	; 0x01
}
    15a8:	0f 90       	pop	r0
    15aa:	0f 90       	pop	r0
    15ac:	0f 90       	pop	r0
    15ae:	cf 91       	pop	r28
    15b0:	df 91       	pop	r29
    15b2:	08 95       	ret

000015b4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    15b4:	df 93       	push	r29
    15b6:	cf 93       	push	r28
    15b8:	00 d0       	rcall	.+0      	; 0x15ba <vQueueDelete+0x6>
    15ba:	cd b7       	in	r28, 0x3d	; 61
    15bc:	de b7       	in	r29, 0x3e	; 62
    15be:	9a 83       	std	Y+2, r25	; 0x02
    15c0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    15c2:	e9 81       	ldd	r30, Y+1	; 0x01
    15c4:	fa 81       	ldd	r31, Y+2	; 0x02
    15c6:	80 81       	ld	r24, Z
    15c8:	91 81       	ldd	r25, Z+1	; 0x01
    15ca:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <vPortFree>
	vPortFree( pxQueue );
    15ce:	89 81       	ldd	r24, Y+1	; 0x01
    15d0:	9a 81       	ldd	r25, Y+2	; 0x02
    15d2:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <vPortFree>
}
    15d6:	0f 90       	pop	r0
    15d8:	0f 90       	pop	r0
    15da:	cf 91       	pop	r28
    15dc:	df 91       	pop	r29
    15de:	08 95       	ret

000015e0 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    15e0:	df 93       	push	r29
    15e2:	cf 93       	push	r28
    15e4:	00 d0       	rcall	.+0      	; 0x15e6 <prvCopyDataToQueue+0x6>
    15e6:	00 d0       	rcall	.+0      	; 0x15e8 <prvCopyDataToQueue+0x8>
    15e8:	0f 92       	push	r0
    15ea:	cd b7       	in	r28, 0x3d	; 61
    15ec:	de b7       	in	r29, 0x3e	; 62
    15ee:	9a 83       	std	Y+2, r25	; 0x02
    15f0:	89 83       	std	Y+1, r24	; 0x01
    15f2:	7c 83       	std	Y+4, r23	; 0x04
    15f4:	6b 83       	std	Y+3, r22	; 0x03
    15f6:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    15f8:	e9 81       	ldd	r30, Y+1	; 0x01
    15fa:	fa 81       	ldd	r31, Y+2	; 0x02
    15fc:	84 8d       	ldd	r24, Z+28	; 0x1c
    15fe:	88 23       	and	r24, r24
    1600:	09 f4       	brne	.+2      	; 0x1604 <prvCopyDataToQueue+0x24>
    1602:	74 c0       	rjmp	.+232    	; 0x16ec <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1604:	8d 81       	ldd	r24, Y+5	; 0x05
    1606:	88 23       	and	r24, r24
    1608:	99 f5       	brne	.+102    	; 0x1670 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    160a:	e9 81       	ldd	r30, Y+1	; 0x01
    160c:	fa 81       	ldd	r31, Y+2	; 0x02
    160e:	64 81       	ldd	r22, Z+4	; 0x04
    1610:	75 81       	ldd	r23, Z+5	; 0x05
    1612:	e9 81       	ldd	r30, Y+1	; 0x01
    1614:	fa 81       	ldd	r31, Y+2	; 0x02
    1616:	84 8d       	ldd	r24, Z+28	; 0x1c
    1618:	48 2f       	mov	r20, r24
    161a:	50 e0       	ldi	r21, 0x00	; 0
    161c:	2b 81       	ldd	r18, Y+3	; 0x03
    161e:	3c 81       	ldd	r19, Y+4	; 0x04
    1620:	cb 01       	movw	r24, r22
    1622:	b9 01       	movw	r22, r18
    1624:	0e 94 78 13 	call	0x26f0	; 0x26f0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1628:	e9 81       	ldd	r30, Y+1	; 0x01
    162a:	fa 81       	ldd	r31, Y+2	; 0x02
    162c:	24 81       	ldd	r18, Z+4	; 0x04
    162e:	35 81       	ldd	r19, Z+5	; 0x05
    1630:	e9 81       	ldd	r30, Y+1	; 0x01
    1632:	fa 81       	ldd	r31, Y+2	; 0x02
    1634:	84 8d       	ldd	r24, Z+28	; 0x1c
    1636:	88 2f       	mov	r24, r24
    1638:	90 e0       	ldi	r25, 0x00	; 0
    163a:	82 0f       	add	r24, r18
    163c:	93 1f       	adc	r25, r19
    163e:	e9 81       	ldd	r30, Y+1	; 0x01
    1640:	fa 81       	ldd	r31, Y+2	; 0x02
    1642:	95 83       	std	Z+5, r25	; 0x05
    1644:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1646:	e9 81       	ldd	r30, Y+1	; 0x01
    1648:	fa 81       	ldd	r31, Y+2	; 0x02
    164a:	24 81       	ldd	r18, Z+4	; 0x04
    164c:	35 81       	ldd	r19, Z+5	; 0x05
    164e:	e9 81       	ldd	r30, Y+1	; 0x01
    1650:	fa 81       	ldd	r31, Y+2	; 0x02
    1652:	82 81       	ldd	r24, Z+2	; 0x02
    1654:	93 81       	ldd	r25, Z+3	; 0x03
    1656:	28 17       	cp	r18, r24
    1658:	39 07       	cpc	r19, r25
    165a:	08 f4       	brcc	.+2      	; 0x165e <prvCopyDataToQueue+0x7e>
    165c:	47 c0       	rjmp	.+142    	; 0x16ec <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    165e:	e9 81       	ldd	r30, Y+1	; 0x01
    1660:	fa 81       	ldd	r31, Y+2	; 0x02
    1662:	80 81       	ld	r24, Z
    1664:	91 81       	ldd	r25, Z+1	; 0x01
    1666:	e9 81       	ldd	r30, Y+1	; 0x01
    1668:	fa 81       	ldd	r31, Y+2	; 0x02
    166a:	95 83       	std	Z+5, r25	; 0x05
    166c:	84 83       	std	Z+4, r24	; 0x04
    166e:	3e c0       	rjmp	.+124    	; 0x16ec <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1670:	e9 81       	ldd	r30, Y+1	; 0x01
    1672:	fa 81       	ldd	r31, Y+2	; 0x02
    1674:	66 81       	ldd	r22, Z+6	; 0x06
    1676:	77 81       	ldd	r23, Z+7	; 0x07
    1678:	e9 81       	ldd	r30, Y+1	; 0x01
    167a:	fa 81       	ldd	r31, Y+2	; 0x02
    167c:	84 8d       	ldd	r24, Z+28	; 0x1c
    167e:	48 2f       	mov	r20, r24
    1680:	50 e0       	ldi	r21, 0x00	; 0
    1682:	2b 81       	ldd	r18, Y+3	; 0x03
    1684:	3c 81       	ldd	r19, Y+4	; 0x04
    1686:	cb 01       	movw	r24, r22
    1688:	b9 01       	movw	r22, r18
    168a:	0e 94 78 13 	call	0x26f0	; 0x26f0 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    168e:	e9 81       	ldd	r30, Y+1	; 0x01
    1690:	fa 81       	ldd	r31, Y+2	; 0x02
    1692:	26 81       	ldd	r18, Z+6	; 0x06
    1694:	37 81       	ldd	r19, Z+7	; 0x07
    1696:	e9 81       	ldd	r30, Y+1	; 0x01
    1698:	fa 81       	ldd	r31, Y+2	; 0x02
    169a:	84 8d       	ldd	r24, Z+28	; 0x1c
    169c:	88 2f       	mov	r24, r24
    169e:	90 e0       	ldi	r25, 0x00	; 0
    16a0:	90 95       	com	r25
    16a2:	81 95       	neg	r24
    16a4:	9f 4f       	sbci	r25, 0xFF	; 255
    16a6:	82 0f       	add	r24, r18
    16a8:	93 1f       	adc	r25, r19
    16aa:	e9 81       	ldd	r30, Y+1	; 0x01
    16ac:	fa 81       	ldd	r31, Y+2	; 0x02
    16ae:	97 83       	std	Z+7, r25	; 0x07
    16b0:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    16b2:	e9 81       	ldd	r30, Y+1	; 0x01
    16b4:	fa 81       	ldd	r31, Y+2	; 0x02
    16b6:	26 81       	ldd	r18, Z+6	; 0x06
    16b8:	37 81       	ldd	r19, Z+7	; 0x07
    16ba:	e9 81       	ldd	r30, Y+1	; 0x01
    16bc:	fa 81       	ldd	r31, Y+2	; 0x02
    16be:	80 81       	ld	r24, Z
    16c0:	91 81       	ldd	r25, Z+1	; 0x01
    16c2:	28 17       	cp	r18, r24
    16c4:	39 07       	cpc	r19, r25
    16c6:	90 f4       	brcc	.+36     	; 0x16ec <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    16c8:	e9 81       	ldd	r30, Y+1	; 0x01
    16ca:	fa 81       	ldd	r31, Y+2	; 0x02
    16cc:	22 81       	ldd	r18, Z+2	; 0x02
    16ce:	33 81       	ldd	r19, Z+3	; 0x03
    16d0:	e9 81       	ldd	r30, Y+1	; 0x01
    16d2:	fa 81       	ldd	r31, Y+2	; 0x02
    16d4:	84 8d       	ldd	r24, Z+28	; 0x1c
    16d6:	88 2f       	mov	r24, r24
    16d8:	90 e0       	ldi	r25, 0x00	; 0
    16da:	90 95       	com	r25
    16dc:	81 95       	neg	r24
    16de:	9f 4f       	sbci	r25, 0xFF	; 255
    16e0:	82 0f       	add	r24, r18
    16e2:	93 1f       	adc	r25, r19
    16e4:	e9 81       	ldd	r30, Y+1	; 0x01
    16e6:	fa 81       	ldd	r31, Y+2	; 0x02
    16e8:	97 83       	std	Z+7, r25	; 0x07
    16ea:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    16ec:	e9 81       	ldd	r30, Y+1	; 0x01
    16ee:	fa 81       	ldd	r31, Y+2	; 0x02
    16f0:	82 8d       	ldd	r24, Z+26	; 0x1a
    16f2:	8f 5f       	subi	r24, 0xFF	; 255
    16f4:	e9 81       	ldd	r30, Y+1	; 0x01
    16f6:	fa 81       	ldd	r31, Y+2	; 0x02
    16f8:	82 8f       	std	Z+26, r24	; 0x1a
}
    16fa:	0f 90       	pop	r0
    16fc:	0f 90       	pop	r0
    16fe:	0f 90       	pop	r0
    1700:	0f 90       	pop	r0
    1702:	0f 90       	pop	r0
    1704:	cf 91       	pop	r28
    1706:	df 91       	pop	r29
    1708:	08 95       	ret

0000170a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    170a:	df 93       	push	r29
    170c:	cf 93       	push	r28
    170e:	00 d0       	rcall	.+0      	; 0x1710 <prvCopyDataFromQueue+0x6>
    1710:	00 d0       	rcall	.+0      	; 0x1712 <prvCopyDataFromQueue+0x8>
    1712:	cd b7       	in	r28, 0x3d	; 61
    1714:	de b7       	in	r29, 0x3e	; 62
    1716:	9a 83       	std	Y+2, r25	; 0x02
    1718:	89 83       	std	Y+1, r24	; 0x01
    171a:	7c 83       	std	Y+4, r23	; 0x04
    171c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    171e:	e9 81       	ldd	r30, Y+1	; 0x01
    1720:	fa 81       	ldd	r31, Y+2	; 0x02
    1722:	80 81       	ld	r24, Z
    1724:	91 81       	ldd	r25, Z+1	; 0x01
    1726:	00 97       	sbiw	r24, 0x00	; 0
    1728:	89 f1       	breq	.+98     	; 0x178c <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    172a:	e9 81       	ldd	r30, Y+1	; 0x01
    172c:	fa 81       	ldd	r31, Y+2	; 0x02
    172e:	26 81       	ldd	r18, Z+6	; 0x06
    1730:	37 81       	ldd	r19, Z+7	; 0x07
    1732:	e9 81       	ldd	r30, Y+1	; 0x01
    1734:	fa 81       	ldd	r31, Y+2	; 0x02
    1736:	84 8d       	ldd	r24, Z+28	; 0x1c
    1738:	88 2f       	mov	r24, r24
    173a:	90 e0       	ldi	r25, 0x00	; 0
    173c:	82 0f       	add	r24, r18
    173e:	93 1f       	adc	r25, r19
    1740:	e9 81       	ldd	r30, Y+1	; 0x01
    1742:	fa 81       	ldd	r31, Y+2	; 0x02
    1744:	97 83       	std	Z+7, r25	; 0x07
    1746:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1748:	e9 81       	ldd	r30, Y+1	; 0x01
    174a:	fa 81       	ldd	r31, Y+2	; 0x02
    174c:	26 81       	ldd	r18, Z+6	; 0x06
    174e:	37 81       	ldd	r19, Z+7	; 0x07
    1750:	e9 81       	ldd	r30, Y+1	; 0x01
    1752:	fa 81       	ldd	r31, Y+2	; 0x02
    1754:	82 81       	ldd	r24, Z+2	; 0x02
    1756:	93 81       	ldd	r25, Z+3	; 0x03
    1758:	28 17       	cp	r18, r24
    175a:	39 07       	cpc	r19, r25
    175c:	40 f0       	brcs	.+16     	; 0x176e <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    175e:	e9 81       	ldd	r30, Y+1	; 0x01
    1760:	fa 81       	ldd	r31, Y+2	; 0x02
    1762:	80 81       	ld	r24, Z
    1764:	91 81       	ldd	r25, Z+1	; 0x01
    1766:	e9 81       	ldd	r30, Y+1	; 0x01
    1768:	fa 81       	ldd	r31, Y+2	; 0x02
    176a:	97 83       	std	Z+7, r25	; 0x07
    176c:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    176e:	e9 81       	ldd	r30, Y+1	; 0x01
    1770:	fa 81       	ldd	r31, Y+2	; 0x02
    1772:	46 81       	ldd	r20, Z+6	; 0x06
    1774:	57 81       	ldd	r21, Z+7	; 0x07
    1776:	e9 81       	ldd	r30, Y+1	; 0x01
    1778:	fa 81       	ldd	r31, Y+2	; 0x02
    177a:	84 8d       	ldd	r24, Z+28	; 0x1c
    177c:	28 2f       	mov	r18, r24
    177e:	30 e0       	ldi	r19, 0x00	; 0
    1780:	8b 81       	ldd	r24, Y+3	; 0x03
    1782:	9c 81       	ldd	r25, Y+4	; 0x04
    1784:	ba 01       	movw	r22, r20
    1786:	a9 01       	movw	r20, r18
    1788:	0e 94 78 13 	call	0x26f0	; 0x26f0 <memcpy>
	}
}
    178c:	0f 90       	pop	r0
    178e:	0f 90       	pop	r0
    1790:	0f 90       	pop	r0
    1792:	0f 90       	pop	r0
    1794:	cf 91       	pop	r28
    1796:	df 91       	pop	r29
    1798:	08 95       	ret

0000179a <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    179a:	df 93       	push	r29
    179c:	cf 93       	push	r28
    179e:	00 d0       	rcall	.+0      	; 0x17a0 <prvUnlockQueue+0x6>
    17a0:	cd b7       	in	r28, 0x3d	; 61
    17a2:	de b7       	in	r29, 0x3e	; 62
    17a4:	9a 83       	std	Y+2, r25	; 0x02
    17a6:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    17a8:	0f b6       	in	r0, 0x3f	; 63
    17aa:	f8 94       	cli
    17ac:	0f 92       	push	r0
    17ae:	15 c0       	rjmp	.+42     	; 0x17da <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17b0:	e9 81       	ldd	r30, Y+1	; 0x01
    17b2:	fa 81       	ldd	r31, Y+2	; 0x02
    17b4:	81 89       	ldd	r24, Z+17	; 0x11
    17b6:	88 23       	and	r24, r24
    17b8:	a9 f0       	breq	.+42     	; 0x17e4 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17ba:	89 81       	ldd	r24, Y+1	; 0x01
    17bc:	9a 81       	ldd	r25, Y+2	; 0x02
    17be:	41 96       	adiw	r24, 0x11	; 17
    17c0:	0e 94 05 11 	call	0x220a	; 0x220a <xTaskRemoveFromEventList>
    17c4:	88 23       	and	r24, r24
    17c6:	11 f0       	breq	.+4      	; 0x17cc <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    17c8:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    17cc:	e9 81       	ldd	r30, Y+1	; 0x01
    17ce:	fa 81       	ldd	r31, Y+2	; 0x02
    17d0:	86 8d       	ldd	r24, Z+30	; 0x1e
    17d2:	81 50       	subi	r24, 0x01	; 1
    17d4:	e9 81       	ldd	r30, Y+1	; 0x01
    17d6:	fa 81       	ldd	r31, Y+2	; 0x02
    17d8:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    17da:	e9 81       	ldd	r30, Y+1	; 0x01
    17dc:	fa 81       	ldd	r31, Y+2	; 0x02
    17de:	86 8d       	ldd	r24, Z+30	; 0x1e
    17e0:	18 16       	cp	r1, r24
    17e2:	34 f3       	brlt	.-52     	; 0x17b0 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    17e4:	e9 81       	ldd	r30, Y+1	; 0x01
    17e6:	fa 81       	ldd	r31, Y+2	; 0x02
    17e8:	8f ef       	ldi	r24, 0xFF	; 255
    17ea:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    17ec:	0f 90       	pop	r0
    17ee:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    17f0:	0f b6       	in	r0, 0x3f	; 63
    17f2:	f8 94       	cli
    17f4:	0f 92       	push	r0
    17f6:	15 c0       	rjmp	.+42     	; 0x1822 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17f8:	e9 81       	ldd	r30, Y+1	; 0x01
    17fa:	fa 81       	ldd	r31, Y+2	; 0x02
    17fc:	80 85       	ldd	r24, Z+8	; 0x08
    17fe:	88 23       	and	r24, r24
    1800:	a9 f0       	breq	.+42     	; 0x182c <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1802:	89 81       	ldd	r24, Y+1	; 0x01
    1804:	9a 81       	ldd	r25, Y+2	; 0x02
    1806:	08 96       	adiw	r24, 0x08	; 8
    1808:	0e 94 05 11 	call	0x220a	; 0x220a <xTaskRemoveFromEventList>
    180c:	88 23       	and	r24, r24
    180e:	11 f0       	breq	.+4      	; 0x1814 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    1810:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1814:	e9 81       	ldd	r30, Y+1	; 0x01
    1816:	fa 81       	ldd	r31, Y+2	; 0x02
    1818:	85 8d       	ldd	r24, Z+29	; 0x1d
    181a:	81 50       	subi	r24, 0x01	; 1
    181c:	e9 81       	ldd	r30, Y+1	; 0x01
    181e:	fa 81       	ldd	r31, Y+2	; 0x02
    1820:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1822:	e9 81       	ldd	r30, Y+1	; 0x01
    1824:	fa 81       	ldd	r31, Y+2	; 0x02
    1826:	85 8d       	ldd	r24, Z+29	; 0x1d
    1828:	18 16       	cp	r1, r24
    182a:	34 f3       	brlt	.-52     	; 0x17f8 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    182c:	e9 81       	ldd	r30, Y+1	; 0x01
    182e:	fa 81       	ldd	r31, Y+2	; 0x02
    1830:	8f ef       	ldi	r24, 0xFF	; 255
    1832:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1834:	0f 90       	pop	r0
    1836:	0f be       	out	0x3f, r0	; 63
}
    1838:	0f 90       	pop	r0
    183a:	0f 90       	pop	r0
    183c:	cf 91       	pop	r28
    183e:	df 91       	pop	r29
    1840:	08 95       	ret

00001842 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    1842:	df 93       	push	r29
    1844:	cf 93       	push	r28
    1846:	00 d0       	rcall	.+0      	; 0x1848 <prvIsQueueEmpty+0x6>
    1848:	0f 92       	push	r0
    184a:	cd b7       	in	r28, 0x3d	; 61
    184c:	de b7       	in	r29, 0x3e	; 62
    184e:	9b 83       	std	Y+3, r25	; 0x03
    1850:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1852:	0f b6       	in	r0, 0x3f	; 63
    1854:	f8 94       	cli
    1856:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1858:	ea 81       	ldd	r30, Y+2	; 0x02
    185a:	fb 81       	ldd	r31, Y+3	; 0x03
    185c:	82 8d       	ldd	r24, Z+26	; 0x1a
    185e:	19 82       	std	Y+1, r1	; 0x01
    1860:	88 23       	and	r24, r24
    1862:	11 f4       	brne	.+4      	; 0x1868 <prvIsQueueEmpty+0x26>
    1864:	81 e0       	ldi	r24, 0x01	; 1
    1866:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1868:	0f 90       	pop	r0
    186a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    186c:	89 81       	ldd	r24, Y+1	; 0x01
}
    186e:	0f 90       	pop	r0
    1870:	0f 90       	pop	r0
    1872:	0f 90       	pop	r0
    1874:	cf 91       	pop	r28
    1876:	df 91       	pop	r29
    1878:	08 95       	ret

0000187a <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    187a:	df 93       	push	r29
    187c:	cf 93       	push	r28
    187e:	00 d0       	rcall	.+0      	; 0x1880 <xQueueIsQueueEmptyFromISR+0x6>
    1880:	0f 92       	push	r0
    1882:	cd b7       	in	r28, 0x3d	; 61
    1884:	de b7       	in	r29, 0x3e	; 62
    1886:	9b 83       	std	Y+3, r25	; 0x03
    1888:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    188a:	ea 81       	ldd	r30, Y+2	; 0x02
    188c:	fb 81       	ldd	r31, Y+3	; 0x03
    188e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1890:	19 82       	std	Y+1, r1	; 0x01
    1892:	88 23       	and	r24, r24
    1894:	11 f4       	brne	.+4      	; 0x189a <xQueueIsQueueEmptyFromISR+0x20>
    1896:	81 e0       	ldi	r24, 0x01	; 1
    1898:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    189a:	89 81       	ldd	r24, Y+1	; 0x01
}
    189c:	0f 90       	pop	r0
    189e:	0f 90       	pop	r0
    18a0:	0f 90       	pop	r0
    18a2:	cf 91       	pop	r28
    18a4:	df 91       	pop	r29
    18a6:	08 95       	ret

000018a8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    18a8:	df 93       	push	r29
    18aa:	cf 93       	push	r28
    18ac:	00 d0       	rcall	.+0      	; 0x18ae <prvIsQueueFull+0x6>
    18ae:	0f 92       	push	r0
    18b0:	cd b7       	in	r28, 0x3d	; 61
    18b2:	de b7       	in	r29, 0x3e	; 62
    18b4:	9b 83       	std	Y+3, r25	; 0x03
    18b6:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    18b8:	0f b6       	in	r0, 0x3f	; 63
    18ba:	f8 94       	cli
    18bc:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    18be:	ea 81       	ldd	r30, Y+2	; 0x02
    18c0:	fb 81       	ldd	r31, Y+3	; 0x03
    18c2:	92 8d       	ldd	r25, Z+26	; 0x1a
    18c4:	ea 81       	ldd	r30, Y+2	; 0x02
    18c6:	fb 81       	ldd	r31, Y+3	; 0x03
    18c8:	83 8d       	ldd	r24, Z+27	; 0x1b
    18ca:	19 82       	std	Y+1, r1	; 0x01
    18cc:	98 17       	cp	r25, r24
    18ce:	11 f4       	brne	.+4      	; 0x18d4 <prvIsQueueFull+0x2c>
    18d0:	81 e0       	ldi	r24, 0x01	; 1
    18d2:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    18d4:	0f 90       	pop	r0
    18d6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    18d8:	89 81       	ldd	r24, Y+1	; 0x01
}
    18da:	0f 90       	pop	r0
    18dc:	0f 90       	pop	r0
    18de:	0f 90       	pop	r0
    18e0:	cf 91       	pop	r28
    18e2:	df 91       	pop	r29
    18e4:	08 95       	ret

000018e6 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    18e6:	df 93       	push	r29
    18e8:	cf 93       	push	r28
    18ea:	00 d0       	rcall	.+0      	; 0x18ec <xQueueIsQueueFullFromISR+0x6>
    18ec:	0f 92       	push	r0
    18ee:	cd b7       	in	r28, 0x3d	; 61
    18f0:	de b7       	in	r29, 0x3e	; 62
    18f2:	9b 83       	std	Y+3, r25	; 0x03
    18f4:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    18f6:	ea 81       	ldd	r30, Y+2	; 0x02
    18f8:	fb 81       	ldd	r31, Y+3	; 0x03
    18fa:	92 8d       	ldd	r25, Z+26	; 0x1a
    18fc:	ea 81       	ldd	r30, Y+2	; 0x02
    18fe:	fb 81       	ldd	r31, Y+3	; 0x03
    1900:	83 8d       	ldd	r24, Z+27	; 0x1b
    1902:	19 82       	std	Y+1, r1	; 0x01
    1904:	98 17       	cp	r25, r24
    1906:	11 f4       	brne	.+4      	; 0x190c <xQueueIsQueueFullFromISR+0x26>
    1908:	81 e0       	ldi	r24, 0x01	; 1
    190a:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    190c:	89 81       	ldd	r24, Y+1	; 0x01
}
    190e:	0f 90       	pop	r0
    1910:	0f 90       	pop	r0
    1912:	0f 90       	pop	r0
    1914:	cf 91       	pop	r28
    1916:	df 91       	pop	r29
    1918:	08 95       	ret

0000191a <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    191a:	af 92       	push	r10
    191c:	bf 92       	push	r11
    191e:	cf 92       	push	r12
    1920:	df 92       	push	r13
    1922:	ef 92       	push	r14
    1924:	ff 92       	push	r15
    1926:	0f 93       	push	r16
    1928:	1f 93       	push	r17
    192a:	df 93       	push	r29
    192c:	cf 93       	push	r28
    192e:	cd b7       	in	r28, 0x3d	; 61
    1930:	de b7       	in	r29, 0x3e	; 62
    1932:	64 97       	sbiw	r28, 0x14	; 20
    1934:	0f b6       	in	r0, 0x3f	; 63
    1936:	f8 94       	cli
    1938:	de bf       	out	0x3e, r29	; 62
    193a:	0f be       	out	0x3f, r0	; 63
    193c:	cd bf       	out	0x3d, r28	; 61
    193e:	9f 83       	std	Y+7, r25	; 0x07
    1940:	8e 83       	std	Y+6, r24	; 0x06
    1942:	79 87       	std	Y+9, r23	; 0x09
    1944:	68 87       	std	Y+8, r22	; 0x08
    1946:	5b 87       	std	Y+11, r21	; 0x0b
    1948:	4a 87       	std	Y+10, r20	; 0x0a
    194a:	3d 87       	std	Y+13, r19	; 0x0d
    194c:	2c 87       	std	Y+12, r18	; 0x0c
    194e:	0e 87       	std	Y+14, r16	; 0x0e
    1950:	f8 8a       	std	Y+16, r15	; 0x10
    1952:	ef 86       	std	Y+15, r14	; 0x0f
    1954:	da 8a       	std	Y+18, r13	; 0x12
    1956:	c9 8a       	std	Y+17, r12	; 0x11
    1958:	bc 8a       	std	Y+20, r11	; 0x14
    195a:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    195c:	8a 85       	ldd	r24, Y+10	; 0x0a
    195e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1960:	29 89       	ldd	r18, Y+17	; 0x11
    1962:	3a 89       	ldd	r19, Y+18	; 0x12
    1964:	b9 01       	movw	r22, r18
    1966:	0e 94 12 13 	call	0x2624	; 0x2624 <prvAllocateTCBAndStack>
    196a:	9c 83       	std	Y+4, r25	; 0x04
    196c:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    196e:	8b 81       	ldd	r24, Y+3	; 0x03
    1970:	9c 81       	ldd	r25, Y+4	; 0x04
    1972:	00 97       	sbiw	r24, 0x00	; 0
    1974:	09 f4       	brne	.+2      	; 0x1978 <xTaskGenericCreate+0x5e>
    1976:	99 c0       	rjmp	.+306    	; 0x1aaa <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1978:	eb 81       	ldd	r30, Y+3	; 0x03
    197a:	fc 81       	ldd	r31, Y+4	; 0x04
    197c:	27 89       	ldd	r18, Z+23	; 0x17
    197e:	30 8d       	ldd	r19, Z+24	; 0x18
    1980:	8a 85       	ldd	r24, Y+10	; 0x0a
    1982:	9b 85       	ldd	r25, Y+11	; 0x0b
    1984:	01 97       	sbiw	r24, 0x01	; 1
    1986:	82 0f       	add	r24, r18
    1988:	93 1f       	adc	r25, r19
    198a:	9a 83       	std	Y+2, r25	; 0x02
    198c:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    198e:	8b 81       	ldd	r24, Y+3	; 0x03
    1990:	9c 81       	ldd	r25, Y+4	; 0x04
    1992:	28 85       	ldd	r18, Y+8	; 0x08
    1994:	39 85       	ldd	r19, Y+9	; 0x09
    1996:	eb 89       	ldd	r30, Y+19	; 0x13
    1998:	fc 89       	ldd	r31, Y+20	; 0x14
    199a:	aa 85       	ldd	r26, Y+10	; 0x0a
    199c:	bb 85       	ldd	r27, Y+11	; 0x0b
    199e:	b9 01       	movw	r22, r18
    19a0:	4e 85       	ldd	r20, Y+14	; 0x0e
    19a2:	9f 01       	movw	r18, r30
    19a4:	8d 01       	movw	r16, r26
    19a6:	0e 94 f7 11 	call	0x23ee	; 0x23ee <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    19aa:	89 81       	ldd	r24, Y+1	; 0x01
    19ac:	9a 81       	ldd	r25, Y+2	; 0x02
    19ae:	2e 81       	ldd	r18, Y+6	; 0x06
    19b0:	3f 81       	ldd	r19, Y+7	; 0x07
    19b2:	4c 85       	ldd	r20, Y+12	; 0x0c
    19b4:	5d 85       	ldd	r21, Y+13	; 0x0d
    19b6:	b9 01       	movw	r22, r18
    19b8:	0e 94 3a 05 	call	0xa74	; 0xa74 <pxPortInitialiseStack>
    19bc:	eb 81       	ldd	r30, Y+3	; 0x03
    19be:	fc 81       	ldd	r31, Y+4	; 0x04
    19c0:	91 83       	std	Z+1, r25	; 0x01
    19c2:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    19c4:	8f 85       	ldd	r24, Y+15	; 0x0f
    19c6:	98 89       	ldd	r25, Y+16	; 0x10
    19c8:	00 97       	sbiw	r24, 0x00	; 0
    19ca:	31 f0       	breq	.+12     	; 0x19d8 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    19cc:	ef 85       	ldd	r30, Y+15	; 0x0f
    19ce:	f8 89       	ldd	r31, Y+16	; 0x10
    19d0:	8b 81       	ldd	r24, Y+3	; 0x03
    19d2:	9c 81       	ldd	r25, Y+4	; 0x04
    19d4:	91 83       	std	Z+1, r25	; 0x01
    19d6:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    19d8:	0f b6       	in	r0, 0x3f	; 63
    19da:	f8 94       	cli
    19dc:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    19de:	80 91 ff 02 	lds	r24, 0x02FF
    19e2:	8f 5f       	subi	r24, 0xFF	; 255
    19e4:	80 93 ff 02 	sts	0x02FF, r24
			if( pxCurrentTCB == NULL )
    19e8:	80 91 fc 02 	lds	r24, 0x02FC
    19ec:	90 91 fd 02 	lds	r25, 0x02FD
    19f0:	00 97       	sbiw	r24, 0x00	; 0
    19f2:	69 f4       	brne	.+26     	; 0x1a0e <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    19f4:	8b 81       	ldd	r24, Y+3	; 0x03
    19f6:	9c 81       	ldd	r25, Y+4	; 0x04
    19f8:	90 93 fd 02 	sts	0x02FD, r25
    19fc:	80 93 fc 02 	sts	0x02FC, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1a00:	80 91 ff 02 	lds	r24, 0x02FF
    1a04:	81 30       	cpi	r24, 0x01	; 1
    1a06:	a9 f4       	brne	.+42     	; 0x1a32 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1a08:	0e 94 4e 12 	call	0x249c	; 0x249c <prvInitialiseTaskLists>
    1a0c:	12 c0       	rjmp	.+36     	; 0x1a32 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1a0e:	80 91 04 03 	lds	r24, 0x0304
    1a12:	88 23       	and	r24, r24
    1a14:	71 f4       	brne	.+28     	; 0x1a32 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1a16:	e0 91 fc 02 	lds	r30, 0x02FC
    1a1a:	f0 91 fd 02 	lds	r31, 0x02FD
    1a1e:	96 89       	ldd	r25, Z+22	; 0x16
    1a20:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a22:	89 17       	cp	r24, r25
    1a24:	30 f0       	brcs	.+12     	; 0x1a32 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    1a26:	8b 81       	ldd	r24, Y+3	; 0x03
    1a28:	9c 81       	ldd	r25, Y+4	; 0x04
    1a2a:	90 93 fd 02 	sts	0x02FD, r25
    1a2e:	80 93 fc 02 	sts	0x02FC, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1a32:	eb 81       	ldd	r30, Y+3	; 0x03
    1a34:	fc 81       	ldd	r31, Y+4	; 0x04
    1a36:	96 89       	ldd	r25, Z+22	; 0x16
    1a38:	80 91 02 03 	lds	r24, 0x0302
    1a3c:	89 17       	cp	r24, r25
    1a3e:	28 f4       	brcc	.+10     	; 0x1a4a <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1a40:	eb 81       	ldd	r30, Y+3	; 0x03
    1a42:	fc 81       	ldd	r31, Y+4	; 0x04
    1a44:	86 89       	ldd	r24, Z+22	; 0x16
    1a46:	80 93 02 03 	sts	0x0302, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1a4a:	80 91 09 03 	lds	r24, 0x0309
    1a4e:	8f 5f       	subi	r24, 0xFF	; 255
    1a50:	80 93 09 03 	sts	0x0309, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1a54:	eb 81       	ldd	r30, Y+3	; 0x03
    1a56:	fc 81       	ldd	r31, Y+4	; 0x04
    1a58:	96 89       	ldd	r25, Z+22	; 0x16
    1a5a:	80 91 03 03 	lds	r24, 0x0303
    1a5e:	89 17       	cp	r24, r25
    1a60:	28 f4       	brcc	.+10     	; 0x1a6c <xTaskGenericCreate+0x152>
    1a62:	eb 81       	ldd	r30, Y+3	; 0x03
    1a64:	fc 81       	ldd	r31, Y+4	; 0x04
    1a66:	86 89       	ldd	r24, Z+22	; 0x16
    1a68:	80 93 03 03 	sts	0x0303, r24
    1a6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1a70:	86 89       	ldd	r24, Z+22	; 0x16
    1a72:	28 2f       	mov	r18, r24
    1a74:	30 e0       	ldi	r19, 0x00	; 0
    1a76:	c9 01       	movw	r24, r18
    1a78:	88 0f       	add	r24, r24
    1a7a:	99 1f       	adc	r25, r25
    1a7c:	88 0f       	add	r24, r24
    1a7e:	99 1f       	adc	r25, r25
    1a80:	88 0f       	add	r24, r24
    1a82:	99 1f       	adc	r25, r25
    1a84:	82 0f       	add	r24, r18
    1a86:	93 1f       	adc	r25, r19
    1a88:	ac 01       	movw	r20, r24
    1a8a:	46 5f       	subi	r20, 0xF6	; 246
    1a8c:	5c 4f       	sbci	r21, 0xFC	; 252
    1a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a90:	9c 81       	ldd	r25, Y+4	; 0x04
    1a92:	9c 01       	movw	r18, r24
    1a94:	2e 5f       	subi	r18, 0xFE	; 254
    1a96:	3f 4f       	sbci	r19, 0xFF	; 255
    1a98:	ca 01       	movw	r24, r20
    1a9a:	b9 01       	movw	r22, r18
    1a9c:	0e 94 39 04 	call	0x872	; 0x872 <vListInsertEnd>

			xReturn = pdPASS;
    1aa0:	81 e0       	ldi	r24, 0x01	; 1
    1aa2:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1aa4:	0f 90       	pop	r0
    1aa6:	0f be       	out	0x3f, r0	; 63
    1aa8:	02 c0       	rjmp	.+4      	; 0x1aae <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1aaa:	8f ef       	ldi	r24, 0xFF	; 255
    1aac:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1aae:	8d 81       	ldd	r24, Y+5	; 0x05
    1ab0:	81 30       	cpi	r24, 0x01	; 1
    1ab2:	71 f4       	brne	.+28     	; 0x1ad0 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    1ab4:	80 91 04 03 	lds	r24, 0x0304
    1ab8:	88 23       	and	r24, r24
    1aba:	51 f0       	breq	.+20     	; 0x1ad0 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1abc:	e0 91 fc 02 	lds	r30, 0x02FC
    1ac0:	f0 91 fd 02 	lds	r31, 0x02FD
    1ac4:	96 89       	ldd	r25, Z+22	; 0x16
    1ac6:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ac8:	98 17       	cp	r25, r24
    1aca:	10 f4       	brcc	.+4      	; 0x1ad0 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1acc:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vPortYield>
			}
		}
	}

	return xReturn;
    1ad0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1ad2:	64 96       	adiw	r28, 0x14	; 20
    1ad4:	0f b6       	in	r0, 0x3f	; 63
    1ad6:	f8 94       	cli
    1ad8:	de bf       	out	0x3e, r29	; 62
    1ada:	0f be       	out	0x3f, r0	; 63
    1adc:	cd bf       	out	0x3d, r28	; 61
    1ade:	cf 91       	pop	r28
    1ae0:	df 91       	pop	r29
    1ae2:	1f 91       	pop	r17
    1ae4:	0f 91       	pop	r16
    1ae6:	ff 90       	pop	r15
    1ae8:	ef 90       	pop	r14
    1aea:	df 90       	pop	r13
    1aec:	cf 90       	pop	r12
    1aee:	bf 90       	pop	r11
    1af0:	af 90       	pop	r10
    1af2:	08 95       	ret

00001af4 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1af4:	df 93       	push	r29
    1af6:	cf 93       	push	r28
    1af8:	00 d0       	rcall	.+0      	; 0x1afa <vTaskDelete+0x6>
    1afa:	00 d0       	rcall	.+0      	; 0x1afc <vTaskDelete+0x8>
    1afc:	00 d0       	rcall	.+0      	; 0x1afe <vTaskDelete+0xa>
    1afe:	cd b7       	in	r28, 0x3d	; 61
    1b00:	de b7       	in	r29, 0x3e	; 62
    1b02:	9c 83       	std	Y+4, r25	; 0x04
    1b04:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1b06:	0f b6       	in	r0, 0x3f	; 63
    1b08:	f8 94       	cli
    1b0a:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1b0c:	20 91 fc 02 	lds	r18, 0x02FC
    1b10:	30 91 fd 02 	lds	r19, 0x02FD
    1b14:	8b 81       	ldd	r24, Y+3	; 0x03
    1b16:	9c 81       	ldd	r25, Y+4	; 0x04
    1b18:	82 17       	cp	r24, r18
    1b1a:	93 07       	cpc	r25, r19
    1b1c:	11 f4       	brne	.+4      	; 0x1b22 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1b1e:	1c 82       	std	Y+4, r1	; 0x04
    1b20:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1b22:	8b 81       	ldd	r24, Y+3	; 0x03
    1b24:	9c 81       	ldd	r25, Y+4	; 0x04
    1b26:	00 97       	sbiw	r24, 0x00	; 0
    1b28:	39 f4       	brne	.+14     	; 0x1b38 <vTaskDelete+0x44>
    1b2a:	80 91 fc 02 	lds	r24, 0x02FC
    1b2e:	90 91 fd 02 	lds	r25, 0x02FD
    1b32:	9e 83       	std	Y+6, r25	; 0x06
    1b34:	8d 83       	std	Y+5, r24	; 0x05
    1b36:	04 c0       	rjmp	.+8      	; 0x1b40 <vTaskDelete+0x4c>
    1b38:	8b 81       	ldd	r24, Y+3	; 0x03
    1b3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b3c:	9e 83       	std	Y+6, r25	; 0x06
    1b3e:	8d 83       	std	Y+5, r24	; 0x05
    1b40:	8d 81       	ldd	r24, Y+5	; 0x05
    1b42:	9e 81       	ldd	r25, Y+6	; 0x06
    1b44:	9a 83       	std	Y+2, r25	; 0x02
    1b46:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1b48:	89 81       	ldd	r24, Y+1	; 0x01
    1b4a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b4c:	02 96       	adiw	r24, 0x02	; 2
    1b4e:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1b52:	e9 81       	ldd	r30, Y+1	; 0x01
    1b54:	fa 81       	ldd	r31, Y+2	; 0x02
    1b56:	84 89       	ldd	r24, Z+20	; 0x14
    1b58:	95 89       	ldd	r25, Z+21	; 0x15
    1b5a:	00 97       	sbiw	r24, 0x00	; 0
    1b5c:	29 f0       	breq	.+10     	; 0x1b68 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1b5e:	89 81       	ldd	r24, Y+1	; 0x01
    1b60:	9a 81       	ldd	r25, Y+2	; 0x02
    1b62:	0c 96       	adiw	r24, 0x0c	; 12
    1b64:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1b68:	89 81       	ldd	r24, Y+1	; 0x01
    1b6a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b6c:	9c 01       	movw	r18, r24
    1b6e:	2e 5f       	subi	r18, 0xFE	; 254
    1b70:	3f 4f       	sbci	r19, 0xFF	; 255
    1b72:	84 e4       	ldi	r24, 0x44	; 68
    1b74:	93 e0       	ldi	r25, 0x03	; 3
    1b76:	b9 01       	movw	r22, r18
    1b78:	0e 94 39 04 	call	0x872	; 0x872 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1b7c:	80 91 fe 02 	lds	r24, 0x02FE
    1b80:	8f 5f       	subi	r24, 0xFF	; 255
    1b82:	80 93 fe 02 	sts	0x02FE, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1b86:	80 91 09 03 	lds	r24, 0x0309
    1b8a:	8f 5f       	subi	r24, 0xFF	; 255
    1b8c:	80 93 09 03 	sts	0x0309, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1b90:	0f 90       	pop	r0
    1b92:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1b94:	80 91 04 03 	lds	r24, 0x0304
    1b98:	88 23       	and	r24, r24
    1b9a:	31 f0       	breq	.+12     	; 0x1ba8 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1b9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b9e:	9c 81       	ldd	r25, Y+4	; 0x04
    1ba0:	00 97       	sbiw	r24, 0x00	; 0
    1ba2:	11 f4       	brne	.+4      	; 0x1ba8 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1ba4:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vPortYield>
			}
		}
	}
    1ba8:	26 96       	adiw	r28, 0x06	; 6
    1baa:	0f b6       	in	r0, 0x3f	; 63
    1bac:	f8 94       	cli
    1bae:	de bf       	out	0x3e, r29	; 62
    1bb0:	0f be       	out	0x3f, r0	; 63
    1bb2:	cd bf       	out	0x3d, r28	; 61
    1bb4:	cf 91       	pop	r28
    1bb6:	df 91       	pop	r29
    1bb8:	08 95       	ret

00001bba <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1bba:	df 93       	push	r29
    1bbc:	cf 93       	push	r28
    1bbe:	cd b7       	in	r28, 0x3d	; 61
    1bc0:	de b7       	in	r29, 0x3e	; 62
    1bc2:	28 97       	sbiw	r28, 0x08	; 8
    1bc4:	0f b6       	in	r0, 0x3f	; 63
    1bc6:	f8 94       	cli
    1bc8:	de bf       	out	0x3e, r29	; 62
    1bca:	0f be       	out	0x3f, r0	; 63
    1bcc:	cd bf       	out	0x3d, r28	; 61
    1bce:	9e 83       	std	Y+6, r25	; 0x06
    1bd0:	8d 83       	std	Y+5, r24	; 0x05
    1bd2:	78 87       	std	Y+8, r23	; 0x08
    1bd4:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1bd6:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1bd8:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1bdc:	ed 81       	ldd	r30, Y+5	; 0x05
    1bde:	fe 81       	ldd	r31, Y+6	; 0x06
    1be0:	20 81       	ld	r18, Z
    1be2:	31 81       	ldd	r19, Z+1	; 0x01
    1be4:	8f 81       	ldd	r24, Y+7	; 0x07
    1be6:	98 85       	ldd	r25, Y+8	; 0x08
    1be8:	82 0f       	add	r24, r18
    1bea:	93 1f       	adc	r25, r19
    1bec:	9c 83       	std	Y+4, r25	; 0x04
    1bee:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    1bf0:	ed 81       	ldd	r30, Y+5	; 0x05
    1bf2:	fe 81       	ldd	r31, Y+6	; 0x06
    1bf4:	20 81       	ld	r18, Z
    1bf6:	31 81       	ldd	r19, Z+1	; 0x01
    1bf8:	80 91 00 03 	lds	r24, 0x0300
    1bfc:	90 91 01 03 	lds	r25, 0x0301
    1c00:	82 17       	cp	r24, r18
    1c02:	93 07       	cpc	r25, r19
    1c04:	a8 f4       	brcc	.+42     	; 0x1c30 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1c06:	ed 81       	ldd	r30, Y+5	; 0x05
    1c08:	fe 81       	ldd	r31, Y+6	; 0x06
    1c0a:	20 81       	ld	r18, Z
    1c0c:	31 81       	ldd	r19, Z+1	; 0x01
    1c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c10:	9c 81       	ldd	r25, Y+4	; 0x04
    1c12:	82 17       	cp	r24, r18
    1c14:	93 07       	cpc	r25, r19
    1c16:	00 f5       	brcc	.+64     	; 0x1c58 <vTaskDelayUntil+0x9e>
    1c18:	20 91 00 03 	lds	r18, 0x0300
    1c1c:	30 91 01 03 	lds	r19, 0x0301
    1c20:	8b 81       	ldd	r24, Y+3	; 0x03
    1c22:	9c 81       	ldd	r25, Y+4	; 0x04
    1c24:	28 17       	cp	r18, r24
    1c26:	39 07       	cpc	r19, r25
    1c28:	b8 f4       	brcc	.+46     	; 0x1c58 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1c2a:	81 e0       	ldi	r24, 0x01	; 1
    1c2c:	89 83       	std	Y+1, r24	; 0x01
    1c2e:	14 c0       	rjmp	.+40     	; 0x1c58 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1c30:	ed 81       	ldd	r30, Y+5	; 0x05
    1c32:	fe 81       	ldd	r31, Y+6	; 0x06
    1c34:	20 81       	ld	r18, Z
    1c36:	31 81       	ldd	r19, Z+1	; 0x01
    1c38:	8b 81       	ldd	r24, Y+3	; 0x03
    1c3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c3c:	82 17       	cp	r24, r18
    1c3e:	93 07       	cpc	r25, r19
    1c40:	48 f0       	brcs	.+18     	; 0x1c54 <vTaskDelayUntil+0x9a>
    1c42:	20 91 00 03 	lds	r18, 0x0300
    1c46:	30 91 01 03 	lds	r19, 0x0301
    1c4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c4e:	28 17       	cp	r18, r24
    1c50:	39 07       	cpc	r19, r25
    1c52:	10 f4       	brcc	.+4      	; 0x1c58 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1c54:	81 e0       	ldi	r24, 0x01	; 1
    1c56:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1c58:	ed 81       	ldd	r30, Y+5	; 0x05
    1c5a:	fe 81       	ldd	r31, Y+6	; 0x06
    1c5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c60:	91 83       	std	Z+1, r25	; 0x01
    1c62:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1c64:	89 81       	ldd	r24, Y+1	; 0x01
    1c66:	88 23       	and	r24, r24
    1c68:	59 f0       	breq	.+22     	; 0x1c80 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c6a:	80 91 fc 02 	lds	r24, 0x02FC
    1c6e:	90 91 fd 02 	lds	r25, 0x02FD
    1c72:	02 96       	adiw	r24, 0x02	; 2
    1c74:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1c78:	8b 81       	ldd	r24, Y+3	; 0x03
    1c7a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c7c:	0e 94 c9 12 	call	0x2592	; 0x2592 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1c80:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <xTaskResumeAll>
    1c84:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1c86:	8a 81       	ldd	r24, Y+2	; 0x02
    1c88:	88 23       	and	r24, r24
    1c8a:	11 f4       	brne	.+4      	; 0x1c90 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    1c8c:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vPortYield>
		}
	}
    1c90:	28 96       	adiw	r28, 0x08	; 8
    1c92:	0f b6       	in	r0, 0x3f	; 63
    1c94:	f8 94       	cli
    1c96:	de bf       	out	0x3e, r29	; 62
    1c98:	0f be       	out	0x3f, r0	; 63
    1c9a:	cd bf       	out	0x3d, r28	; 61
    1c9c:	cf 91       	pop	r28
    1c9e:	df 91       	pop	r29
    1ca0:	08 95       	ret

00001ca2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1ca2:	df 93       	push	r29
    1ca4:	cf 93       	push	r28
    1ca6:	00 d0       	rcall	.+0      	; 0x1ca8 <vTaskDelay+0x6>
    1ca8:	00 d0       	rcall	.+0      	; 0x1caa <vTaskDelay+0x8>
    1caa:	0f 92       	push	r0
    1cac:	cd b7       	in	r28, 0x3d	; 61
    1cae:	de b7       	in	r29, 0x3e	; 62
    1cb0:	9d 83       	std	Y+5, r25	; 0x05
    1cb2:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1cb4:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1cb6:	8c 81       	ldd	r24, Y+4	; 0x04
    1cb8:	9d 81       	ldd	r25, Y+5	; 0x05
    1cba:	00 97       	sbiw	r24, 0x00	; 0
    1cbc:	d1 f0       	breq	.+52     	; 0x1cf2 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    1cbe:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1cc2:	20 91 00 03 	lds	r18, 0x0300
    1cc6:	30 91 01 03 	lds	r19, 0x0301
    1cca:	8c 81       	ldd	r24, Y+4	; 0x04
    1ccc:	9d 81       	ldd	r25, Y+5	; 0x05
    1cce:	82 0f       	add	r24, r18
    1cd0:	93 1f       	adc	r25, r19
    1cd2:	9b 83       	std	Y+3, r25	; 0x03
    1cd4:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1cd6:	80 91 fc 02 	lds	r24, 0x02FC
    1cda:	90 91 fd 02 	lds	r25, 0x02FD
    1cde:	02 96       	adiw	r24, 0x02	; 2
    1ce0:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1ce4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ce6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ce8:	0e 94 c9 12 	call	0x2592	; 0x2592 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1cec:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <xTaskResumeAll>
    1cf0:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1cf2:	89 81       	ldd	r24, Y+1	; 0x01
    1cf4:	88 23       	and	r24, r24
    1cf6:	11 f4       	brne	.+4      	; 0x1cfc <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    1cf8:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vPortYield>
		}
	}
    1cfc:	0f 90       	pop	r0
    1cfe:	0f 90       	pop	r0
    1d00:	0f 90       	pop	r0
    1d02:	0f 90       	pop	r0
    1d04:	0f 90       	pop	r0
    1d06:	cf 91       	pop	r28
    1d08:	df 91       	pop	r29
    1d0a:	08 95       	ret

00001d0c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1d0c:	af 92       	push	r10
    1d0e:	bf 92       	push	r11
    1d10:	cf 92       	push	r12
    1d12:	df 92       	push	r13
    1d14:	ef 92       	push	r14
    1d16:	ff 92       	push	r15
    1d18:	0f 93       	push	r16
    1d1a:	df 93       	push	r29
    1d1c:	cf 93       	push	r28
    1d1e:	0f 92       	push	r0
    1d20:	cd b7       	in	r28, 0x3d	; 61
    1d22:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1d24:	20 e6       	ldi	r18, 0x60	; 96
    1d26:	30 e0       	ldi	r19, 0x00	; 0
    1d28:	8d ee       	ldi	r24, 0xED	; 237
    1d2a:	91 e1       	ldi	r25, 0x11	; 17
    1d2c:	b9 01       	movw	r22, r18
    1d2e:	45 e5       	ldi	r20, 0x55	; 85
    1d30:	50 e0       	ldi	r21, 0x00	; 0
    1d32:	20 e0       	ldi	r18, 0x00	; 0
    1d34:	30 e0       	ldi	r19, 0x00	; 0
    1d36:	00 e0       	ldi	r16, 0x00	; 0
    1d38:	ee 24       	eor	r14, r14
    1d3a:	ff 24       	eor	r15, r15
    1d3c:	cc 24       	eor	r12, r12
    1d3e:	dd 24       	eor	r13, r13
    1d40:	aa 24       	eor	r10, r10
    1d42:	bb 24       	eor	r11, r11
    1d44:	0e 94 8d 0c 	call	0x191a	; 0x191a <xTaskGenericCreate>
    1d48:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1d4a:	89 81       	ldd	r24, Y+1	; 0x01
    1d4c:	81 30       	cpi	r24, 0x01	; 1
    1d4e:	51 f4       	brne	.+20     	; 0x1d64 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1d50:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1d52:	81 e0       	ldi	r24, 0x01	; 1
    1d54:	80 93 04 03 	sts	0x0304, r24
		xTickCount = ( portTickType ) 0U;
    1d58:	10 92 01 03 	sts	0x0301, r1
    1d5c:	10 92 00 03 	sts	0x0300, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1d60:	0e 94 bd 06 	call	0xd7a	; 0xd7a <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1d64:	0f 90       	pop	r0
    1d66:	cf 91       	pop	r28
    1d68:	df 91       	pop	r29
    1d6a:	0f 91       	pop	r16
    1d6c:	ff 90       	pop	r15
    1d6e:	ef 90       	pop	r14
    1d70:	df 90       	pop	r13
    1d72:	cf 90       	pop	r12
    1d74:	bf 90       	pop	r11
    1d76:	af 90       	pop	r10
    1d78:	08 95       	ret

00001d7a <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    1d7a:	df 93       	push	r29
    1d7c:	cf 93       	push	r28
    1d7e:	cd b7       	in	r28, 0x3d	; 61
    1d80:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1d82:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1d84:	10 92 04 03 	sts	0x0304, r1
	vPortEndScheduler();
    1d88:	0e 94 f2 06 	call	0xde4	; 0xde4 <vPortEndScheduler>
}
    1d8c:	cf 91       	pop	r28
    1d8e:	df 91       	pop	r29
    1d90:	08 95       	ret

00001d92 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    1d92:	df 93       	push	r29
    1d94:	cf 93       	push	r28
    1d96:	cd b7       	in	r28, 0x3d	; 61
    1d98:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1d9a:	80 91 05 03 	lds	r24, 0x0305
    1d9e:	8f 5f       	subi	r24, 0xFF	; 255
    1da0:	80 93 05 03 	sts	0x0305, r24
}
    1da4:	cf 91       	pop	r28
    1da6:	df 91       	pop	r29
    1da8:	08 95       	ret

00001daa <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1daa:	df 93       	push	r29
    1dac:	cf 93       	push	r28
    1dae:	00 d0       	rcall	.+0      	; 0x1db0 <xTaskResumeAll+0x6>
    1db0:	00 d0       	rcall	.+0      	; 0x1db2 <xTaskResumeAll+0x8>
    1db2:	cd b7       	in	r28, 0x3d	; 61
    1db4:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1db6:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1db8:	0f b6       	in	r0, 0x3f	; 63
    1dba:	f8 94       	cli
    1dbc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1dbe:	80 91 05 03 	lds	r24, 0x0305
    1dc2:	81 50       	subi	r24, 0x01	; 1
    1dc4:	80 93 05 03 	sts	0x0305, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1dc8:	80 91 05 03 	lds	r24, 0x0305
    1dcc:	88 23       	and	r24, r24
    1dce:	09 f0       	breq	.+2      	; 0x1dd2 <xTaskResumeAll+0x28>
    1dd0:	6c c0       	rjmp	.+216    	; 0x1eaa <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1dd2:	80 91 ff 02 	lds	r24, 0x02FF
    1dd6:	88 23       	and	r24, r24
    1dd8:	09 f4       	brne	.+2      	; 0x1ddc <xTaskResumeAll+0x32>
    1dda:	67 c0       	rjmp	.+206    	; 0x1eaa <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    1ddc:	19 82       	std	Y+1, r1	; 0x01
    1dde:	41 c0       	rjmp	.+130    	; 0x1e62 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1de0:	e0 91 40 03 	lds	r30, 0x0340
    1de4:	f0 91 41 03 	lds	r31, 0x0341
    1de8:	86 81       	ldd	r24, Z+6	; 0x06
    1dea:	97 81       	ldd	r25, Z+7	; 0x07
    1dec:	9c 83       	std	Y+4, r25	; 0x04
    1dee:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    1df0:	8b 81       	ldd	r24, Y+3	; 0x03
    1df2:	9c 81       	ldd	r25, Y+4	; 0x04
    1df4:	0c 96       	adiw	r24, 0x0c	; 12
    1df6:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1dfa:	8b 81       	ldd	r24, Y+3	; 0x03
    1dfc:	9c 81       	ldd	r25, Y+4	; 0x04
    1dfe:	02 96       	adiw	r24, 0x02	; 2
    1e00:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1e04:	eb 81       	ldd	r30, Y+3	; 0x03
    1e06:	fc 81       	ldd	r31, Y+4	; 0x04
    1e08:	96 89       	ldd	r25, Z+22	; 0x16
    1e0a:	80 91 03 03 	lds	r24, 0x0303
    1e0e:	89 17       	cp	r24, r25
    1e10:	28 f4       	brcc	.+10     	; 0x1e1c <xTaskResumeAll+0x72>
    1e12:	eb 81       	ldd	r30, Y+3	; 0x03
    1e14:	fc 81       	ldd	r31, Y+4	; 0x04
    1e16:	86 89       	ldd	r24, Z+22	; 0x16
    1e18:	80 93 03 03 	sts	0x0303, r24
    1e1c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e1e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e20:	86 89       	ldd	r24, Z+22	; 0x16
    1e22:	28 2f       	mov	r18, r24
    1e24:	30 e0       	ldi	r19, 0x00	; 0
    1e26:	c9 01       	movw	r24, r18
    1e28:	88 0f       	add	r24, r24
    1e2a:	99 1f       	adc	r25, r25
    1e2c:	88 0f       	add	r24, r24
    1e2e:	99 1f       	adc	r25, r25
    1e30:	88 0f       	add	r24, r24
    1e32:	99 1f       	adc	r25, r25
    1e34:	82 0f       	add	r24, r18
    1e36:	93 1f       	adc	r25, r19
    1e38:	86 5f       	subi	r24, 0xF6	; 246
    1e3a:	9c 4f       	sbci	r25, 0xFC	; 252
    1e3c:	2b 81       	ldd	r18, Y+3	; 0x03
    1e3e:	3c 81       	ldd	r19, Y+4	; 0x04
    1e40:	2e 5f       	subi	r18, 0xFE	; 254
    1e42:	3f 4f       	sbci	r19, 0xFF	; 255
    1e44:	b9 01       	movw	r22, r18
    1e46:	0e 94 39 04 	call	0x872	; 0x872 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1e4a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e4c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e4e:	96 89       	ldd	r25, Z+22	; 0x16
    1e50:	e0 91 fc 02 	lds	r30, 0x02FC
    1e54:	f0 91 fd 02 	lds	r31, 0x02FD
    1e58:	86 89       	ldd	r24, Z+22	; 0x16
    1e5a:	98 17       	cp	r25, r24
    1e5c:	10 f0       	brcs	.+4      	; 0x1e62 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    1e5e:	81 e0       	ldi	r24, 0x01	; 1
    1e60:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1e62:	80 91 3b 03 	lds	r24, 0x033B
    1e66:	88 23       	and	r24, r24
    1e68:	09 f0       	breq	.+2      	; 0x1e6c <xTaskResumeAll+0xc2>
    1e6a:	ba cf       	rjmp	.-140    	; 0x1de0 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1e6c:	80 91 06 03 	lds	r24, 0x0306
    1e70:	88 23       	and	r24, r24
    1e72:	71 f0       	breq	.+28     	; 0x1e90 <xTaskResumeAll+0xe6>
    1e74:	07 c0       	rjmp	.+14     	; 0x1e84 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    1e76:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <vTaskIncrementTick>
						--uxMissedTicks;
    1e7a:	80 91 06 03 	lds	r24, 0x0306
    1e7e:	81 50       	subi	r24, 0x01	; 1
    1e80:	80 93 06 03 	sts	0x0306, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1e84:	80 91 06 03 	lds	r24, 0x0306
    1e88:	88 23       	and	r24, r24
    1e8a:	a9 f7       	brne	.-22     	; 0x1e76 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    1e8c:	81 e0       	ldi	r24, 0x01	; 1
    1e8e:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1e90:	89 81       	ldd	r24, Y+1	; 0x01
    1e92:	81 30       	cpi	r24, 0x01	; 1
    1e94:	21 f0       	breq	.+8      	; 0x1e9e <xTaskResumeAll+0xf4>
    1e96:	80 91 07 03 	lds	r24, 0x0307
    1e9a:	81 30       	cpi	r24, 0x01	; 1
    1e9c:	31 f4       	brne	.+12     	; 0x1eaa <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    1e9e:	81 e0       	ldi	r24, 0x01	; 1
    1ea0:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    1ea2:	10 92 07 03 	sts	0x0307, r1
					portYIELD_WITHIN_API();
    1ea6:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1eaa:	0f 90       	pop	r0
    1eac:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    1eae:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1eb0:	0f 90       	pop	r0
    1eb2:	0f 90       	pop	r0
    1eb4:	0f 90       	pop	r0
    1eb6:	0f 90       	pop	r0
    1eb8:	cf 91       	pop	r28
    1eba:	df 91       	pop	r29
    1ebc:	08 95       	ret

00001ebe <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    1ebe:	df 93       	push	r29
    1ec0:	cf 93       	push	r28
    1ec2:	00 d0       	rcall	.+0      	; 0x1ec4 <xTaskGetTickCount+0x6>
    1ec4:	cd b7       	in	r28, 0x3d	; 61
    1ec6:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1ec8:	0f b6       	in	r0, 0x3f	; 63
    1eca:	f8 94       	cli
    1ecc:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1ece:	80 91 00 03 	lds	r24, 0x0300
    1ed2:	90 91 01 03 	lds	r25, 0x0301
    1ed6:	9a 83       	std	Y+2, r25	; 0x02
    1ed8:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1eda:	0f 90       	pop	r0
    1edc:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    1ede:	89 81       	ldd	r24, Y+1	; 0x01
    1ee0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1ee2:	0f 90       	pop	r0
    1ee4:	0f 90       	pop	r0
    1ee6:	cf 91       	pop	r28
    1ee8:	df 91       	pop	r29
    1eea:	08 95       	ret

00001eec <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    1eec:	df 93       	push	r29
    1eee:	cf 93       	push	r28
    1ef0:	00 d0       	rcall	.+0      	; 0x1ef2 <xTaskGetTickCountFromISR+0x6>
    1ef2:	0f 92       	push	r0
    1ef4:	cd b7       	in	r28, 0x3d	; 61
    1ef6:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1ef8:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    1efa:	80 91 00 03 	lds	r24, 0x0300
    1efe:	90 91 01 03 	lds	r25, 0x0301
    1f02:	9b 83       	std	Y+3, r25	; 0x03
    1f04:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1f06:	8a 81       	ldd	r24, Y+2	; 0x02
    1f08:	9b 81       	ldd	r25, Y+3	; 0x03
}
    1f0a:	0f 90       	pop	r0
    1f0c:	0f 90       	pop	r0
    1f0e:	0f 90       	pop	r0
    1f10:	cf 91       	pop	r28
    1f12:	df 91       	pop	r29
    1f14:	08 95       	ret

00001f16 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    1f16:	df 93       	push	r29
    1f18:	cf 93       	push	r28
    1f1a:	cd b7       	in	r28, 0x3d	; 61
    1f1c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1f1e:	80 91 ff 02 	lds	r24, 0x02FF
}
    1f22:	cf 91       	pop	r28
    1f24:	df 91       	pop	r29
    1f26:	08 95       	ret

00001f28 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1f28:	df 93       	push	r29
    1f2a:	cf 93       	push	r28
    1f2c:	00 d0       	rcall	.+0      	; 0x1f2e <vTaskIncrementTick+0x6>
    1f2e:	00 d0       	rcall	.+0      	; 0x1f30 <vTaskIncrementTick+0x8>
    1f30:	00 d0       	rcall	.+0      	; 0x1f32 <vTaskIncrementTick+0xa>
    1f32:	cd b7       	in	r28, 0x3d	; 61
    1f34:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1f36:	80 91 05 03 	lds	r24, 0x0305
    1f3a:	88 23       	and	r24, r24
    1f3c:	09 f0       	breq	.+2      	; 0x1f40 <vTaskIncrementTick+0x18>
    1f3e:	bb c0       	rjmp	.+374    	; 0x20b6 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    1f40:	80 91 00 03 	lds	r24, 0x0300
    1f44:	90 91 01 03 	lds	r25, 0x0301
    1f48:	01 96       	adiw	r24, 0x01	; 1
    1f4a:	90 93 01 03 	sts	0x0301, r25
    1f4e:	80 93 00 03 	sts	0x0300, r24
		if( xTickCount == ( portTickType ) 0U )
    1f52:	80 91 00 03 	lds	r24, 0x0300
    1f56:	90 91 01 03 	lds	r25, 0x0301
    1f5a:	00 97       	sbiw	r24, 0x00	; 0
    1f5c:	d1 f5       	brne	.+116    	; 0x1fd2 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1f5e:	80 91 37 03 	lds	r24, 0x0337
    1f62:	90 91 38 03 	lds	r25, 0x0338
    1f66:	9c 83       	std	Y+4, r25	; 0x04
    1f68:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1f6a:	80 91 39 03 	lds	r24, 0x0339
    1f6e:	90 91 3a 03 	lds	r25, 0x033A
    1f72:	90 93 38 03 	sts	0x0338, r25
    1f76:	80 93 37 03 	sts	0x0337, r24
			pxOverflowDelayedTaskList = pxTemp;
    1f7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f7e:	90 93 3a 03 	sts	0x033A, r25
    1f82:	80 93 39 03 	sts	0x0339, r24
			xNumOfOverflows++;
    1f86:	80 91 08 03 	lds	r24, 0x0308
    1f8a:	8f 5f       	subi	r24, 0xFF	; 255
    1f8c:	80 93 08 03 	sts	0x0308, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1f90:	e0 91 37 03 	lds	r30, 0x0337
    1f94:	f0 91 38 03 	lds	r31, 0x0338
    1f98:	80 81       	ld	r24, Z
    1f9a:	88 23       	and	r24, r24
    1f9c:	39 f4       	brne	.+14     	; 0x1fac <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1f9e:	8f ef       	ldi	r24, 0xFF	; 255
    1fa0:	9f ef       	ldi	r25, 0xFF	; 255
    1fa2:	90 93 66 00 	sts	0x0066, r25
    1fa6:	80 93 65 00 	sts	0x0065, r24
    1faa:	13 c0       	rjmp	.+38     	; 0x1fd2 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1fac:	e0 91 37 03 	lds	r30, 0x0337
    1fb0:	f0 91 38 03 	lds	r31, 0x0338
    1fb4:	05 80       	ldd	r0, Z+5	; 0x05
    1fb6:	f6 81       	ldd	r31, Z+6	; 0x06
    1fb8:	e0 2d       	mov	r30, r0
    1fba:	86 81       	ldd	r24, Z+6	; 0x06
    1fbc:	97 81       	ldd	r25, Z+7	; 0x07
    1fbe:	9e 83       	std	Y+6, r25	; 0x06
    1fc0:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1fc2:	ed 81       	ldd	r30, Y+5	; 0x05
    1fc4:	fe 81       	ldd	r31, Y+6	; 0x06
    1fc6:	82 81       	ldd	r24, Z+2	; 0x02
    1fc8:	93 81       	ldd	r25, Z+3	; 0x03
    1fca:	90 93 66 00 	sts	0x0066, r25
    1fce:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1fd2:	20 91 00 03 	lds	r18, 0x0300
    1fd6:	30 91 01 03 	lds	r19, 0x0301
    1fda:	80 91 65 00 	lds	r24, 0x0065
    1fde:	90 91 66 00 	lds	r25, 0x0066
    1fe2:	28 17       	cp	r18, r24
    1fe4:	39 07       	cpc	r19, r25
    1fe6:	08 f4       	brcc	.+2      	; 0x1fea <vTaskIncrementTick+0xc2>
    1fe8:	6b c0       	rjmp	.+214    	; 0x20c0 <vTaskIncrementTick+0x198>
    1fea:	e0 91 37 03 	lds	r30, 0x0337
    1fee:	f0 91 38 03 	lds	r31, 0x0338
    1ff2:	80 81       	ld	r24, Z
    1ff4:	88 23       	and	r24, r24
    1ff6:	39 f4       	brne	.+14     	; 0x2006 <vTaskIncrementTick+0xde>
    1ff8:	8f ef       	ldi	r24, 0xFF	; 255
    1ffa:	9f ef       	ldi	r25, 0xFF	; 255
    1ffc:	90 93 66 00 	sts	0x0066, r25
    2000:	80 93 65 00 	sts	0x0065, r24
    2004:	5d c0       	rjmp	.+186    	; 0x20c0 <vTaskIncrementTick+0x198>
    2006:	e0 91 37 03 	lds	r30, 0x0337
    200a:	f0 91 38 03 	lds	r31, 0x0338
    200e:	05 80       	ldd	r0, Z+5	; 0x05
    2010:	f6 81       	ldd	r31, Z+6	; 0x06
    2012:	e0 2d       	mov	r30, r0
    2014:	86 81       	ldd	r24, Z+6	; 0x06
    2016:	97 81       	ldd	r25, Z+7	; 0x07
    2018:	9e 83       	std	Y+6, r25	; 0x06
    201a:	8d 83       	std	Y+5, r24	; 0x05
    201c:	ed 81       	ldd	r30, Y+5	; 0x05
    201e:	fe 81       	ldd	r31, Y+6	; 0x06
    2020:	82 81       	ldd	r24, Z+2	; 0x02
    2022:	93 81       	ldd	r25, Z+3	; 0x03
    2024:	9a 83       	std	Y+2, r25	; 0x02
    2026:	89 83       	std	Y+1, r24	; 0x01
    2028:	20 91 00 03 	lds	r18, 0x0300
    202c:	30 91 01 03 	lds	r19, 0x0301
    2030:	89 81       	ldd	r24, Y+1	; 0x01
    2032:	9a 81       	ldd	r25, Y+2	; 0x02
    2034:	28 17       	cp	r18, r24
    2036:	39 07       	cpc	r19, r25
    2038:	38 f4       	brcc	.+14     	; 0x2048 <vTaskIncrementTick+0x120>
    203a:	89 81       	ldd	r24, Y+1	; 0x01
    203c:	9a 81       	ldd	r25, Y+2	; 0x02
    203e:	90 93 66 00 	sts	0x0066, r25
    2042:	80 93 65 00 	sts	0x0065, r24
    2046:	3c c0       	rjmp	.+120    	; 0x20c0 <vTaskIncrementTick+0x198>
    2048:	8d 81       	ldd	r24, Y+5	; 0x05
    204a:	9e 81       	ldd	r25, Y+6	; 0x06
    204c:	02 96       	adiw	r24, 0x02	; 2
    204e:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>
    2052:	ed 81       	ldd	r30, Y+5	; 0x05
    2054:	fe 81       	ldd	r31, Y+6	; 0x06
    2056:	84 89       	ldd	r24, Z+20	; 0x14
    2058:	95 89       	ldd	r25, Z+21	; 0x15
    205a:	00 97       	sbiw	r24, 0x00	; 0
    205c:	29 f0       	breq	.+10     	; 0x2068 <vTaskIncrementTick+0x140>
    205e:	8d 81       	ldd	r24, Y+5	; 0x05
    2060:	9e 81       	ldd	r25, Y+6	; 0x06
    2062:	0c 96       	adiw	r24, 0x0c	; 12
    2064:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>
    2068:	ed 81       	ldd	r30, Y+5	; 0x05
    206a:	fe 81       	ldd	r31, Y+6	; 0x06
    206c:	96 89       	ldd	r25, Z+22	; 0x16
    206e:	80 91 03 03 	lds	r24, 0x0303
    2072:	89 17       	cp	r24, r25
    2074:	28 f4       	brcc	.+10     	; 0x2080 <vTaskIncrementTick+0x158>
    2076:	ed 81       	ldd	r30, Y+5	; 0x05
    2078:	fe 81       	ldd	r31, Y+6	; 0x06
    207a:	86 89       	ldd	r24, Z+22	; 0x16
    207c:	80 93 03 03 	sts	0x0303, r24
    2080:	ed 81       	ldd	r30, Y+5	; 0x05
    2082:	fe 81       	ldd	r31, Y+6	; 0x06
    2084:	86 89       	ldd	r24, Z+22	; 0x16
    2086:	28 2f       	mov	r18, r24
    2088:	30 e0       	ldi	r19, 0x00	; 0
    208a:	c9 01       	movw	r24, r18
    208c:	88 0f       	add	r24, r24
    208e:	99 1f       	adc	r25, r25
    2090:	88 0f       	add	r24, r24
    2092:	99 1f       	adc	r25, r25
    2094:	88 0f       	add	r24, r24
    2096:	99 1f       	adc	r25, r25
    2098:	82 0f       	add	r24, r18
    209a:	93 1f       	adc	r25, r19
    209c:	ac 01       	movw	r20, r24
    209e:	46 5f       	subi	r20, 0xF6	; 246
    20a0:	5c 4f       	sbci	r21, 0xFC	; 252
    20a2:	8d 81       	ldd	r24, Y+5	; 0x05
    20a4:	9e 81       	ldd	r25, Y+6	; 0x06
    20a6:	9c 01       	movw	r18, r24
    20a8:	2e 5f       	subi	r18, 0xFE	; 254
    20aa:	3f 4f       	sbci	r19, 0xFF	; 255
    20ac:	ca 01       	movw	r24, r20
    20ae:	b9 01       	movw	r22, r18
    20b0:	0e 94 39 04 	call	0x872	; 0x872 <vListInsertEnd>
    20b4:	9a cf       	rjmp	.-204    	; 0x1fea <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    20b6:	80 91 06 03 	lds	r24, 0x0306
    20ba:	8f 5f       	subi	r24, 0xFF	; 255
    20bc:	80 93 06 03 	sts	0x0306, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    20c0:	26 96       	adiw	r28, 0x06	; 6
    20c2:	0f b6       	in	r0, 0x3f	; 63
    20c4:	f8 94       	cli
    20c6:	de bf       	out	0x3e, r29	; 62
    20c8:	0f be       	out	0x3f, r0	; 63
    20ca:	cd bf       	out	0x3d, r28	; 61
    20cc:	cf 91       	pop	r28
    20ce:	df 91       	pop	r29
    20d0:	08 95       	ret

000020d2 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    20d2:	df 93       	push	r29
    20d4:	cf 93       	push	r28
    20d6:	00 d0       	rcall	.+0      	; 0x20d8 <vTaskSwitchContext+0x6>
    20d8:	cd b7       	in	r28, 0x3d	; 61
    20da:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    20dc:	80 91 05 03 	lds	r24, 0x0305
    20e0:	88 23       	and	r24, r24
    20e2:	49 f0       	breq	.+18     	; 0x20f6 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    20e4:	81 e0       	ldi	r24, 0x01	; 1
    20e6:	80 93 07 03 	sts	0x0307, r24
    20ea:	54 c0       	rjmp	.+168    	; 0x2194 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    20ec:	80 91 03 03 	lds	r24, 0x0303
    20f0:	81 50       	subi	r24, 0x01	; 1
    20f2:	80 93 03 03 	sts	0x0303, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    20f6:	80 91 03 03 	lds	r24, 0x0303
    20fa:	28 2f       	mov	r18, r24
    20fc:	30 e0       	ldi	r19, 0x00	; 0
    20fe:	c9 01       	movw	r24, r18
    2100:	88 0f       	add	r24, r24
    2102:	99 1f       	adc	r25, r25
    2104:	88 0f       	add	r24, r24
    2106:	99 1f       	adc	r25, r25
    2108:	88 0f       	add	r24, r24
    210a:	99 1f       	adc	r25, r25
    210c:	82 0f       	add	r24, r18
    210e:	93 1f       	adc	r25, r19
    2110:	fc 01       	movw	r30, r24
    2112:	e6 5f       	subi	r30, 0xF6	; 246
    2114:	fc 4f       	sbci	r31, 0xFC	; 252
    2116:	80 81       	ld	r24, Z
    2118:	88 23       	and	r24, r24
    211a:	41 f3       	breq	.-48     	; 0x20ec <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    211c:	80 91 03 03 	lds	r24, 0x0303
    2120:	28 2f       	mov	r18, r24
    2122:	30 e0       	ldi	r19, 0x00	; 0
    2124:	c9 01       	movw	r24, r18
    2126:	88 0f       	add	r24, r24
    2128:	99 1f       	adc	r25, r25
    212a:	88 0f       	add	r24, r24
    212c:	99 1f       	adc	r25, r25
    212e:	88 0f       	add	r24, r24
    2130:	99 1f       	adc	r25, r25
    2132:	82 0f       	add	r24, r18
    2134:	93 1f       	adc	r25, r19
    2136:	86 5f       	subi	r24, 0xF6	; 246
    2138:	9c 4f       	sbci	r25, 0xFC	; 252
    213a:	9a 83       	std	Y+2, r25	; 0x02
    213c:	89 83       	std	Y+1, r24	; 0x01
    213e:	e9 81       	ldd	r30, Y+1	; 0x01
    2140:	fa 81       	ldd	r31, Y+2	; 0x02
    2142:	01 80       	ldd	r0, Z+1	; 0x01
    2144:	f2 81       	ldd	r31, Z+2	; 0x02
    2146:	e0 2d       	mov	r30, r0
    2148:	82 81       	ldd	r24, Z+2	; 0x02
    214a:	93 81       	ldd	r25, Z+3	; 0x03
    214c:	e9 81       	ldd	r30, Y+1	; 0x01
    214e:	fa 81       	ldd	r31, Y+2	; 0x02
    2150:	92 83       	std	Z+2, r25	; 0x02
    2152:	81 83       	std	Z+1, r24	; 0x01
    2154:	e9 81       	ldd	r30, Y+1	; 0x01
    2156:	fa 81       	ldd	r31, Y+2	; 0x02
    2158:	21 81       	ldd	r18, Z+1	; 0x01
    215a:	32 81       	ldd	r19, Z+2	; 0x02
    215c:	89 81       	ldd	r24, Y+1	; 0x01
    215e:	9a 81       	ldd	r25, Y+2	; 0x02
    2160:	03 96       	adiw	r24, 0x03	; 3
    2162:	28 17       	cp	r18, r24
    2164:	39 07       	cpc	r19, r25
    2166:	59 f4       	brne	.+22     	; 0x217e <vTaskSwitchContext+0xac>
    2168:	e9 81       	ldd	r30, Y+1	; 0x01
    216a:	fa 81       	ldd	r31, Y+2	; 0x02
    216c:	01 80       	ldd	r0, Z+1	; 0x01
    216e:	f2 81       	ldd	r31, Z+2	; 0x02
    2170:	e0 2d       	mov	r30, r0
    2172:	82 81       	ldd	r24, Z+2	; 0x02
    2174:	93 81       	ldd	r25, Z+3	; 0x03
    2176:	e9 81       	ldd	r30, Y+1	; 0x01
    2178:	fa 81       	ldd	r31, Y+2	; 0x02
    217a:	92 83       	std	Z+2, r25	; 0x02
    217c:	81 83       	std	Z+1, r24	; 0x01
    217e:	e9 81       	ldd	r30, Y+1	; 0x01
    2180:	fa 81       	ldd	r31, Y+2	; 0x02
    2182:	01 80       	ldd	r0, Z+1	; 0x01
    2184:	f2 81       	ldd	r31, Z+2	; 0x02
    2186:	e0 2d       	mov	r30, r0
    2188:	86 81       	ldd	r24, Z+6	; 0x06
    218a:	97 81       	ldd	r25, Z+7	; 0x07
    218c:	90 93 fd 02 	sts	0x02FD, r25
    2190:	80 93 fc 02 	sts	0x02FC, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2194:	0f 90       	pop	r0
    2196:	0f 90       	pop	r0
    2198:	cf 91       	pop	r28
    219a:	df 91       	pop	r29
    219c:	08 95       	ret

0000219e <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    219e:	df 93       	push	r29
    21a0:	cf 93       	push	r28
    21a2:	00 d0       	rcall	.+0      	; 0x21a4 <vTaskPlaceOnEventList+0x6>
    21a4:	00 d0       	rcall	.+0      	; 0x21a6 <vTaskPlaceOnEventList+0x8>
    21a6:	00 d0       	rcall	.+0      	; 0x21a8 <vTaskPlaceOnEventList+0xa>
    21a8:	cd b7       	in	r28, 0x3d	; 61
    21aa:	de b7       	in	r29, 0x3e	; 62
    21ac:	9c 83       	std	Y+4, r25	; 0x04
    21ae:	8b 83       	std	Y+3, r24	; 0x03
    21b0:	7e 83       	std	Y+6, r23	; 0x06
    21b2:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    21b4:	4b 81       	ldd	r20, Y+3	; 0x03
    21b6:	5c 81       	ldd	r21, Y+4	; 0x04
    21b8:	80 91 fc 02 	lds	r24, 0x02FC
    21bc:	90 91 fd 02 	lds	r25, 0x02FD
    21c0:	9c 01       	movw	r18, r24
    21c2:	24 5f       	subi	r18, 0xF4	; 244
    21c4:	3f 4f       	sbci	r19, 0xFF	; 255
    21c6:	ca 01       	movw	r24, r20
    21c8:	b9 01       	movw	r22, r18
    21ca:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    21ce:	80 91 fc 02 	lds	r24, 0x02FC
    21d2:	90 91 fd 02 	lds	r25, 0x02FD
    21d6:	02 96       	adiw	r24, 0x02	; 2
    21d8:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    21dc:	20 91 00 03 	lds	r18, 0x0300
    21e0:	30 91 01 03 	lds	r19, 0x0301
    21e4:	8d 81       	ldd	r24, Y+5	; 0x05
    21e6:	9e 81       	ldd	r25, Y+6	; 0x06
    21e8:	82 0f       	add	r24, r18
    21ea:	93 1f       	adc	r25, r19
    21ec:	9a 83       	std	Y+2, r25	; 0x02
    21ee:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    21f0:	89 81       	ldd	r24, Y+1	; 0x01
    21f2:	9a 81       	ldd	r25, Y+2	; 0x02
    21f4:	0e 94 c9 12 	call	0x2592	; 0x2592 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    21f8:	26 96       	adiw	r28, 0x06	; 6
    21fa:	0f b6       	in	r0, 0x3f	; 63
    21fc:	f8 94       	cli
    21fe:	de bf       	out	0x3e, r29	; 62
    2200:	0f be       	out	0x3f, r0	; 63
    2202:	cd bf       	out	0x3d, r28	; 61
    2204:	cf 91       	pop	r28
    2206:	df 91       	pop	r29
    2208:	08 95       	ret

0000220a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    220a:	df 93       	push	r29
    220c:	cf 93       	push	r28
    220e:	00 d0       	rcall	.+0      	; 0x2210 <xTaskRemoveFromEventList+0x6>
    2210:	00 d0       	rcall	.+0      	; 0x2212 <xTaskRemoveFromEventList+0x8>
    2212:	0f 92       	push	r0
    2214:	cd b7       	in	r28, 0x3d	; 61
    2216:	de b7       	in	r29, 0x3e	; 62
    2218:	9d 83       	std	Y+5, r25	; 0x05
    221a:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    221c:	ec 81       	ldd	r30, Y+4	; 0x04
    221e:	fd 81       	ldd	r31, Y+5	; 0x05
    2220:	05 80       	ldd	r0, Z+5	; 0x05
    2222:	f6 81       	ldd	r31, Z+6	; 0x06
    2224:	e0 2d       	mov	r30, r0
    2226:	86 81       	ldd	r24, Z+6	; 0x06
    2228:	97 81       	ldd	r25, Z+7	; 0x07
    222a:	9b 83       	std	Y+3, r25	; 0x03
    222c:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    222e:	8a 81       	ldd	r24, Y+2	; 0x02
    2230:	9b 81       	ldd	r25, Y+3	; 0x03
    2232:	0c 96       	adiw	r24, 0x0c	; 12
    2234:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2238:	80 91 05 03 	lds	r24, 0x0305
    223c:	88 23       	and	r24, r24
    223e:	61 f5       	brne	.+88     	; 0x2298 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2240:	8a 81       	ldd	r24, Y+2	; 0x02
    2242:	9b 81       	ldd	r25, Y+3	; 0x03
    2244:	02 96       	adiw	r24, 0x02	; 2
    2246:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    224a:	ea 81       	ldd	r30, Y+2	; 0x02
    224c:	fb 81       	ldd	r31, Y+3	; 0x03
    224e:	96 89       	ldd	r25, Z+22	; 0x16
    2250:	80 91 03 03 	lds	r24, 0x0303
    2254:	89 17       	cp	r24, r25
    2256:	28 f4       	brcc	.+10     	; 0x2262 <xTaskRemoveFromEventList+0x58>
    2258:	ea 81       	ldd	r30, Y+2	; 0x02
    225a:	fb 81       	ldd	r31, Y+3	; 0x03
    225c:	86 89       	ldd	r24, Z+22	; 0x16
    225e:	80 93 03 03 	sts	0x0303, r24
    2262:	ea 81       	ldd	r30, Y+2	; 0x02
    2264:	fb 81       	ldd	r31, Y+3	; 0x03
    2266:	86 89       	ldd	r24, Z+22	; 0x16
    2268:	28 2f       	mov	r18, r24
    226a:	30 e0       	ldi	r19, 0x00	; 0
    226c:	c9 01       	movw	r24, r18
    226e:	88 0f       	add	r24, r24
    2270:	99 1f       	adc	r25, r25
    2272:	88 0f       	add	r24, r24
    2274:	99 1f       	adc	r25, r25
    2276:	88 0f       	add	r24, r24
    2278:	99 1f       	adc	r25, r25
    227a:	82 0f       	add	r24, r18
    227c:	93 1f       	adc	r25, r19
    227e:	ac 01       	movw	r20, r24
    2280:	46 5f       	subi	r20, 0xF6	; 246
    2282:	5c 4f       	sbci	r21, 0xFC	; 252
    2284:	8a 81       	ldd	r24, Y+2	; 0x02
    2286:	9b 81       	ldd	r25, Y+3	; 0x03
    2288:	9c 01       	movw	r18, r24
    228a:	2e 5f       	subi	r18, 0xFE	; 254
    228c:	3f 4f       	sbci	r19, 0xFF	; 255
    228e:	ca 01       	movw	r24, r20
    2290:	b9 01       	movw	r22, r18
    2292:	0e 94 39 04 	call	0x872	; 0x872 <vListInsertEnd>
    2296:	0a c0       	rjmp	.+20     	; 0x22ac <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2298:	8a 81       	ldd	r24, Y+2	; 0x02
    229a:	9b 81       	ldd	r25, Y+3	; 0x03
    229c:	9c 01       	movw	r18, r24
    229e:	24 5f       	subi	r18, 0xF4	; 244
    22a0:	3f 4f       	sbci	r19, 0xFF	; 255
    22a2:	8b e3       	ldi	r24, 0x3B	; 59
    22a4:	93 e0       	ldi	r25, 0x03	; 3
    22a6:	b9 01       	movw	r22, r18
    22a8:	0e 94 39 04 	call	0x872	; 0x872 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    22ac:	ea 81       	ldd	r30, Y+2	; 0x02
    22ae:	fb 81       	ldd	r31, Y+3	; 0x03
    22b0:	96 89       	ldd	r25, Z+22	; 0x16
    22b2:	e0 91 fc 02 	lds	r30, 0x02FC
    22b6:	f0 91 fd 02 	lds	r31, 0x02FD
    22ba:	86 89       	ldd	r24, Z+22	; 0x16
    22bc:	98 17       	cp	r25, r24
    22be:	18 f0       	brcs	.+6      	; 0x22c6 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    22c0:	81 e0       	ldi	r24, 0x01	; 1
    22c2:	89 83       	std	Y+1, r24	; 0x01
    22c4:	01 c0       	rjmp	.+2      	; 0x22c8 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    22c6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    22c8:	89 81       	ldd	r24, Y+1	; 0x01
}
    22ca:	0f 90       	pop	r0
    22cc:	0f 90       	pop	r0
    22ce:	0f 90       	pop	r0
    22d0:	0f 90       	pop	r0
    22d2:	0f 90       	pop	r0
    22d4:	cf 91       	pop	r28
    22d6:	df 91       	pop	r29
    22d8:	08 95       	ret

000022da <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    22da:	df 93       	push	r29
    22dc:	cf 93       	push	r28
    22de:	00 d0       	rcall	.+0      	; 0x22e0 <vTaskSetTimeOutState+0x6>
    22e0:	cd b7       	in	r28, 0x3d	; 61
    22e2:	de b7       	in	r29, 0x3e	; 62
    22e4:	9a 83       	std	Y+2, r25	; 0x02
    22e6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    22e8:	80 91 08 03 	lds	r24, 0x0308
    22ec:	e9 81       	ldd	r30, Y+1	; 0x01
    22ee:	fa 81       	ldd	r31, Y+2	; 0x02
    22f0:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    22f2:	80 91 00 03 	lds	r24, 0x0300
    22f6:	90 91 01 03 	lds	r25, 0x0301
    22fa:	e9 81       	ldd	r30, Y+1	; 0x01
    22fc:	fa 81       	ldd	r31, Y+2	; 0x02
    22fe:	92 83       	std	Z+2, r25	; 0x02
    2300:	81 83       	std	Z+1, r24	; 0x01
}
    2302:	0f 90       	pop	r0
    2304:	0f 90       	pop	r0
    2306:	cf 91       	pop	r28
    2308:	df 91       	pop	r29
    230a:	08 95       	ret

0000230c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    230c:	df 93       	push	r29
    230e:	cf 93       	push	r28
    2310:	00 d0       	rcall	.+0      	; 0x2312 <xTaskCheckForTimeOut+0x6>
    2312:	00 d0       	rcall	.+0      	; 0x2314 <xTaskCheckForTimeOut+0x8>
    2314:	0f 92       	push	r0
    2316:	cd b7       	in	r28, 0x3d	; 61
    2318:	de b7       	in	r29, 0x3e	; 62
    231a:	9b 83       	std	Y+3, r25	; 0x03
    231c:	8a 83       	std	Y+2, r24	; 0x02
    231e:	7d 83       	std	Y+5, r23	; 0x05
    2320:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2322:	0f b6       	in	r0, 0x3f	; 63
    2324:	f8 94       	cli
    2326:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2328:	ea 81       	ldd	r30, Y+2	; 0x02
    232a:	fb 81       	ldd	r31, Y+3	; 0x03
    232c:	90 81       	ld	r25, Z
    232e:	80 91 08 03 	lds	r24, 0x0308
    2332:	98 17       	cp	r25, r24
    2334:	71 f0       	breq	.+28     	; 0x2352 <xTaskCheckForTimeOut+0x46>
    2336:	ea 81       	ldd	r30, Y+2	; 0x02
    2338:	fb 81       	ldd	r31, Y+3	; 0x03
    233a:	21 81       	ldd	r18, Z+1	; 0x01
    233c:	32 81       	ldd	r19, Z+2	; 0x02
    233e:	80 91 00 03 	lds	r24, 0x0300
    2342:	90 91 01 03 	lds	r25, 0x0301
    2346:	82 17       	cp	r24, r18
    2348:	93 07       	cpc	r25, r19
    234a:	18 f0       	brcs	.+6      	; 0x2352 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    234c:	81 e0       	ldi	r24, 0x01	; 1
    234e:	89 83       	std	Y+1, r24	; 0x01
    2350:	2f c0       	rjmp	.+94     	; 0x23b0 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2352:	20 91 00 03 	lds	r18, 0x0300
    2356:	30 91 01 03 	lds	r19, 0x0301
    235a:	ea 81       	ldd	r30, Y+2	; 0x02
    235c:	fb 81       	ldd	r31, Y+3	; 0x03
    235e:	81 81       	ldd	r24, Z+1	; 0x01
    2360:	92 81       	ldd	r25, Z+2	; 0x02
    2362:	28 1b       	sub	r18, r24
    2364:	39 0b       	sbc	r19, r25
    2366:	ec 81       	ldd	r30, Y+4	; 0x04
    2368:	fd 81       	ldd	r31, Y+5	; 0x05
    236a:	80 81       	ld	r24, Z
    236c:	91 81       	ldd	r25, Z+1	; 0x01
    236e:	28 17       	cp	r18, r24
    2370:	39 07       	cpc	r19, r25
    2372:	e0 f4       	brcc	.+56     	; 0x23ac <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2374:	ec 81       	ldd	r30, Y+4	; 0x04
    2376:	fd 81       	ldd	r31, Y+5	; 0x05
    2378:	40 81       	ld	r20, Z
    237a:	51 81       	ldd	r21, Z+1	; 0x01
    237c:	ea 81       	ldd	r30, Y+2	; 0x02
    237e:	fb 81       	ldd	r31, Y+3	; 0x03
    2380:	21 81       	ldd	r18, Z+1	; 0x01
    2382:	32 81       	ldd	r19, Z+2	; 0x02
    2384:	80 91 00 03 	lds	r24, 0x0300
    2388:	90 91 01 03 	lds	r25, 0x0301
    238c:	b9 01       	movw	r22, r18
    238e:	68 1b       	sub	r22, r24
    2390:	79 0b       	sbc	r23, r25
    2392:	cb 01       	movw	r24, r22
    2394:	84 0f       	add	r24, r20
    2396:	95 1f       	adc	r25, r21
    2398:	ec 81       	ldd	r30, Y+4	; 0x04
    239a:	fd 81       	ldd	r31, Y+5	; 0x05
    239c:	91 83       	std	Z+1, r25	; 0x01
    239e:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    23a0:	8a 81       	ldd	r24, Y+2	; 0x02
    23a2:	9b 81       	ldd	r25, Y+3	; 0x03
    23a4:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    23a8:	19 82       	std	Y+1, r1	; 0x01
    23aa:	02 c0       	rjmp	.+4      	; 0x23b0 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    23ac:	81 e0       	ldi	r24, 0x01	; 1
    23ae:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    23b0:	0f 90       	pop	r0
    23b2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    23b4:	89 81       	ldd	r24, Y+1	; 0x01
}
    23b6:	0f 90       	pop	r0
    23b8:	0f 90       	pop	r0
    23ba:	0f 90       	pop	r0
    23bc:	0f 90       	pop	r0
    23be:	0f 90       	pop	r0
    23c0:	cf 91       	pop	r28
    23c2:	df 91       	pop	r29
    23c4:	08 95       	ret

000023c6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    23c6:	df 93       	push	r29
    23c8:	cf 93       	push	r28
    23ca:	cd b7       	in	r28, 0x3d	; 61
    23cc:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    23ce:	81 e0       	ldi	r24, 0x01	; 1
    23d0:	80 93 07 03 	sts	0x0307, r24
}
    23d4:	cf 91       	pop	r28
    23d6:	df 91       	pop	r29
    23d8:	08 95       	ret

000023da <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    23da:	df 93       	push	r29
    23dc:	cf 93       	push	r28
    23de:	00 d0       	rcall	.+0      	; 0x23e0 <prvIdleTask+0x6>
    23e0:	cd b7       	in	r28, 0x3d	; 61
    23e2:	de b7       	in	r29, 0x3e	; 62
    23e4:	9a 83       	std	Y+2, r25	; 0x02
    23e6:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    23e8:	0e 94 8b 12 	call	0x2516	; 0x2516 <prvCheckTasksWaitingTermination>
    23ec:	fd cf       	rjmp	.-6      	; 0x23e8 <prvIdleTask+0xe>

000023ee <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    23ee:	0f 93       	push	r16
    23f0:	1f 93       	push	r17
    23f2:	df 93       	push	r29
    23f4:	cf 93       	push	r28
    23f6:	cd b7       	in	r28, 0x3d	; 61
    23f8:	de b7       	in	r29, 0x3e	; 62
    23fa:	29 97       	sbiw	r28, 0x09	; 9
    23fc:	0f b6       	in	r0, 0x3f	; 63
    23fe:	f8 94       	cli
    2400:	de bf       	out	0x3e, r29	; 62
    2402:	0f be       	out	0x3f, r0	; 63
    2404:	cd bf       	out	0x3d, r28	; 61
    2406:	9a 83       	std	Y+2, r25	; 0x02
    2408:	89 83       	std	Y+1, r24	; 0x01
    240a:	7c 83       	std	Y+4, r23	; 0x04
    240c:	6b 83       	std	Y+3, r22	; 0x03
    240e:	4d 83       	std	Y+5, r20	; 0x05
    2410:	3f 83       	std	Y+7, r19	; 0x07
    2412:	2e 83       	std	Y+6, r18	; 0x06
    2414:	19 87       	std	Y+9, r17	; 0x09
    2416:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2418:	89 81       	ldd	r24, Y+1	; 0x01
    241a:	9a 81       	ldd	r25, Y+2	; 0x02
    241c:	49 96       	adiw	r24, 0x19	; 25
    241e:	2b 81       	ldd	r18, Y+3	; 0x03
    2420:	3c 81       	ldd	r19, Y+4	; 0x04
    2422:	b9 01       	movw	r22, r18
    2424:	48 e0       	ldi	r20, 0x08	; 8
    2426:	50 e0       	ldi	r21, 0x00	; 0
    2428:	0e 94 88 13 	call	0x2710	; 0x2710 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    242c:	e9 81       	ldd	r30, Y+1	; 0x01
    242e:	fa 81       	ldd	r31, Y+2	; 0x02
    2430:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    2432:	8d 81       	ldd	r24, Y+5	; 0x05
    2434:	83 30       	cpi	r24, 0x03	; 3
    2436:	10 f0       	brcs	.+4      	; 0x243c <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2438:	82 e0       	ldi	r24, 0x02	; 2
    243a:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    243c:	e9 81       	ldd	r30, Y+1	; 0x01
    243e:	fa 81       	ldd	r31, Y+2	; 0x02
    2440:	8d 81       	ldd	r24, Y+5	; 0x05
    2442:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2444:	89 81       	ldd	r24, Y+1	; 0x01
    2446:	9a 81       	ldd	r25, Y+2	; 0x02
    2448:	02 96       	adiw	r24, 0x02	; 2
    244a:	0e 94 29 04 	call	0x852	; 0x852 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    244e:	89 81       	ldd	r24, Y+1	; 0x01
    2450:	9a 81       	ldd	r25, Y+2	; 0x02
    2452:	0c 96       	adiw	r24, 0x0c	; 12
    2454:	0e 94 29 04 	call	0x852	; 0x852 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2458:	e9 81       	ldd	r30, Y+1	; 0x01
    245a:	fa 81       	ldd	r31, Y+2	; 0x02
    245c:	89 81       	ldd	r24, Y+1	; 0x01
    245e:	9a 81       	ldd	r25, Y+2	; 0x02
    2460:	91 87       	std	Z+9, r25	; 0x09
    2462:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2464:	8d 81       	ldd	r24, Y+5	; 0x05
    2466:	28 2f       	mov	r18, r24
    2468:	30 e0       	ldi	r19, 0x00	; 0
    246a:	83 e0       	ldi	r24, 0x03	; 3
    246c:	90 e0       	ldi	r25, 0x00	; 0
    246e:	82 1b       	sub	r24, r18
    2470:	93 0b       	sbc	r25, r19
    2472:	e9 81       	ldd	r30, Y+1	; 0x01
    2474:	fa 81       	ldd	r31, Y+2	; 0x02
    2476:	95 87       	std	Z+13, r25	; 0x0d
    2478:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    247a:	e9 81       	ldd	r30, Y+1	; 0x01
    247c:	fa 81       	ldd	r31, Y+2	; 0x02
    247e:	89 81       	ldd	r24, Y+1	; 0x01
    2480:	9a 81       	ldd	r25, Y+2	; 0x02
    2482:	93 8b       	std	Z+19, r25	; 0x13
    2484:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2486:	29 96       	adiw	r28, 0x09	; 9
    2488:	0f b6       	in	r0, 0x3f	; 63
    248a:	f8 94       	cli
    248c:	de bf       	out	0x3e, r29	; 62
    248e:	0f be       	out	0x3f, r0	; 63
    2490:	cd bf       	out	0x3d, r28	; 61
    2492:	cf 91       	pop	r28
    2494:	df 91       	pop	r29
    2496:	1f 91       	pop	r17
    2498:	0f 91       	pop	r16
    249a:	08 95       	ret

0000249c <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    249c:	df 93       	push	r29
    249e:	cf 93       	push	r28
    24a0:	0f 92       	push	r0
    24a2:	cd b7       	in	r28, 0x3d	; 61
    24a4:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    24a6:	19 82       	std	Y+1, r1	; 0x01
    24a8:	13 c0       	rjmp	.+38     	; 0x24d0 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    24aa:	89 81       	ldd	r24, Y+1	; 0x01
    24ac:	28 2f       	mov	r18, r24
    24ae:	30 e0       	ldi	r19, 0x00	; 0
    24b0:	c9 01       	movw	r24, r18
    24b2:	88 0f       	add	r24, r24
    24b4:	99 1f       	adc	r25, r25
    24b6:	88 0f       	add	r24, r24
    24b8:	99 1f       	adc	r25, r25
    24ba:	88 0f       	add	r24, r24
    24bc:	99 1f       	adc	r25, r25
    24be:	82 0f       	add	r24, r18
    24c0:	93 1f       	adc	r25, r19
    24c2:	86 5f       	subi	r24, 0xF6	; 246
    24c4:	9c 4f       	sbci	r25, 0xFC	; 252
    24c6:	0e 94 ff 03 	call	0x7fe	; 0x7fe <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    24ca:	89 81       	ldd	r24, Y+1	; 0x01
    24cc:	8f 5f       	subi	r24, 0xFF	; 255
    24ce:	89 83       	std	Y+1, r24	; 0x01
    24d0:	89 81       	ldd	r24, Y+1	; 0x01
    24d2:	83 30       	cpi	r24, 0x03	; 3
    24d4:	50 f3       	brcs	.-44     	; 0x24aa <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    24d6:	85 e2       	ldi	r24, 0x25	; 37
    24d8:	93 e0       	ldi	r25, 0x03	; 3
    24da:	0e 94 ff 03 	call	0x7fe	; 0x7fe <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    24de:	8e e2       	ldi	r24, 0x2E	; 46
    24e0:	93 e0       	ldi	r25, 0x03	; 3
    24e2:	0e 94 ff 03 	call	0x7fe	; 0x7fe <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    24e6:	8b e3       	ldi	r24, 0x3B	; 59
    24e8:	93 e0       	ldi	r25, 0x03	; 3
    24ea:	0e 94 ff 03 	call	0x7fe	; 0x7fe <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    24ee:	84 e4       	ldi	r24, 0x44	; 68
    24f0:	93 e0       	ldi	r25, 0x03	; 3
    24f2:	0e 94 ff 03 	call	0x7fe	; 0x7fe <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    24f6:	85 e2       	ldi	r24, 0x25	; 37
    24f8:	93 e0       	ldi	r25, 0x03	; 3
    24fa:	90 93 38 03 	sts	0x0338, r25
    24fe:	80 93 37 03 	sts	0x0337, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2502:	8e e2       	ldi	r24, 0x2E	; 46
    2504:	93 e0       	ldi	r25, 0x03	; 3
    2506:	90 93 3a 03 	sts	0x033A, r25
    250a:	80 93 39 03 	sts	0x0339, r24
}
    250e:	0f 90       	pop	r0
    2510:	cf 91       	pop	r28
    2512:	df 91       	pop	r29
    2514:	08 95       	ret

00002516 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2516:	df 93       	push	r29
    2518:	cf 93       	push	r28
    251a:	00 d0       	rcall	.+0      	; 0x251c <prvCheckTasksWaitingTermination+0x6>
    251c:	0f 92       	push	r0
    251e:	cd b7       	in	r28, 0x3d	; 61
    2520:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    2522:	80 91 fe 02 	lds	r24, 0x02FE
    2526:	88 23       	and	r24, r24
    2528:	71 f1       	breq	.+92     	; 0x2586 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    252a:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    252e:	80 91 44 03 	lds	r24, 0x0344
    2532:	1b 82       	std	Y+3, r1	; 0x03
    2534:	88 23       	and	r24, r24
    2536:	11 f4       	brne	.+4      	; 0x253c <prvCheckTasksWaitingTermination+0x26>
    2538:	81 e0       	ldi	r24, 0x01	; 1
    253a:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    253c:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2540:	8b 81       	ldd	r24, Y+3	; 0x03
    2542:	88 23       	and	r24, r24
    2544:	01 f5       	brne	.+64     	; 0x2586 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2546:	0f b6       	in	r0, 0x3f	; 63
    2548:	f8 94       	cli
    254a:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    254c:	e0 91 49 03 	lds	r30, 0x0349
    2550:	f0 91 4a 03 	lds	r31, 0x034A
    2554:	86 81       	ldd	r24, Z+6	; 0x06
    2556:	97 81       	ldd	r25, Z+7	; 0x07
    2558:	9a 83       	std	Y+2, r25	; 0x02
    255a:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    255c:	89 81       	ldd	r24, Y+1	; 0x01
    255e:	9a 81       	ldd	r25, Y+2	; 0x02
    2560:	02 96       	adiw	r24, 0x02	; 2
    2562:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <vListRemove>
					--uxCurrentNumberOfTasks;
    2566:	80 91 ff 02 	lds	r24, 0x02FF
    256a:	81 50       	subi	r24, 0x01	; 1
    256c:	80 93 ff 02 	sts	0x02FF, r24
					--uxTasksDeleted;
    2570:	80 91 fe 02 	lds	r24, 0x02FE
    2574:	81 50       	subi	r24, 0x01	; 1
    2576:	80 93 fe 02 	sts	0x02FE, r24
				}
				taskEXIT_CRITICAL();
    257a:	0f 90       	pop	r0
    257c:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    257e:	89 81       	ldd	r24, Y+1	; 0x01
    2580:	9a 81       	ldd	r25, Y+2	; 0x02
    2582:	0e 94 62 13 	call	0x26c4	; 0x26c4 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    2586:	0f 90       	pop	r0
    2588:	0f 90       	pop	r0
    258a:	0f 90       	pop	r0
    258c:	cf 91       	pop	r28
    258e:	df 91       	pop	r29
    2590:	08 95       	ret

00002592 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2592:	df 93       	push	r29
    2594:	cf 93       	push	r28
    2596:	00 d0       	rcall	.+0      	; 0x2598 <prvAddCurrentTaskToDelayedList+0x6>
    2598:	cd b7       	in	r28, 0x3d	; 61
    259a:	de b7       	in	r29, 0x3e	; 62
    259c:	9a 83       	std	Y+2, r25	; 0x02
    259e:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    25a0:	e0 91 fc 02 	lds	r30, 0x02FC
    25a4:	f0 91 fd 02 	lds	r31, 0x02FD
    25a8:	89 81       	ldd	r24, Y+1	; 0x01
    25aa:	9a 81       	ldd	r25, Y+2	; 0x02
    25ac:	93 83       	std	Z+3, r25	; 0x03
    25ae:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    25b0:	20 91 00 03 	lds	r18, 0x0300
    25b4:	30 91 01 03 	lds	r19, 0x0301
    25b8:	89 81       	ldd	r24, Y+1	; 0x01
    25ba:	9a 81       	ldd	r25, Y+2	; 0x02
    25bc:	82 17       	cp	r24, r18
    25be:	93 07       	cpc	r25, r19
    25c0:	70 f4       	brcc	.+28     	; 0x25de <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25c2:	80 91 39 03 	lds	r24, 0x0339
    25c6:	90 91 3a 03 	lds	r25, 0x033A
    25ca:	20 91 fc 02 	lds	r18, 0x02FC
    25ce:	30 91 fd 02 	lds	r19, 0x02FD
    25d2:	2e 5f       	subi	r18, 0xFE	; 254
    25d4:	3f 4f       	sbci	r19, 0xFF	; 255
    25d6:	b9 01       	movw	r22, r18
    25d8:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsert>
    25dc:	1e c0       	rjmp	.+60     	; 0x261a <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25de:	40 91 37 03 	lds	r20, 0x0337
    25e2:	50 91 38 03 	lds	r21, 0x0338
    25e6:	80 91 fc 02 	lds	r24, 0x02FC
    25ea:	90 91 fd 02 	lds	r25, 0x02FD
    25ee:	9c 01       	movw	r18, r24
    25f0:	2e 5f       	subi	r18, 0xFE	; 254
    25f2:	3f 4f       	sbci	r19, 0xFF	; 255
    25f4:	ca 01       	movw	r24, r20
    25f6:	b9 01       	movw	r22, r18
    25f8:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    25fc:	20 91 65 00 	lds	r18, 0x0065
    2600:	30 91 66 00 	lds	r19, 0x0066
    2604:	89 81       	ldd	r24, Y+1	; 0x01
    2606:	9a 81       	ldd	r25, Y+2	; 0x02
    2608:	82 17       	cp	r24, r18
    260a:	93 07       	cpc	r25, r19
    260c:	30 f4       	brcc	.+12     	; 0x261a <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    260e:	89 81       	ldd	r24, Y+1	; 0x01
    2610:	9a 81       	ldd	r25, Y+2	; 0x02
    2612:	90 93 66 00 	sts	0x0066, r25
    2616:	80 93 65 00 	sts	0x0065, r24
		}
	}
}
    261a:	0f 90       	pop	r0
    261c:	0f 90       	pop	r0
    261e:	cf 91       	pop	r28
    2620:	df 91       	pop	r29
    2622:	08 95       	ret

00002624 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    2624:	df 93       	push	r29
    2626:	cf 93       	push	r28
    2628:	cd b7       	in	r28, 0x3d	; 61
    262a:	de b7       	in	r29, 0x3e	; 62
    262c:	28 97       	sbiw	r28, 0x08	; 8
    262e:	0f b6       	in	r0, 0x3f	; 63
    2630:	f8 94       	cli
    2632:	de bf       	out	0x3e, r29	; 62
    2634:	0f be       	out	0x3f, r0	; 63
    2636:	cd bf       	out	0x3d, r28	; 61
    2638:	9c 83       	std	Y+4, r25	; 0x04
    263a:	8b 83       	std	Y+3, r24	; 0x03
    263c:	7e 83       	std	Y+6, r23	; 0x06
    263e:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2640:	81 e2       	ldi	r24, 0x21	; 33
    2642:	90 e0       	ldi	r25, 0x00	; 0
    2644:	0e 94 93 03 	call	0x726	; 0x726 <pvPortMalloc>
    2648:	9a 83       	std	Y+2, r25	; 0x02
    264a:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    264c:	89 81       	ldd	r24, Y+1	; 0x01
    264e:	9a 81       	ldd	r25, Y+2	; 0x02
    2650:	00 97       	sbiw	r24, 0x00	; 0
    2652:	69 f1       	breq	.+90     	; 0x26ae <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2654:	8d 81       	ldd	r24, Y+5	; 0x05
    2656:	9e 81       	ldd	r25, Y+6	; 0x06
    2658:	00 97       	sbiw	r24, 0x00	; 0
    265a:	39 f4       	brne	.+14     	; 0x266a <prvAllocateTCBAndStack+0x46>
    265c:	8b 81       	ldd	r24, Y+3	; 0x03
    265e:	9c 81       	ldd	r25, Y+4	; 0x04
    2660:	0e 94 93 03 	call	0x726	; 0x726 <pvPortMalloc>
    2664:	98 87       	std	Y+8, r25	; 0x08
    2666:	8f 83       	std	Y+7, r24	; 0x07
    2668:	04 c0       	rjmp	.+8      	; 0x2672 <prvAllocateTCBAndStack+0x4e>
    266a:	8d 81       	ldd	r24, Y+5	; 0x05
    266c:	9e 81       	ldd	r25, Y+6	; 0x06
    266e:	98 87       	std	Y+8, r25	; 0x08
    2670:	8f 83       	std	Y+7, r24	; 0x07
    2672:	e9 81       	ldd	r30, Y+1	; 0x01
    2674:	fa 81       	ldd	r31, Y+2	; 0x02
    2676:	8f 81       	ldd	r24, Y+7	; 0x07
    2678:	98 85       	ldd	r25, Y+8	; 0x08
    267a:	90 8f       	std	Z+24, r25	; 0x18
    267c:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    267e:	e9 81       	ldd	r30, Y+1	; 0x01
    2680:	fa 81       	ldd	r31, Y+2	; 0x02
    2682:	87 89       	ldd	r24, Z+23	; 0x17
    2684:	90 8d       	ldd	r25, Z+24	; 0x18
    2686:	00 97       	sbiw	r24, 0x00	; 0
    2688:	39 f4       	brne	.+14     	; 0x2698 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    268a:	89 81       	ldd	r24, Y+1	; 0x01
    268c:	9a 81       	ldd	r25, Y+2	; 0x02
    268e:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <vPortFree>
			pxNewTCB = NULL;
    2692:	1a 82       	std	Y+2, r1	; 0x02
    2694:	19 82       	std	Y+1, r1	; 0x01
    2696:	0b c0       	rjmp	.+22     	; 0x26ae <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2698:	e9 81       	ldd	r30, Y+1	; 0x01
    269a:	fa 81       	ldd	r31, Y+2	; 0x02
    269c:	87 89       	ldd	r24, Z+23	; 0x17
    269e:	90 8d       	ldd	r25, Z+24	; 0x18
    26a0:	2b 81       	ldd	r18, Y+3	; 0x03
    26a2:	3c 81       	ldd	r19, Y+4	; 0x04
    26a4:	65 ea       	ldi	r22, 0xA5	; 165
    26a6:	70 e0       	ldi	r23, 0x00	; 0
    26a8:	a9 01       	movw	r20, r18
    26aa:	0e 94 81 13 	call	0x2702	; 0x2702 <memset>
		}
	}

	return pxNewTCB;
    26ae:	89 81       	ldd	r24, Y+1	; 0x01
    26b0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    26b2:	28 96       	adiw	r28, 0x08	; 8
    26b4:	0f b6       	in	r0, 0x3f	; 63
    26b6:	f8 94       	cli
    26b8:	de bf       	out	0x3e, r29	; 62
    26ba:	0f be       	out	0x3f, r0	; 63
    26bc:	cd bf       	out	0x3d, r28	; 61
    26be:	cf 91       	pop	r28
    26c0:	df 91       	pop	r29
    26c2:	08 95       	ret

000026c4 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    26c4:	df 93       	push	r29
    26c6:	cf 93       	push	r28
    26c8:	00 d0       	rcall	.+0      	; 0x26ca <prvDeleteTCB+0x6>
    26ca:	cd b7       	in	r28, 0x3d	; 61
    26cc:	de b7       	in	r29, 0x3e	; 62
    26ce:	9a 83       	std	Y+2, r25	; 0x02
    26d0:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    26d2:	e9 81       	ldd	r30, Y+1	; 0x01
    26d4:	fa 81       	ldd	r31, Y+2	; 0x02
    26d6:	87 89       	ldd	r24, Z+23	; 0x17
    26d8:	90 8d       	ldd	r25, Z+24	; 0x18
    26da:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <vPortFree>
		vPortFree( pxTCB );
    26de:	89 81       	ldd	r24, Y+1	; 0x01
    26e0:	9a 81       	ldd	r25, Y+2	; 0x02
    26e2:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <vPortFree>
	}
    26e6:	0f 90       	pop	r0
    26e8:	0f 90       	pop	r0
    26ea:	cf 91       	pop	r28
    26ec:	df 91       	pop	r29
    26ee:	08 95       	ret

000026f0 <memcpy>:
    26f0:	fb 01       	movw	r30, r22
    26f2:	dc 01       	movw	r26, r24
    26f4:	02 c0       	rjmp	.+4      	; 0x26fa <memcpy+0xa>
    26f6:	01 90       	ld	r0, Z+
    26f8:	0d 92       	st	X+, r0
    26fa:	41 50       	subi	r20, 0x01	; 1
    26fc:	50 40       	sbci	r21, 0x00	; 0
    26fe:	d8 f7       	brcc	.-10     	; 0x26f6 <memcpy+0x6>
    2700:	08 95       	ret

00002702 <memset>:
    2702:	dc 01       	movw	r26, r24
    2704:	01 c0       	rjmp	.+2      	; 0x2708 <memset+0x6>
    2706:	6d 93       	st	X+, r22
    2708:	41 50       	subi	r20, 0x01	; 1
    270a:	50 40       	sbci	r21, 0x00	; 0
    270c:	e0 f7       	brcc	.-8      	; 0x2706 <memset+0x4>
    270e:	08 95       	ret

00002710 <strncpy>:
    2710:	fb 01       	movw	r30, r22
    2712:	dc 01       	movw	r26, r24
    2714:	41 50       	subi	r20, 0x01	; 1
    2716:	50 40       	sbci	r21, 0x00	; 0
    2718:	48 f0       	brcs	.+18     	; 0x272c <strncpy+0x1c>
    271a:	01 90       	ld	r0, Z+
    271c:	0d 92       	st	X+, r0
    271e:	00 20       	and	r0, r0
    2720:	c9 f7       	brne	.-14     	; 0x2714 <strncpy+0x4>
    2722:	01 c0       	rjmp	.+2      	; 0x2726 <strncpy+0x16>
    2724:	1d 92       	st	X+, r1
    2726:	41 50       	subi	r20, 0x01	; 1
    2728:	50 40       	sbci	r21, 0x00	; 0
    272a:	e0 f7       	brcc	.-8      	; 0x2724 <strncpy+0x14>
    272c:	08 95       	ret

0000272e <_exit>:
    272e:	f8 94       	cli

00002730 <__stop_program>:
    2730:	ff cf       	rjmp	.-2      	; 0x2730 <__stop_program>
